<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Undecimus 分析（二）通过 String XREF 定位内核数据"><meta name="keywords" content="JailBreak,Undecimus,XREF"><meta name="author" content="高级页面仔 (Soulghost)"><meta name="copyright" content="高级页面仔 (Soulghost)"><title>Undecimus 分析（二）通过 String XREF 定位内核数据 | iOS Security Cabin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定位-Kernel-Task"><span class="toc-number">2.</span> <span class="toc-text">定位 Kernel Task</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#查找使用-Kernel-Task-的函数"><span class="toc-number">2.1.</span> <span class="toc-text">查找使用 Kernel Task 的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定位到函数中的-String-XREF"><span class="toc-number">2.2.</span> <span class="toc-text">定位到函数中的 String XREF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯找到-Kernel-Task-XREF"><span class="toc-number">2.3.</span> <span class="toc-text">回溯找到 Kernel Task XREF</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#在内存中加载-Kernelcache"><span class="toc-number">3.</span> <span class="toc-text">在内存中加载 Kernelcache</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Find-String-Based-XREF"><span class="toc-number">4.</span> <span class="toc-text">Find String Based XREF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定位字符串地址"><span class="toc-number">4.1.</span> <span class="toc-text">定位字符串地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搜索对字符串所在地址的寻址操作"><span class="toc-number">4.2.</span> <span class="toc-text">搜索对字符串所在地址的寻址操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过-String-XREF-定位变量地址"><span class="toc-number">5.</span> <span class="toc-text">通过 String XREF 定位变量地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/6300263?s=460&amp;u=c55866a279854c9150528b358802a75be5e6a507&amp;v=4"></div><div class="author-info__name text-center">高级页面仔 (Soulghost)</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Soulghost" target="_blank" rel="noopener">Follow Me on GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iOS Security Cabin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Undecimus 分析（二）通过 String XREF 定位内核数据</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-29</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在内核中有许多关键变量和校验，为获得这些变量和绕过校验就要求我们在内存中定位这些地址。本文将介绍 Undecimus 中基于 String XREF 定位关键内存地址的方法，通过该方法不仅可以准确定位内核中的特定元素，也能为自行设计二进制分析工具带来很好的启发。</p>
<h1 id="定位-Kernel-Task"><a href="#定位-Kernel-Task" class="headerlink" title="定位 Kernel Task"></a>定位 Kernel Task</h1><p>为了获取内核信息，我们需要定位到 Kernel Task 的地址，再通过 tfp0 的 kread 读取内容。要定位 Kernel Task，关键是找到获取 Kernel Task 的代码，然后尝试从内存中定位这段代码，再分析指令解出变量的文件偏移即可。</p>
<h2 id="查找使用-Kernel-Task-的函数"><a href="#查找使用-Kernel-Task-的函数" class="headerlink" title="查找使用 Kernel Task 的函数"></a>查找使用 Kernel Task 的函数</h2><p>在 <a href="https://github.com/apple/darwin-xnu/tree/xnu-4903.221.2" target="_blank" rel="noopener">xnu-4903.221.2</a> 中可以找到访问 Kernel Task 的如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">proc_apply_resource_actions(<span class="keyword">void</span> * bsdinfo, __unused <span class="keyword">int</span> type, <span class="keyword">int</span> action)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">proc_t</span> p = (<span class="keyword">proc_t</span>)bsdinfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(action) &#123;</span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_THROTTLE:</span><br><span class="line">        	<span class="comment">/* no need to do anything */</span></span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_SUSPEND:</span><br><span class="line">        	task_suspend(p-&gt;task);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_TERMINATE:</span><br><span class="line">        	psignal(p, SIGKILL);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_NOTIFY_KQ:</span><br><span class="line">        	<span class="comment">/* not implemented */</span></span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_NOTIFY_EXC:</span><br><span class="line">        	panic(<span class="string">"shouldn't be applying exception notification to process!"</span>);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一段字符串 “shouldn’t be applying exception notification to process!” 可用于辅助定位，它在编译后会被存储在 <code>__TEXT,__cstring</code> 段，通过在内存中搜索 <code>__TEXT,__cstring</code> 段即可找到字符串地址，我们称之为 <code>location_str</code>。</p>
<h2 id="定位到函数中的-String-XREF"><a href="#定位到函数中的-String-XREF" class="headerlink" title="定位到函数中的 String XREF"></a>定位到函数中的 String XREF</h2><p>由于 ARM 的取址常常需要 2 条指令完成，为了定位使用 <code>location_str</code> 的代码，我们需要对代码段进行静态分析。当发现寄存器中的值等于 <code>location_str</code> 时即发现了一个交叉引用(XREF)，通过这种手段我们便能在内存中定位到语句 <code>panic(&quot;shouldn&#39;t be applying exception notification to process!&quot;)</code> 对应的指令地址。</p>
<h2 id="回溯找到-Kernel-Task-XREF"><a href="#回溯找到-Kernel-Task-XREF" class="headerlink" title="回溯找到 Kernel Task XREF"></a>回溯找到 Kernel Task XREF</h2><p>最快定位到 Kernel Task 的方法是回溯到 <code>task_suspend(p-&gt;task)</code>，在 <code>task_suspend</code> 第一次访问 <code>p-&gt;task</code> 时一定会对 task 寻址，我们可以从寻址指令中解出 task 的文件偏移，再加上内核在内存中的基地址即可得到 Kernel Task 的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">task_suspend(<span class="keyword">task_t</span> task)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">mach_port_t</span> port, send, old_notify;</span><br><span class="line">    <span class="keyword">mach_port_name_t</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (task == TASK_NULL || task == kernel_task)</span><br><span class="line">    	<span class="keyword">return</span> (KERN_INVALID_ARGUMENT);</span><br><span class="line">    </span><br><span class="line">    task_lock(task);</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>从上面的分析可以看出问题的关键在于 XREF 的定位，下面我们将分析一种 String Based XREF 定位算法来解决上述问题。</p>
<h1 id="在内存中加载-Kernelcache"><a href="#在内存中加载-Kernelcache" class="headerlink" title="在内存中加载 Kernelcache"></a>在内存中加载 Kernelcache</h1><p>根据 iPhone Wiki 给出的 Kernelcache 定义[1]：</p>
<blockquote>
<p>The kernelcache is basically the kernel itself as well as all of its extensions (AppleImage3NORAccess, IOAESAccelerator, IOPKEAccelerator, etc.) into one file, then packed/encrypted in an IMG3 (iPhone OS 2.0 and above) or 8900 (iPhone OS 1.0 through 1.1.4) container.</p>
</blockquote>
<p>即 kernelcache 就是将 kernel 和它的扩展打包在一个文件中并以 IMG3 格式存储(iOS 2 以上)。</p>
<p>在 <a href="https://juejin.im/post/5df5f6416fb9a016402d1cc0" target="_blank" rel="noopener">上一篇文章</a> 中我们介绍了基于 tfp0 的沙盒逃逸方法，通过沙盒逃逸我们可以从 <code>/System/Library/Caches/com.apple.kernelcaches/kernelcache</code> 读取 kernelcache，它既是当前系统加载的镜像。</p>
<p>读者可打开 Undecimus 的 <code>jailbreak.m</code> 文件，搜索 “Initializing patchfinder” 定位到 kernelcache 的加载代码，加载方法和普通的 <code>Mach-O</code> 文件类似，也是先读取 <code>Mach Header</code> 和 <code>Load Commands</code>，然后逐段记录偏移量，具体代码在 <code>init_kernel</code> 函数中。</p>
<p>这里不再赘述加载过程，只指出几个关键的全局变量：</p>
<ol>
<li><code>cstring_base</code> 和 <code>cstring_size</code> 是 <code>__TEXT,__cstring</code> 段的虚拟地址和长度；</li>
<li><code>xnucore_base</code> 和 <code>xnucore_size</code> 是 <code>__TEXT,__TEXT_EXEC</code> 段，即代码段的虚拟地址和长度；</li>
<li><code>kerndumpbase</code> 是所有段中最小的虚拟地址，即 kernelcache 加载的虚拟基地址，在普通的 <code>Mach-O</code> 文件中这个值一般是 <code>__PAGEZERO</code> 段的虚拟地址 0x100000000，在内核中似乎是 <code>__TEXT</code> 段的虚拟地址 0xFFFFFFF007004000；</li>
<li><code>kernel</code> 是 kernelcache 在用户空间的完整映射，即一份完整加载的内核镜像。</li>
</ol>
<h1 id="Find-String-Based-XREF"><a href="#Find-String-Based-XREF" class="headerlink" title="Find String Based XREF"></a>Find String Based XREF</h1><p>在 Undecimus 中包含一个 <code>find_strref</code> 函数用于定位字符串的 XREF：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span></span><br><span class="line">find_strref(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">int</span> n, <span class="keyword">enum</span> string_bases string_base, <span class="keyword">bool</span> full_match, <span class="keyword">bool</span> ppl_base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *str;</span><br><span class="line">    <span class="keyword">addr_t</span> base;</span><br><span class="line">    <span class="keyword">addr_t</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">enum</span> text_bases text_base = ppl_base?text_ppl_base:text_xnucore_base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (string_base) &#123;</span><br><span class="line">        <span class="keyword">case</span> string_base_const:</span><br><span class="line">            base = const_base;</span><br><span class="line">            <span class="built_in">size</span> = const_size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> string_base_data:</span><br><span class="line">            base = data_base;</span><br><span class="line">            <span class="built_in">size</span> = data_size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> string_base_oslstring:</span><br><span class="line">            base = oslstring_base;</span><br><span class="line">            <span class="built_in">size</span> = oslstring_size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> string_base_pstring:</span><br><span class="line">            base = pstring_base;</span><br><span class="line">            <span class="built_in">size</span> = pstring_size;</span><br><span class="line">            text_base = text_prelink_base;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> string_base_cstring:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            base = cstring_base;</span><br><span class="line">            <span class="built_in">size</span> = cstring_size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">addr_t</span> off = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = boyermoore_horspool_memmem(kernel + base + off, <span class="built_in">size</span> - off, (<span class="keyword">uint8_t</span> *)<span class="built_in">string</span>, <span class="built_in">strlen</span>(<span class="built_in">string</span>)))) &#123;</span><br><span class="line">        <span class="comment">// Only match the beginning of strings</span></span><br><span class="line">        <span class="comment">// first_string || \0this_string</span></span><br><span class="line">        <span class="keyword">if</span> ((str == kernel + base || *(str<span class="number">-1</span>) == <span class="string">'\0'</span>) &amp;&amp; (!full_match || <span class="built_in">strcmp</span>((<span class="keyword">char</span> *)str, <span class="built_in">string</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// find after str</span></span><br><span class="line">        off = str - (kernel + base) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!str) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find xref</span></span><br><span class="line">    <span class="keyword">return</span> find_reference(str - kernel + kerndumpbase, n, text_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它要求传入字符串 string，引用的序号 n，基准段 string_base，是否完全匹配 <code>full_match</code>，以及是否位于 <code>__PPLTEXT</code> 段，对于寻找 Kernel Task 的场景，我们的入参如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span> str = find_strref(<span class="string">"\"shouldn't be applying exception notification"</span>, <span class="number">2</span>, string_base_cstring, <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>即以 <code>__TEXT,__cstring</code> 为基准，不要求完全匹配，找到第 2 个交叉引用所在的地址。</p>
<h2 id="定位字符串地址"><a href="#定位字符串地址" class="headerlink" title="定位字符串地址"></a>定位字符串地址</h2><p>字符串地址的定位逻辑在 <code>boyermoore_horspool_memmem</code> 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *</span><br><span class="line">boyermoore_horspool_memmem(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* haystack, <span class="keyword">size_t</span> hlen,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* needle,   <span class="keyword">size_t</span> nlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> last, scan = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> bad_char_skip[UCHAR_MAX + <span class="number">1</span>]; <span class="comment">/* Officially called:</span></span><br><span class="line"><span class="comment">                                          * bad character shift */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity checks on the parameters */</span></span><br><span class="line">    <span class="keyword">if</span> (nlen &lt;= <span class="number">0</span> || !haystack || !needle)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---- Preprocess ---- */</span></span><br><span class="line">    <span class="comment">/* Initialize the table to default value */</span></span><br><span class="line">    <span class="comment">/* When a character is encountered that does not occur</span></span><br><span class="line"><span class="comment">     * in the needle, we can safely skip ahead for the whole</span></span><br><span class="line"><span class="comment">     * length of the needle.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (scan = <span class="number">0</span>; scan &lt;= UCHAR_MAX; scan = scan + <span class="number">1</span>)</span><br><span class="line">        bad_char_skip[scan] = nlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C arrays have the first byte at [0], therefore:</span></span><br><span class="line"><span class="comment">     * [nlen - 1] is the last byte of the array. */</span></span><br><span class="line">    last = nlen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then populate it with the analysis of the needle */</span></span><br><span class="line">    <span class="keyword">for</span> (scan = <span class="number">0</span>; scan &lt; last; scan = scan + <span class="number">1</span>)</span><br><span class="line">        bad_char_skip[needle[scan]] = last - scan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---- Do the matching ---- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search the haystack, while the needle can still be within it. */</span></span><br><span class="line">    <span class="keyword">while</span> (hlen &gt;= nlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* scan from the end of the needle */</span></span><br><span class="line">        <span class="keyword">for</span> (scan = last; haystack[scan] == needle[scan]; scan = scan - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (scan == <span class="number">0</span>) <span class="comment">/* If the first byte matches, we've found it. */</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)haystack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* otherwise, we need to skip some bytes and start again.</span></span><br><span class="line"><span class="comment">           Note that here we are getting the skip value based on the last byte</span></span><br><span class="line"><span class="comment">           of needle, no matter where we didn't match. So if needle is: "abcd"</span></span><br><span class="line"><span class="comment">           then we are skipping based on 'd' and that value will be 4, and</span></span><br><span class="line"><span class="comment">           for "abcdd" we again skip on 'd' but the value will be only 1.</span></span><br><span class="line"><span class="comment">           The alternative of pretending that the mismatched character was</span></span><br><span class="line"><span class="comment">           the last character is slower in the normal case (E.g. finding</span></span><br><span class="line"><span class="comment">           "abcd" in "...azcd..." gives 4 by using 'd' but only</span></span><br><span class="line"><span class="comment">           4-2==2 using 'z'. */</span></span><br><span class="line">        hlen     -= bad_char_skip[haystack[last]];</span><br><span class="line">        haystack += bad_char_skip[haystack[last]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先根据调用分析入参：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span> base = cstring_base;</span><br><span class="line"><span class="keyword">addr_t</span> off = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((str = boyermoore_horspool_memmem(kernel + base + off, <span class="built_in">size</span> - off, (<span class="keyword">uint8_t</span> *)<span class="built_in">string</span>, <span class="built_in">strlen</span>(<span class="built_in">string</span>)))) &#123;</span><br><span class="line">    <span class="comment">// Only match the beginning of strings</span></span><br><span class="line">    <span class="comment">// first_string || \0this_string</span></span><br><span class="line">    <span class="keyword">if</span> ((str == kernel + base || *(str<span class="number">-1</span>) == <span class="string">'\0'</span>) &amp;&amp; (!full_match || <span class="built_in">strcmp</span>((<span class="keyword">char</span> *)str, <span class="built_in">string</span>) == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// find after str</span></span><br><span class="line">    off = str - (kernel + base) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>haystack = kernel + base + off，即 <code>__TEXT,__cstring</code> 段的起始地址；</li>
<li>hlen = size - off，即 <code>__TEXT,__cstring</code> 段的长度；</li>
<li>needle = string 即待查找字符串指针；</li>
<li>nlen = strlen(string) 即待查找字符串的长度。</li>
</ol>
<p>在函数的开头首先维护了一个 <code>bad_char_skip</code> 数组来记录当匹配失败时，应当跳过多少个字符来避免无意义的匹配。整个算法采用了倒序扫描的方式，不断从 <code>haystack[needle_len - 1]</code> 向前扫描并检查 <code>haystack[i] == needle[i]</code>，当匹配到 <code>haystack[0]</code> 时如果依然满足条件，说明找到了字符串的地址，否则根据匹配失败的字符查 <code>bad_char_skip</code> 表将 haystack 指针后移继续匹配。</p>
<p><strong>需要注意的是，在匹配成功后得到的字符串地址是相对于用户空间的 kernelcache 映射 <code>kernel</code> 的，并非是字符串在内核中的实际地址。</strong></p>
<h2 id="搜索对字符串所在地址的寻址操作"><a href="#搜索对字符串所在地址的寻址操作" class="headerlink" title="搜索对字符串所在地址的寻址操作"></a>搜索对字符串所在地址的寻址操作</h2><p>在获取到字符串在用户空间的地址 <code>str</code> 后，首先需要计算它在 kernelcache 中的虚拟地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span> str_vmaddr = str - kernel + kerndumpbase;</span><br></pre></td></tr></table></figure>

<p>内核代码中对 str 的引用一定涉及到对 <code>str_vmaddr</code> 的寻址，主要的寻址方式有以下几种：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 1</span></span><br><span class="line"><span class="keyword">adrp </span>xn, <span class="keyword">str@PAGE</span></span><br><span class="line"><span class="keyword">add </span>xn, xn, <span class="keyword">str@PAGEOFF</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">; </span><span class="number">2</span></span><br><span class="line"><span class="keyword">ldr </span>xn, [xm, <span class="symbol">#imm</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">; 3</span></span><br><span class="line"><span class="keyword">ldr </span>xn, =<span class="symbol">#imm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 4</span></span><br><span class="line"><span class="keyword">adr </span>xn, <span class="symbol">#imm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 5</span></span><br><span class="line"><span class="keyword">bl </span><span class="symbol">#addr</span></span><br></pre></td></tr></table></figure>

<p>在 <code>find_strref</code> 的尾部调用了 <code>return find_reference(str_vmaddr, n, text_base)</code>，<code>find_reference</code> 对 <code>__TEXT_EXEC,__text</code> 进行了静态分析，对寻址相关的指令模拟了寄存器运算，主要逻辑在 <code>xref64</code> 函数中，当发现寄存器中的值等于 <code>str_vmaddr</code> 时即找到了一条对 str 的交叉引用。</p>
<p>这里的代码主要是对机器码的解码和运算操作，篇幅较长不再贴出，读者有兴趣可以自行阅读。</p>
<h1 id="通过-String-XREF-定位变量地址"><a href="#通过-String-XREF-定位变量地址" class="headerlink" title="通过 String XREF 定位变量地址"></a>通过 String XREF 定位变量地址</h1><p>上文中我们已经得到了目标函数 <code>proc_apply_resource_actions</code> 中对 str 的引用地址，随后需要向上回溯定位 <code>task_suspend</code> 函数的调用指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">addr_t</span> <span class="title">find_kernel_task</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">             adrp x8,     str@PAGE</span></span><br><span class="line"><span class="comment">     str --&gt; add  x8, x8, str@PAGEOFF</span></span><br><span class="line"><span class="comment">             bl   _panic</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">addr_t</span> str = find_strref(<span class="string">"\"shouldn't be applying exception notification"</span>, <span class="number">2</span>, string_base_cstring, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    str -= kerndumpbase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find bl _task_suspend</span></span><br><span class="line">    <span class="keyword">addr_t</span> call = step64_back(kernel, str, <span class="number">0x10</span>, INSN_CALL);</span><br><span class="line">    <span class="keyword">if</span> (!call) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">addr_t</span> task_suspend = follow_call64(kernel, call);</span><br><span class="line">    <span class="keyword">if</span> (!task_suspend) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">addr_t</span> adrp = step64(kernel, task_suspend, <span class="number">20</span>*<span class="number">4</span>, INSN_ADRP);</span><br><span class="line">    <span class="keyword">if</span> (!adrp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">addr_t</span> kern_task = calc64(kernel, adrp, adrp + <span class="number">0x8</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kern_task) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kern_task + kerndumpbase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程主要分 3 步：</p>
<ol>
<li>回溯找到 <code>bl _task_suspend</code> 的调用点，解出 <code>task_suspend</code> 函数的地址；</li>
<li>从 <code>task_suspend</code> 函数向后搜寻第一条 adrp 指令，即是对 Kernel Task 的寻址；</li>
<li>从寻址指令中解出 Kernel Task 地址。</li>
</ol>
<p>我们再回过头来看 <code>proc_apply_resource_actions</code> 函数片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(action) &#123;</span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_THROTTLE:</span><br><span class="line">		<span class="comment">/* no need to do anything */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_SUSPEND:</span><br><span class="line">		task_suspend(p-&gt;task);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_TERMINATE:</span><br><span class="line">		psignal(p, SIGKILL);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_NOTIFY_KQ:</span><br><span class="line">		<span class="comment">/* not implemented */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_NOTIFY_EXC:</span><br><span class="line">		panic(<span class="string">"shouldn't be applying exception notification to process!"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时不一定会按照 case 的顺序生成机器码，因此我们需要根据 str XREF 找到 kernelcache 中的实际表示，一个简单地办法是在 <code>find_strref(&quot;\&quot;shouldn&#39;t be applying exception notification&quot;, 2, string_base_cstring, false, false)</code> 后打一个断点来获取 str XREF 的文件偏移，再利用二进制分析工具反汇编 kernelcache 中的这个部分。</p>
<p>通过断点调试可知 str XREF 位于 0x0000000000f9f084，这应该是一条 add 指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         adrp x8,     str@PAGE</span></span><br><span class="line"><span class="comment"> str --&gt; add  x8, x8, str@PAGEOFF</span></span><br><span class="line"><span class="comment">         bl   _panic</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>在 <code>Mach-O</code> 查看器中打开可以发现，0x0000000000f9f084 确实是一条 add 指令：<br><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f519149c6a5e33?w=818&h=272&f=png&s=57926" alt=""></p>
<p>要定位 <code>task_suspend(p-&gt;task)</code> 有两种方式，其一是 <code>p-&gt;task</code> 是一个基于偏移量的结构体成员寻址有明显特征，第二个是看函数调用前的参数准备。在 0xf9f074 处有一个 +16 的偏移量寻址，显然这是对 <code>p-&gt;task</code> 地址的计算，因此 0xf9f078 处即是 <code>task_suspend(p-&gt;task)</code> 的调用。</p>
<p>所以从 add 指令处向前回溯 3 条指令即可，找到这条 CALL 指令后，即可从中解出 <code>task_suspend</code>的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find bl _task_suspend</span></span><br><span class="line"><span class="keyword">addr_t</span> call = step64_back(kernel, str, <span class="number">0x10</span>, INSN_CALL);</span><br><span class="line"><span class="keyword">if</span> (!call) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">addr_t</span> task_suspend = follow_call64(kernel, call);</span><br><span class="line"><span class="keyword">if</span> (!task_suspend) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>随后我们从 <code>task_suspend</code> 函数的起始地址开始向后搜寻第一个 adrp 指令即可找到对 Kernel Task 的 adrp 语句，静态分析 adrp &amp; add 即可计算出 Kernel Task 的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span> adrp = step64(kernel, task_suspend, <span class="number">20</span>*<span class="number">4</span>, INSN_ADRP);</span><br><span class="line"><span class="keyword">if</span> (!adrp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">addr_t</span> kern_task = calc64(kernel, adrp, adrp + <span class="number">0x8</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (!kern_task) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>注意这里我们得到的依然是 fileoff，需要加上 <code>kerndumpbase</code> 得到虚拟地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> kern_task + kerndumpbase;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，如果要在内核中读取 Kernel Task，这个地址需要加上 kernel_slide 才可以。计算 kernel_slide 的代码紧跟在 tfp0 之后，读者有兴趣可以自行阅读。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细分析了 Undecimus 中基于 string 的交叉引用在内存中定位代码和变量的技术，通过该技术可以实现内核中变量地址的定位，随后可通过读写实现绕过检测和注入等操作。该技术不仅是完成 Jailbreak 的关键技术，也能给读者带来二进制静态分析的一些启发。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.theiphonewiki.com/wiki/Kernelcache" target="_blank" rel="noopener">The iPhone Wiki: Kernelcache</a></li>
<li><a href="https://github.com/apple/darwin-xnu/tree/xnu-4903.221.2" target="_blank" rel="noopener">Apple: Darwin-XNU</a></li>
<li><a href="https://github.com/pwn20wndstuff/Undecimus" target="_blank" rel="noopener">Github/pwn20wndstuff: Undecimus</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高级页面仔 (Soulghost)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.asm.im/2019/12/29/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-String-XREF-%E5%AE%9A%E4%BD%8D%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE/">http://blog.asm.im/2019/12/29/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-String-XREF-%E5%AE%9A%E4%BD%8D%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JailBreak/">JailBreak</a><a class="post-meta__tags" href="/tags/Undecimus/">Undecimus</a><a class="post-meta__tags" href="/tags/XREF/">XREF</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/01/12/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E8%BF%87-IOTrap-%E5%AE%9E%E7%8E%B0%E5%86%85%E6%A0%B8%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"><i class="fa fa-chevron-left">  </i><span>Undecimus 分析（三）通过 IOTrap 实现内核任意代码执行</span></a></div><div class="next-post pull-right"><a href="/2019/12/15/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Escape-from-Sandbox/"><span>Undecimus 分析（一）Escape from Sandbox</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 高级页面仔 (Soulghost)</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><i class="fa fa-user"> 0xfffffff007004000</i><span class="footer-separator">|</span><i class="fa fa-eye"> 0x2004000</i></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>