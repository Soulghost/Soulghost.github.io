<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="iOS-Jailbreak-Principles-0x03-amfi-kext-的加载和工作过程"><meta name="keywords" content=""><meta name="author" content="高级页面仔 (Soulghost)"><meta name="copyright" content="高级页面仔 (Soulghost)"><title>iOS-Jailbreak-Principles-0x03-amfi-kext-的加载和工作过程 | iOS Security Cabin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#系列文章"><span class="toc-number">1.</span> <span class="toc-text">系列文章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kernel-Extension"><span class="toc-number">3.</span> <span class="toc-text">Kernel Extension</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义"><span class="toc-number">3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pre-Linking"><span class="toc-number">3.2.</span> <span class="toc-text">Pre-Linking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分析-AppleMobileFileIntegrity-kext"><span class="toc-number">4.</span> <span class="toc-text">分析 AppleMobileFileIntegrity.kext</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#从-kernelcache-中分离"><span class="toc-number">4.1.</span> <span class="toc-text">从 kernelcache 中分离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-joker-分离-kext-binary"><span class="toc-number">4.1.1.</span> <span class="toc-text">通过 joker 分离 kext binary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-jtool-分离-PRELINK-INFO"><span class="toc-number">4.1.2.</span> <span class="toc-text">使用 jtool 分离 PRELINK_INFO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在-PRELINK-INFO-中查找关键信息"><span class="toc-number">4.2.</span> <span class="toc-text">在 PRELINK_INFO 中查找关键信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#猜测模块加载方式"><span class="toc-number">4.3.</span> <span class="toc-text">猜测模块加载方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AppleMobileFileIntegrity-kext-的注册"><span class="toc-number">5.</span> <span class="toc-text">AppleMobileFileIntegrity.kext 的注册</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#从启动到注册"><span class="toc-number">5.1.</span> <span class="toc-text">从启动到注册</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AppleMobileFileIntegrity-kext-的加载"><span class="toc-number">6.</span> <span class="toc-text">AppleMobileFileIntegrity.kext 的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#加载器的注入"><span class="toc-number">6.1.</span> <span class="toc-text">加载器的注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载器的-Caller"><span class="toc-number">6.2.</span> <span class="toc-text">加载器的 Caller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载逻辑"><span class="toc-number">6.3.</span> <span class="toc-text">加载逻辑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AppleMobileFileIntegrity-kext-注册到-IOKit"><span class="toc-number">7.</span> <span class="toc-text">AppleMobileFileIntegrity.kext 注册到 IOKit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#注册与启动服务"><span class="toc-number">7.1.</span> <span class="toc-text">注册与启动服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMFI-的启动流程"><span class="toc-number">7.2.</span> <span class="toc-text">AMFI 的启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化-libkern-C-环境"><span class="toc-number">7.3.</span> <span class="toc-text">初始化 libkern C++ 环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pre-阶段"><span class="toc-number">7.3.1.</span> <span class="toc-text">Pre 阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-阶段"><span class="toc-number">7.3.2.</span> <span class="toc-text">In 阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Post-阶段"><span class="toc-number">7.3.3.</span> <span class="toc-text">Post 阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取-AppleMobileFileIntegrity-kext-服务"><span class="toc-number">8.</span> <span class="toc-text">获取 AppleMobileFileIntegrity.kext 服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">10.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/6300263?s=460&amp;u=c55866a279854c9150528b358802a75be5e6a507&amp;v=4"></div><div class="author-info__name text-center">高级页面仔 (Soulghost)</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Soulghost" target="_blank" rel="noopener">Follow Me on GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iOS Security Cabin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">iOS-Jailbreak-Principles-0x03-amfi-kext-的加载和工作过程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-07-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5e8ad7ccf265da47b1778e17" target="_blank" rel="noopener">iOS Jailbreak Principles 0x01 - rootfs remount r/w 原理</a></li>
<li><a href="https://juejin.im/post/5ee5a9f26fb9a04802148379" target="_blank" rel="noopener">iOS Jailbreak Principles 0x02 - codesign and amfid bypass</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章中我们介绍了 amfid 的 codesign 机制及其绕过，amfid 是 codesign 逻辑在 userland 的一个 daemon，代表了 C/S 架构中的 Server。本文将介绍 kernel 侧的 amfi.kext，它是 amfid 的 Client，以 Kernel Extension 的形式被加载和注册到 Kernel 中。</p>
<h1 id="Kernel-Extension"><a href="#Kernel-Extension" class="headerlink" title="Kernel Extension"></a>Kernel Extension</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>XNU 是一个功能丰富的内核，包含了调度, 内存管理, I/O 等必要的服务，但它依然难以直接适配浩如烟海的硬件和外设，即使是宏内核也无法完全做到这一点[1]。</p>
<p>就像是 user mode application 中常常包含 dylib，在 kernel mode 也有 kernel modules 作为扩展，在 XNU 中被称为 kernel extensions，简称为 kext[1]。</p>
<h2 id="Pre-Linking"><a href="#Pre-Linking" class="headerlink" title="Pre-Linking"></a>Pre-Linking</h2><p>以常规视角而言，操作系统应当是先 boot kernel，随后 load kexts。在 iOS 中，kernel 和它的扩展不是以分离的文件形式存在，而是将 kernel 和 kexts 合并成一个 kernelcache 文件直接被 boot loader 加载。</p>
<p>kernelcache 带来了两个好处，其一是 kexts 不必再像 dylib 那样进行动态链接，省去了外部符号地址解析的过程，加快了加载速度；其二是 kernelcache 可以被完整的签名以降低 kext 被篡改的风险[1]。</p>
<h1 id="分析-AppleMobileFileIntegrity-kext"><a href="#分析-AppleMobileFileIntegrity-kext" class="headerlink" title="分析 AppleMobileFileIntegrity.kext"></a>分析 AppleMobileFileIntegrity.kext</h1><h2 id="从-kernelcache-中分离"><a href="#从-kernelcache-中分离" class="headerlink" title="从 kernelcache 中分离"></a>从 kernelcache 中分离</h2><p>由于 amfi.kext 被 prelink 到 kernelcache 中，因此其 Info.plist 和 binary 都直接包含在了庞大的 kernelcache 中，为了便于分析我们可以将它们从 kernelcache 中分离出来。</p>
<h3 id="通过-joker-分离-kext-binary"><a href="#通过-joker-分离-kext-binary" class="headerlink" title="通过 joker 分离 kext binary"></a>通过 joker 分离 kext binary</h3><p>使用 joker (<a href="http://www.newosxbook.com/tools/joker.html" target="_blank" rel="noopener">http://www.newosxbook.com/tools/joker.html</a>) 可以分离出 kext 和进行部分符号化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出目录</span></span><br><span class="line">&gt; <span class="built_in">cd</span> /tmp/kext</span><br><span class="line">&gt; <span class="built_in">export</span> JOKER_DIR=/tmp/kext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备好 kernelcache</span></span><br><span class="line">&gt; ls .</span><br><span class="line">kernelcache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离 amfi.kext</span></span><br><span class="line">&gt; joker -K com.apple.driver.AppleMobileFileIntegrity kernelcache</span><br><span class="line">Writing kext out to /tmp/kext/com.apple.driver.AppleMobileFileIntegrity.kext</span><br><span class="line">Symbolicated stubs to /tmp/kext/com.apple.driver.AppleMobileFileIntegrity.kext.ARM64.E815A4DD-90E7-3A38-A4BA-EFA2425BC543</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看产物</span></span><br><span class="line">&gt; ls .</span><br><span class="line">com.apple.driver.AppleMobileFileIntegrity.kext</span><br><span class="line">com.apple.driver.AppleMobileFileIntegrity.kext.ARM64.E815A4DD-90E7-3A38-A4BA-EFA2425BC543</span><br><span class="line">kernelcache</span><br></pre></td></tr></table></figure>

<p>可以看到我们得到了 kext 的 binary 和一份符号表，由于 kext 是从内核中分离的，与从 <code>dyld_shared_cache</code> 分离出 dylib 类似，有大量的外部地址无法正常解析，通过符号表或是在 kernelcache 中定位都可以帮助判断这些地址的含义和内容。</p>
<h3 id="使用-jtool-分离-PRELINK-INFO"><a href="#使用-jtool-分离-PRELINK-INFO" class="headerlink" title="使用 jtool 分离 PRELINK_INFO"></a>使用 jtool 分离 PRELINK_INFO</h3><p>与 App 通过 Info.plist 描述关键信息类似，kext 也有其 Info.plist 来描述 kext 的各种信息，其中包含了标识符、加载地址等关键信息，为了方便分析，我们还需要从 kernelcache 中分离出 amfi 的 Info.plist。这里我们使用 jtool (<a href="http://www.newosxbook.com/tools/jtool.html" target="_blank" rel="noopener">http://www.newosxbook.com/tools/jtool.html</a>) 来完成分离：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定输出目录</span></span><br><span class="line"><span class="built_in">export</span> JTOOLDIR=/tmp/kext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分离 PRELINK_INFO</span></span><br><span class="line">&gt; jtool -e __PRELINK_INFO kernelcache</span><br><span class="line">Requested segment found at offset 1e10000!</span><br><span class="line">Extracting __PRELINK_INFO at 31522816, 2342912 (23c000) bytes into kernelcache.__PRELINK_INFO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看产物</span></span><br><span class="line">&gt; ls .</span><br><span class="line">com.apple.driver.AppleMobileFileIntegrity.kext</span><br><span class="line">com.apple.driver.AppleMobileFileIntegrity.kext.ARM64.E815A4DD-90E7-3A38-A4BA-EFA2425BC543</span><br><span class="line">kernelcache</span><br><span class="line">kernelcache.__PRELINK_INFO</span><br></pre></td></tr></table></figure>

<p>打开 <code>kernelcache.__PRELINK_INFO</code> 可以看到这里包含了大量被 prelink 到 kernelcache 中的 kext 的信息，在其中还混入了大量被 base64 编码的 Data Blob。</p>
<h2 id="在-PRELINK-INFO-中查找关键信息"><a href="#在-PRELINK-INFO-中查找关键信息" class="headerlink" title="在 PRELINK_INFO 中查找关键信息"></a>在 PRELINK_INFO 中查找关键信息</h2><p>在 <code>kernelcache.__PRELINK_INFO</code> 中搜索 <code>&lt;key&gt;_PrelinkBundlePath&lt;/key&gt;&lt;string&gt;/System/Library/Extensions/AppleMobileFileIntegrity.kext&lt;/string&gt;</code> 可以定位到 amfi.kext 的 Info.plist，这里包含了 amfi.kext 的一些关键信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>BuildMachineOSBuild<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>18A391011<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkExecutableLoadAddr<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">integer</span> <span class="attr">ID</span>=<span class="string">"32"</span> <span class="attr">size</span>=<span class="string">"64"</span>&gt;</span>0xfffffff005ab1980<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundlePackageType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>KEXT<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkExecutableSourceAddr<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">integer</span> <span class="attr">IDREF</span>=<span class="string">"32"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleDevelopmentRegion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>English<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>MinimumOSVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>13.1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>1.0.5<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>DTXcodeBuild<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>11L374m<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>DTPlatformBuild<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span> <span class="attr">ID</span>=<span class="string">"33"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkBundlePath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>/System/Library/Extensions/AppleMobileFileIntegrity.kext<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkExecutableSize<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">integer</span> <span class="attr">size</span>=<span class="string">"64"</span>&gt;</span>0x5211<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkKmodInfo<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">integer</span> <span class="attr">size</span>=<span class="string">"64"</span>&gt;</span>0xfffffff0077e51c8<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>UIDeviceFamily<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">integer</span> <span class="attr">IDREF</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>OSBundleRequired<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>Root<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.driver.AppleMobileFileIntegrity<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>DTXcode<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>1100<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleExecutable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span> <span class="attr">IDREF</span>=<span class="string">"31"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中以 <code>_Prelink</code> 开头的字段非常重要：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkExecutableLoadAddr<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">integer</span> <span class="attr">ID</span>=<span class="string">"32"</span> <span class="attr">size</span>=<span class="string">"64"</span>&gt;</span>0xfffffff005ab1980<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkExecutableSourceAddr<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">integer</span> <span class="attr">ID</span>=<span class="string">"32"</span> <span class="attr">size</span>=<span class="string">"64"</span>&gt;</span>0xfffffff005ab1980<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkBundlePath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>/System/Library/Extensions/AppleMobileFileIntegrity.kext<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkExecutableSize<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">integer</span> <span class="attr">size</span>=<span class="string">"64"</span>&gt;</span>0x5211<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>_PrelinkKmodInfo<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">integer</span> <span class="attr">size</span>=<span class="string">"64"</span>&gt;</span>0xfffffff0077e51c8<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.driver.AppleMobileFileIntegrity<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这些字段的含义如下[1]：</p>
<ul>
<li>_PrelinkExecutableSourceAddr: kext 的起始地址，即 kext 的 Mach-O Header 地址；</li>
<li>_PrelinkExecutableLoadAddr: kext 在内存中的加载地址，对于 prelink kext 这个值一般等于 _PrelinkExecutableSourceAddr；</li>
<li>_PrelinkKmodInfo: kext 在 Mach layer 的对象模型。</li>
</ul>
<p>下面我们大致看一下这些地址的内容，首先是 _PrelinkExecutableSourceAddr，这里是 kext 的加载起点，可以看到这是一个标准的 Mach-O Header 结构：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e86472655284?w=1966&h=878&f=png&s=308513" alt=""></p>
<p>其次是 <code>_PrelinkKmodInfo</code>，它是一个 <code>kmod_info_t</code> 结构体:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmod_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmod_info</span>  * <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int32_t</span>             info_version;       <span class="comment">// version of this structure</span></span><br><span class="line">    <span class="keyword">uint32_t</span>            id;</span><br><span class="line">    <span class="keyword">char</span>                name[KMOD_MAX_NAME];</span><br><span class="line">    <span class="keyword">char</span>                version[KMOD_MAX_NAME];</span><br><span class="line">    <span class="keyword">int32_t</span>             reference_count;    <span class="comment">// # linkage refs to this</span></span><br><span class="line">    <span class="keyword">kmod_reference_t</span>  * reference_list;     <span class="comment">// who this refs (links on)</span></span><br><span class="line">    <span class="keyword">vm_address_t</span>        address;            <span class="comment">// starting address</span></span><br><span class="line">    <span class="keyword">vm_size_t</span>           <span class="built_in">size</span>;               <span class="comment">// total size</span></span><br><span class="line">    <span class="keyword">vm_size_t</span>           hdr_size;           <span class="comment">// unwired hdr size</span></span><br><span class="line">    <span class="keyword">kmod_start_func_t</span> * start;</span><br><span class="line">    <span class="keyword">kmod_stop_func_t</span>  * <span class="built_in">stop</span>;</span><br><span class="line">&#125; <span class="keyword">kmod_info_t</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e87b751b972d?w=1896&h=472&f=png&s=133266" alt=""></p>
<h2 id="猜测模块加载方式"><a href="#猜测模块加载方式" class="headerlink" title="猜测模块加载方式"></a>猜测模块加载方式</h2><p>以 user mode 的经验而言，这里的 Mach-O Header 中可能会包含类似于 <code>LC_MAIN</code> 的结构来标识 Entry Point，或是在 <code>kmod_info</code> 中的 start 和 stop 函数中会包含注册的关键逻辑。</p>
<p>遗憾的是，在 amfi.kext 的 Mach-O Header 中并没有 Entry Point，且 <code>kmod_info</code> 中的 start 和 stop 函数均为空实现，这就说明对于这类 prelink 的 kext 肯定有其他的加载方式有待探索。</p>
<h1 id="AppleMobileFileIntegrity-kext-的注册"><a href="#AppleMobileFileIntegrity-kext-的注册" class="headerlink" title="AppleMobileFileIntegrity.kext 的注册"></a>AppleMobileFileIntegrity.kext 的注册</h1><p>经过一番分析和资料查阅我发现有关 kext 的加载逻辑已经被逐步移动到 libkern 中。维护 kext 的关键逻辑位于 <code>libkern/c++/OSKext.cpp</code> 中，与此同时在 user mode 可以通过 I/O Kit 完成与 kext 的交互[1]。</p>
<p>基于 I/O Kit 的 kext 被作为 drivers 挂载在 IO 设备树中，可通过 Mach messages 实现对 kext 的操作，例如通过 OSKextLoadKextWithIdentifier 来加载一个 kext：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">OSKextLoadKextWithIdentifier(<span class="keyword">const</span> <span class="keyword">char</span> * bundle_id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> OSKext::loadKextWithIdentifier(bundle_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键逻辑是在一个全局注册表 sKextsByID 中找到对应的 OSKext 对象并执行 load 操作，那么问题的关键就转变为 kext 是如何被加入到 sKextsByID 中的。</p>
<p>前面我们提到了 prelink kexts 通过 <code>PRELINK_INFO</code> 来记录信息，在内核的 boot 阶段初始化 I/O Kit 时，<code>_start</code> -&gt; <code>_start_first_cpu</code> -&gt; <code>arm_init</code> -&gt; <code>machine_startup</code> -&gt; <code>kernel_bootstrap</code> -&gt; <code>kernel_bootstrap_thread</code> -&gt;  <code>PE_init_iokit</code> -&gt; <code>StartIOKit</code> -&gt; <code>bootstrapRecordStartupExtensions</code> -&gt; <code>KLDBootstrap::readStartupExtensions</code> -&gt; <code>readPrelinkedExtensions</code> -&gt; <code>OSKext::withPrelinkedInfoDict</code> -&gt; <code>OSKext::initWithPrelinkedInfoDict</code> 来根据 <code>PRELINK_INFO</code> 中的 Info 逐个加载 prelinked kext。</p>
<h2 id="从启动到注册"><a href="#从启动到注册" class="headerlink" title="从启动到注册"></a>从启动到注册</h2><p>下面我们就从 OSKext::initWithPrelinkedInfoDict 方法入手来研究 kext 的加载方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">OSKext::initWithPrelinkedInfoDict(</span><br><span class="line">	OSDictionary * anInfoDict,</span><br><span class="line">	<span class="keyword">bool</span> doCoalesedSlides) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    addressNum = OSDynamicCast(OSNumber, anInfoDict-&gt;getObject(<span class="string">"_PrelinkKmodInfo"</span>));</span><br><span class="line">    <span class="keyword">if</span> (addressNum-&gt;unsigned64BitValue() != <span class="number">0</span>) &#123;</span><br><span class="line">        kmod_info = (<span class="keyword">kmod_info_t</span> *) ml_static_slide((<span class="keyword">intptr_t</span>) (addressNum-&gt;unsigned64BitValue()));</span><br><span class="line">        kmod_info-&gt;address = ml_static_slide(kmod_info-&gt;address);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    flags.prelinked = <span class="literal">true</span>;</span><br><span class="line">    sPrelinkBoot = <span class="literal">true</span>;</span><br><span class="line">    result = registerIdentifier();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是对 kext 对应的 Info.plist 的处理，其中包括初始化 <code>kmod_info</code>, 设置 kext 的 binary 以及设置 kext flags 等，这里最关键的一步是通过 <code>registerIdentifier</code> 将自己添加到全局注册表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line">OSKext::registerIdentifier(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* If we don't have an existing kext with this identifier,</span></span><br><span class="line"><span class="comment">     * just record the new kext and we're done!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    existingKext = OSDynamicCast(OSKext, sKextsByID-&gt;getObject(bundleID));</span><br><span class="line">    <span class="keyword">if</span> (!existingKext) &#123;</span><br><span class="line">    	sKextsByID-&gt;setObject(bundleID, <span class="keyword">this</span>);</span><br><span class="line">    	result = <span class="literal">true</span>;</span><br><span class="line">    	<span class="keyword">goto</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的首次注册逻辑非常简单，就是将 kext 以 bundleID 为 key 加入到全局注册表 sKextsByID，这里省略了二次注册同一个 kext 的版本决议逻辑。</p>
<h1 id="AppleMobileFileIntegrity-kext-的加载"><a href="#AppleMobileFileIntegrity-kext-的加载" class="headerlink" title="AppleMobileFileIntegrity.kext 的加载"></a>AppleMobileFileIntegrity.kext 的加载</h1><p>说完了注册，下面来看一下 prelinked kext 的加载。笔者刚开始一直觉得 amfi.kext 是基于 libKern 的 kext_request 加载的，多处寻找代码和 bundleID 的交叉引用未果，费解之际发现 prelinked kext 加载也藏在启动流程之中，加载和注册的桥梁是全局注册表 sKextsByID。</p>
<h2 id="加载器的注入"><a href="#加载器的注入" class="headerlink" title="加载器的注入"></a>加载器的注入</h2><p>我们之前在注册流程中提到，有一个从 <code>StartIOKit</code> -&gt; <code>bootstrapRecordStartupExtensions</code> 的调用，在 StartIOKit 中对应的代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*record_startup_extensions_function)(<span class="keyword">void</span>) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">StartIOKit( <span class="keyword">void</span> * p1, <span class="keyword">void</span> * p2, <span class="keyword">void</span> * p3, <span class="keyword">void</span> * p4 ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* If the bootstrap segment set up a function to record startup</span></span><br><span class="line"><span class="comment">     * extensions, call it now.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (record_startup_extensions_function) &#123;</span><br><span class="line">    	record_startup_extensions_function();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>record_startup_extensions_function</code> 是在 KLDBootstrap 的构造函数中注入的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">* Set the function pointers for the entry points into the bootstrap</span></span><br><span class="line"><span class="comment">* segment upon C++ static constructor invocation.</span></span><br><span class="line"><span class="comment">*********************************************************************/</span></span><br><span class="line">KLDBootstrap::KLDBootstrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;sBootstrapObject) &#123;</span><br><span class="line">    	panic(<span class="string">"Attempt to access bootstrap segment."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    record_startup_extensions_function = &amp;bootstrapRecordStartupExtensions;</span><br><span class="line">    load_security_extensions_function = &amp;bootstrapLoadSecurityExtensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StartIOKit</code> 调用的 <code>record_startup_extensions_function</code> 实现即为注册流程中的 <code>bootstrapRecordStartupExtensions</code>，此外这里还为 <code>load_security_extensions_function</code> 注入了 <code>bootstrapLoadSecurityExtensions</code> 作为实现。这里的 <code>bootstrapLoadSecurityExtensions</code> 就是 kext 的加载逻辑，与注册逻辑 <code>bootstrapRecordStartupExtensions</code> 相对应。</p>
<h2 id="加载器的-Caller"><a href="#加载器的-Caller" class="headerlink" title="加载器的 Caller"></a>加载器的 Caller</h2><p>那么是谁负责调用 <code>bootstrapLoadSecurityExtensions</code> 来加载这些 kext 的呢？通过搜索代码我们可以找到位于 MAC 中的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Function pointer set up for loading security extensions.</span></span><br><span class="line"><span class="comment"> * It is set to an actual function after OSlibkernInit()</span></span><br><span class="line"><span class="comment"> * has been called, and is set back to 0 by OSKextRemoveKextBootstrap()</span></span><br><span class="line"><span class="comment"> * after bsd_init().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> (*load_security_extensions_function)(<span class="keyword">void</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Init after early Mach startup, but before BSD</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">mac_policy_initmach(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For the purposes of modules that want to know if they were</span></span><br><span class="line"><span class="comment">     * loaded "early", set the mac_late flag once we've processed</span></span><br><span class="line"><span class="comment">     * modules either linked into the kernel, or loaded before the</span></span><br><span class="line"><span class="comment">     * kernel startup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (load_security_extensions_function) &#123;</span><br><span class="line">    	load_security_extensions_function();</span><br><span class="line">    &#125;</span><br><span class="line">    mac_late = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 MAC 全称是 Mandatory Access Control，它是基于 Trusted BSD 实现的一个更细粒度的操作系统安全模型，用于提供对象级的安全控制。而 <code>mac_policy_initmach</code> 的 Caller 为 <code>kernel_bootstrap_thread</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now running in a thread.  Kick off other services,</span></span><br><span class="line"><span class="comment"> * invoke user bootstrap, enter pageout loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">kernel_bootstrap_thread(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  IOKIT</span></span><br><span class="line">    kernel_bootstrap_log(<span class="string">"PE_init_iokit"</span>);</span><br><span class="line">    PE_init_iokit();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MACF</span></span><br><span class="line">    kernel_bootstrap_log(<span class="string">"mac_policy_initmach"</span>);</span><br><span class="line">    mac_policy_initmach();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的注册 <code>PE_init_iokit</code> 和加载 <code>mac_policy_initmach</code> 是先后调用的，从而保证 <code>mac_policy_initmach</code> 时能取到已经注册的 Security Kexts。</p>
<h2 id="加载逻辑"><a href="#加载逻辑" class="headerlink" title="加载逻辑"></a>加载逻辑</h2><p>前面提到加载逻辑位于 <code>bootstrapLoadSecurityExtensions</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bootstrapLoadSecurityExtensions(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sBootstrapObject.loadSecurityExtensions();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">KLDBootstrap::loadSecurityExtensions(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// OSKext::copyKexts()</span></span><br><span class="line">    extensionsDict = OSDynamicCast(OSDictionary, sKextsByID-&gt;copyCollection());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    keyIterator = OSCollectionIterator::withCollection(extensionsDict);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> ((bundleID = OSDynamicCast(OSString, keyIterator-&gt;getNextObject()))) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * bundle_id = bundleID-&gt;getCStringNoCopy();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Skip extensions whose bundle IDs don't start with "com.apple.".</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!bundle_id ||</span><br><span class="line">            (<span class="built_in">strncmp</span>(bundle_id, <span class="string">"com.apple."</span>, CONST_STRLEN(<span class="string">"com.apple."</span>)) != <span class="number">0</span>)) &#123;</span><br><span class="line">        	<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        theKext = OSDynamicCast(OSKext, extensionsDict-&gt;getObject(bundleID));</span><br><span class="line">        <span class="keyword">if</span> (!theKext) &#123;</span><br><span class="line">    	    <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (kOSBooleanTrue == theKext-&gt;getPropertyForHostArch(kAppleSecurityExtensionKey)) &#123;</span><br><span class="line">    	    OSKext::loadKextWithIdentifier(bundleID-&gt;getCStringNoCopy(),</span><br><span class="line">        	    <span class="comment">/* allowDefer */</span> <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过遍历 sKextsByID 执行 loadKextWithIdentifier 方法，后续会执行 <code>OSKext::load</code> -&gt; <code>OSKext::loadExecutable</code> (register <code>kmod_info</code>) and <code>OSKext::start</code> -&gt; <code>OSRuntimeInitializeCPP</code>。</p>
<p>其中 <code>OSKext::load</code> 中包含了注册到 IOKit，<code>OSRuntimeInitializeCPP</code> 完成了 libkern 的一些 C++ 环境初始化。</p>
<h1 id="AppleMobileFileIntegrity-kext-注册到-IOKit"><a href="#AppleMobileFileIntegrity-kext-注册到-IOKit" class="headerlink" title="AppleMobileFileIntegrity.kext 注册到 IOKit"></a>AppleMobileFileIntegrity.kext 注册到 IOKit</h1><h2 id="注册与启动服务"><a href="#注册与启动服务" class="headerlink" title="注册与启动服务"></a>注册与启动服务</h2><p>我们先来看 load 阶段，在 <code>OSKext::load</code> 的函数最后包含了这样一段逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If not excluding matching, send the personalities to the kernel.</span></span><br><span class="line"><span class="comment"> * This never affects the result of the load operation.</span></span><br><span class="line"><span class="comment"> * This is a bit of a hack, because we shouldn't be handling</span></span><br><span class="line"><span class="comment"> * personalities within the load function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OSReturn</span><br><span class="line">OSKext::load(</span><br><span class="line">	OSKextExcludeLevel   startOpt,</span><br><span class="line">	OSKextExcludeLevel   startMatchingOpt,</span><br><span class="line">	OSArray            * personalityNames) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (result == kOSReturnSuccess &amp;&amp; startMatchingOpt == kOSKextExcludeNone) &#123;</span><br><span class="line">        result = sendPersonalitiesToCatalog(<span class="literal">true</span>, personalityNames);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓 Personalities 即 IOKitPersonalities，用于描述驱动的特征以便 IOKit 能正确的加载和匹配服务。</p>
<p><code>OSKext::sendPersonalitiesToCatalog</code> 随后会调用到 <code>gIOCatalogue-&gt;addDrivers(personalitiesToSend, startMatching)</code>，这里的 gIOCatalogue 是一个全局的 IOCatalogue 对象，它是一个所有 IOKIt 驱动 personalities 的数据库，IOKit 通过它来匹配相关服务[2]。</p>
<p><code>gIOCatalogue-&gt;addDrivers</code> 随后会调用到 <code>IOService::catalogNewDrivers</code> -&gt; <code>IOService::startMatching</code> -&gt; <code>IOService::doServiceMatch</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">IOService::doServiceMatch( IOOptionBits options )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (keepGuessing) &#123;</span><br><span class="line">    	matches = gIOCatalogue-&gt;findDrivers( <span class="keyword">this</span>, &amp;catalogGeneration );</span><br><span class="line">        <span class="comment">// the matches list should always be created by findDrivers()</span></span><br><span class="line">        <span class="keyword">if</span> (matches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == (__state[<span class="number">0</span>] &amp; kIOServiceFirstPublishState)) &#123;</span><br><span class="line">                getMetaClass()-&gt;addInstance(<span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (keepGuessing &amp;&amp; matches-&gt;getCount() &amp;&amp; (kIOReturnSuccess == getResources())) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">this</span> == gIOResources) || (<span class="keyword">this</span> == gIOUserResources)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resourceKeys) &#123;</span><br><span class="line">                        resourceKeys-&gt;<span class="built_in">release</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    resourceKeys = copyPropertyKeys();</span><br><span class="line">                &#125;</span><br><span class="line">                probeCandidates( matches );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>getMetaClass()-&gt;addInstance(this)</code> 和 <code>probeCandidates( matches )</code> 是两个关键调用，我们先来看前者：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Class global data */</span></span><br><span class="line">OSObject::MetaClass OSObject::gMetaClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OSMetaClass *</span><br><span class="line">OSObject::getMetaClass() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;gMetaClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 gMetaClass 是一个 Class 维度的全局对象，addInstance 将 kext 的 IOService 实例添加到这个 Class 维度的列表上来关联类对象关联的所有 IOService 实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">OSMetaClass::addInstance(<span class="keyword">const</span> OSObject * instance, <span class="keyword">bool</span> super) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!super) &#123;</span><br><span class="line">        IOLockLock(sInstancesLock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!reserved-&gt;instances) &#123;</span><br><span class="line">        reserved-&gt;instances = OSOrderedSet::withCapacity(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (superClassLink) &#123;</span><br><span class="line">            superClassLink-&gt;addInstance(reserved-&gt;instances, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reserved-&gt;instances-&gt;setLastObject(instance);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!super) &#123;</span><br><span class="line">        IOLockUnlock(sInstancesLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 gMetaClass-&gt;reserved-&gt;instances 将用于 Service Matching 时获取到 amfi 对应的 IOService 实例。</p>
<p>接下来看一下 <code>probeCandidates( matches )</code> 这个调用，它会调用到 <code>IOService::startCandidate</code> -&gt; <code>IOService::start</code>，从而完成 amfi 的 IOService 启动。</p>
<h2 id="AMFI-的启动流程"><a href="#AMFI-的启动流程" class="headerlink" title="AMFI 的启动流程"></a>AMFI 的启动流程</h2><p>在 amfi.kext 中我们可以找到 <code>IOService::start</code> 启动方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> __cdecl <span class="title">AMFI::start_IOService</span><span class="params">(<span class="keyword">uint64_t</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> *v1; <span class="comment">// x19</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( !(*((<span class="keyword">unsigned</span> <span class="keyword">int</span> (**)(<span class="keyword">void</span>))IORegistryEntry::gMetaClass + <span class="number">88</span>))() )</span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))loc_FFFFFFF006075D18)();</span><br><span class="line">  initializeAppleMobileFileIntegrity();</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)cs_debug )</span><br><span class="line">    IOLog(<span class="string">"%s: built %s %s\n"</span>, <span class="string">"virtual bool AppleMobileFileIntegrity::start(IOService *)"</span>, <span class="string">"Sep  3 2019"</span>, <span class="string">"22:15:18"</span>);</span><br><span class="line">  (*(<span class="keyword">void</span> (__fastcall **)(<span class="keyword">uint64_t</span> *, _QWORD))(*v1 + <span class="number">672</span>))(v1, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的核心初始化方法是 <code>initializeAppleMobileFileIntegrity</code>，其中包含了与 codesign 相关的 MAC Policy Module 与 Handler 的注册，这些 Handler 以切面的形式对特定系统调用进行校验，例如 <code>mpo_vnode_check_signature</code> 使用 in-kernel signature cache 和 amfid 进行文件的代码签名校验。有关 <code>initializeAppleMobileFileIntegrity</code> 的具体逻辑以及与 amfid 的交互方式我们将在下一篇文章中详细介绍。</p>
<h2 id="初始化-libkern-C-环境"><a href="#初始化-libkern-C-环境" class="headerlink" title="初始化 libkern C++ 环境"></a>初始化 libkern C++ 环境</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">OSRuntimeInitializeCPP(</span><br><span class="line">	OSKext                   * theKext)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Tell the meta class system that we are starting the load</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    metaHandle = OSMetaClass::preModLoad(kmodInfo-&gt;name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Scan the header for all constructor sections, in any</span></span><br><span class="line"><span class="comment">	 * segment, and invoke the constructors within those sections.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">for</span> (segment = firstsegfromheader(header);</span><br><span class="line">        segment != <span class="literal">NULL</span> &amp;&amp; load_success;</span><br><span class="line">        segment = nextsegfromheader(header, segment)) &#123;</span><br><span class="line">    	<span class="comment">/* Record the current segment in the event of a failure.</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">    	failure_segment = segment;</span><br><span class="line">    	load_success = OSRuntimeCallStructorsInSection(</span><br><span class="line">    		theKext, kmodInfo, metaHandle, segment,</span><br><span class="line">    		sectionNames[kOSSectionNameInitializer],</span><br><span class="line">    		textStart, textEnd);</span><br><span class="line">    &#125; <span class="comment">/* for (segment...) */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Now, regardless of success so far, do the post-init registration</span></span><br><span class="line"><span class="comment">     * and cleanup. If we had to call the unloadCPP function, static</span></span><br><span class="line"><span class="comment">     * destructors have removed classes from the stalled list so no</span></span><br><span class="line"><span class="comment">     * metaclasses will actually be registered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    result = OSMetaClass::postModLoad(metaHandle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pre-阶段"><a href="#Pre-阶段" class="headerlink" title="Pre 阶段"></a>Pre 阶段</h3><p>这里的加载主要包含 3 个阶段，其中 pre 阶段主要是为了准备 kext 的 Main Class 的加载上下文，这里的上下文通过一个全局变量保存，并通过一个锁保证串行队列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * While loading a kext and running all its constructors to register</span></span><br><span class="line"><span class="comment"> * all OSMetaClass classes, the classes are queued up here. Only one</span></span><br><span class="line"><span class="comment"> * kext can be in flight at a time, guarded by sStalledClassesLock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">StalledData</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>   * kextIdentifier;</span><br><span class="line">    OSReturn       result;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   capacity;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   count;</span><br><span class="line">    OSMetaClass ** classes;</span><br><span class="line">&#125; * sStalled;</span><br><span class="line">IOLock * sStalledClassesLock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">OSMetaClass::preModLoad(<span class="keyword">const</span> <span class="keyword">char</span> * kextIdentifier)</span><br><span class="line">&#123;</span><br><span class="line">    IOLockLock(sStalledClassesLock);</span><br><span class="line">    </span><br><span class="line">    assert(sStalled == <span class="literal">NULL</span>);</span><br><span class="line">    sStalled = (StalledData *)kalloc_tag(<span class="keyword">sizeof</span>(*sStalled), VM_KERN_MEMORY_OSKEXT);</span><br><span class="line">    <span class="keyword">if</span> (sStalled) &#123;</span><br><span class="line">    	sStalled-&gt;classes = (OSMetaClass **)kalloc_tag(kKModCapacityIncrement * <span class="keyword">sizeof</span>(OSMetaClass *), VM_KERN_MEMORY_OSKEXT);</span><br><span class="line">    	<span class="keyword">if</span> (!sStalled-&gt;classes) &#123;</span><br><span class="line">            kfree(sStalled, <span class="keyword">sizeof</span>(*sStalled));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	OSMETA_ACCUMSIZE((kKModCapacityIncrement * <span class="keyword">sizeof</span>(OSMetaClass *)) +</span><br><span class="line">    	    <span class="keyword">sizeof</span>(*sStalled));</span><br><span class="line">    </span><br><span class="line">    	sStalled-&gt;result   = kOSReturnSuccess;</span><br><span class="line">    	sStalled-&gt;capacity = kKModCapacityIncrement;</span><br><span class="line">    	sStalled-&gt;count    = <span class="number">0</span>;</span><br><span class="line">    	sStalled-&gt;kextIdentifier = kextIdentifier;</span><br><span class="line">    	bzero(sStalled-&gt;classes, kKModCapacityIncrement * <span class="keyword">sizeof</span>(OSMetaClass *));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// keep sStalledClassesLock locked until postModLoad</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sStalled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="In-阶段"><a href="#In-阶段" class="headerlink" title="In 阶段"></a>In 阶段</h3><p>随后的代码通过 <code>OSRuntimeCallStructorsInSection</code> 扫描了 kext 中所有的 <code>__mod_init_func</code> sections 并调用这些初始化函数，这里我们可以打开 IDA 查看 <code>__mod_init_func</code> 包含了哪些初始化函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__mod_init_func:FFFFFFF006DF41A0 ; Segment type: Pure data</span><br><span class="line">__mod_init_func:FFFFFFF006DF41A0   AREA __mod_init_func, DATA, ALIGN&#x3D;3</span><br><span class="line">__mod_init_func:FFFFFFF006DF41A0 ; ORG 0xFFFFFFF006DF41A0</span><br><span class="line">__mod_init_func:FFFFFFF006DF41A0   DCQ InitFunc_0</span><br><span class="line">__mod_init_func:FFFFFFF006DF41A8   DCQ InitFunc_1</span><br><span class="line">__mod_init_func:FFFFFFF006DF41B0   DCQ InitFunc_2</span><br><span class="line">__mod_init_func:FFFFFFF006DF41B0 ; __mod_init_func ends</span><br></pre></td></tr></table></figure>

<p>可见在 amfi.kext 中共包含了 3 个初始化函数，其中 <code>InitFunc_1</code> 是一些全局变量的初始化函数，<code>InitFunc_0</code> 和 <code>InitFunc_2</code> 是 AMFI 的一些 Main Class 的初始化函数，我们这里重点看一下 <code>InitFunc_2</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_QWORD *InitFunc_2()</span><br><span class="line">&#123;</span><br><span class="line">    _QWORD *result; &#x2F;&#x2F; x0</span><br><span class="line">    result &#x3D; (_QWORD *)OSMetaClass::OSMetaClass(&amp;some_this, &quot;AppleMobileFileIntegrity&quot;, some_inSuperClass, 136LL);</span><br><span class="line">    *result &#x3D; some_vtable;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>OSMetaClass::OSMetaClass</code> 是类的核心构造方法，它实际上是将类加到 OSMetaClass 全局上下文 <code>sStalled-&gt;classes</code> 中以便 post 流程中使用，这里省略了当 classes 列表的 Grow 逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************************************************************</span></span><br><span class="line"><span class="comment">* The core constructor for a MetaClass (defined with this name always</span></span><br><span class="line"><span class="comment">* but within the scope of its represented class).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* MetaClass constructors are invoked in OSRuntimeInitializeCPP(),</span></span><br><span class="line"><span class="comment">* in between calls to OSMetaClass::preModLoad(), which sets up for</span></span><br><span class="line"><span class="comment">* registration, and OSMetaClass::postModLoad(), which actually</span></span><br><span class="line"><span class="comment">* records all the class/kext relationships of the new MetaClasses.</span></span><br><span class="line"><span class="comment">*********************************************************************/</span></span><br><span class="line"></span><br><span class="line">OSMetaClass::OSMetaClass(</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>        * inClassName,</span><br><span class="line">	<span class="keyword">const</span> OSMetaClass * inSuperClass,</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>        inClassSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sStalled-&gt;classes[sStalled-&gt;count++] = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Post-阶段"><a href="#Post-阶段" class="headerlink" title="Post 阶段"></a>Post 阶段</h3><p>post 阶段主要是维护 kext 与 classes 的关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">OSReturn</span><br><span class="line">OSMetaClass::postModLoad(<span class="keyword">void</span> * loadHandle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// static OSDictionary * sAllClassesDict;</span></span><br><span class="line">    sAllClassesDict = OSDictionary::withCapacity(kClassCapacityIncrement);</span><br><span class="line">    sAllClassesDict-&gt;setOptions(OSCollection::kSort, OSCollection::kSort);</span><br><span class="line">    myKextName = <span class="keyword">const_cast</span>&lt;OSSymbol *&gt;(OSSymbol::withCStringNoCopy(</span><br><span class="line">				    sStalled-&gt;kextIdentifier));</span><br><span class="line">    myKext = OSKext::lookupKextWithIdentifier(myKextName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* First pass checking classes aren't already loaded. If any already</span></span><br><span class="line"><span class="comment">     * exist, we don't register any, and so we don't technically have</span></span><br><span class="line"><span class="comment">     * to do any C++ teardown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Hack alert: me-&gt;className has been a C string until now.</span></span><br><span class="line"><span class="comment">     * We only release the OSSymbol if we store the kext.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IOLockLock(sAllClassesLock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sStalled-&gt;count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> OSMetaClass * me = sStalled-&gt;classes[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((me = me-&gt;superClassLink)) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// static unsigned int sDeepestClass;</span></span><br><span class="line">        <span class="keyword">if</span> (depth &gt; sDeepestClass) &#123;</span><br><span class="line">            sDeepestClass = depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    IOLockUnlock(sAllClassesLock);</span><br><span class="line">    </span><br><span class="line">    IOLockLock(sAllClassesLock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sStalled-&gt;count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> OSMetaClass * me = sStalled-&gt;classes[i];</span><br><span class="line">        OSMetaClass * me = sStalled-&gt;classes[i];</span><br><span class="line">        me-&gt;className = OSSymbol::withCStringNoCopy((<span class="keyword">const</span> <span class="keyword">char</span> *)me-&gt;className);</span><br><span class="line">        sAllClassesDict-&gt;setObject(me-&gt;className, me);</span><br><span class="line">        me-&gt;reserved-&gt;kext = myKext;</span><br><span class="line">        myKext-&gt;addClass(me, sStalled-&gt;count);</span><br><span class="line">    &#125;</span><br><span class="line">    IOLockLock(sAllClassesLock);</span><br><span class="line">    </span><br><span class="line">    sBootstrapState = kCompletedBootstrap;</span><br><span class="line">    sStalled = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> kOSReturnSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成 post 流程后，kext 的所有 OSMetaClass 实例就被以 name2instance 的形式记录在全局注册表 sAllClassesDict 之中了，同时每个 OSMetaClass 实例 还维护了 instance2kext 的对应关系 (me-&gt;reserved-&gt;kext = myKext)，每个 kext 又维护了里属于他的所有 instance (myKext-&gt;addClass(me, sStalled-&gt;count))。这就保证了可以通过 class name 找到实例，又可以通过实例找到对应的 OSKext 对象，而通过 OSKext 对象也可以获得隶属于它的所有 OSMetaClass 实例。</p>
<h1 id="获取-AppleMobileFileIntegrity-kext-服务"><a href="#获取-AppleMobileFileIntegrity-kext-服务" class="headerlink" title="获取 AppleMobileFileIntegrity.kext 服务"></a>获取 AppleMobileFileIntegrity.kext 服务</h1><p>我们在 kernelcache 中搜索 “AppleMobileFileIntegrity” 字符串的交叉引用不难找到通过 IOService 访问 AMFI 服务的代码，例如 <code>com.apple.security.sandbox</code> 中的 <code>initAMFI</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">initAMFI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  OSDictionary *matchDict_1; <span class="comment">// x0</span></span><br><span class="line">  OSDictionary *v1; <span class="comment">// x19</span></span><br><span class="line">  IOService *v2; <span class="comment">// x0</span></span><br><span class="line">  __int64 v4; <span class="comment">// x0</span></span><br><span class="line">  __int64 matchDict; <span class="comment">// [xsp+8h] [xbp-18h]</span></span><br><span class="line"></span><br><span class="line">  matchDict = <span class="number">0L</span>L;</span><br><span class="line">  matchDict_1 = (OSDictionary *)IOService::nameMatching(<span class="string">"AppleMobileFileIntegrity"</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v1 = matchDict_1;</span><br><span class="line">  v2 = IOService::waitForMatchingService(matchDict_1, <span class="number">0xFFFFFFFFFFFFFFFF</span>LL);</span><br><span class="line">  matchDict = OSMetaClassBase::safeMetaCast(v2, *(_QWORD *)qword_FFFFFFF006F9D038);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先使用 IOService::nameMatching 构造了一个 OSDictionary:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"IONameMatch"</span>: <span class="string">"AppleMobileFileIntegrity"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后通过 <code>IOService::waitForMatchingService</code> 匹配服务，核心逻辑梳理如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">IOService *</span><br><span class="line">IOService::waitForMatchingService( OSDictionary * matching,</span><br><span class="line">    <span class="keyword">uint64_t</span> timeout) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    	result = (IOService *) copyExistingServices( matching,</span><br><span class="line">    	    kIOServiceMatchedState, kIONotifyOnce );</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OSObject *</span><br><span class="line">IOService::copyExistingServices( OSDictionary * matching,</span><br><span class="line">    IOOptionBits inState, IOOptionBits options ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    IOServiceMatchContext ctx;</span><br><span class="line">    ctx.table   = matching;</span><br><span class="line">    ctx.state   = inState;</span><br><span class="line">    ctx.count   = <span class="number">0</span>;</span><br><span class="line">    ctx.done    = <span class="number">0</span>;</span><br><span class="line">    ctx.options = options;</span><br><span class="line">    ctx.result  = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    IOService::gMetaClass.applyToInstances(instanceMatch, &amp;ctx);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">OSMetaClass::applyToInstances(OSMetaClassInstanceApplierFunction applier,</span><br><span class="line">    <span class="keyword">void</span> * context) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    IOLockLock(sInstancesLock);</span><br><span class="line">    <span class="keyword">if</span> (reserved-&gt;instances) &#123;</span><br><span class="line">        applyToInstances(reserved-&gt;instances, applier, context);</span><br><span class="line">    &#125;</span><br><span class="line">    IOLockUnlock(sInstancesLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后是通过遍历 IOService::gMetaClass.reserved-&gt;instances 中的所有 IOService 实例实现匹配的，而 IOService::gMetaClass.reserved-&gt;instances 正好是我们在 <code>OSKext::load</code> -&gt; <code>OSKext::sendPersonalitiesToCatalog</code> 阶段所注册的。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，整个 Prelinked Kext 的注册、加载、启动和获取流程就讲完了。为了更好地研究代码签名机制，笔者首先分析了 amfid 的工作机制，随后分析了 AMFI.kext 与 amfid 的交互逻辑，再到 AMFI.kext 的加载。分析整个加载机制耗费了非常多的时间，这篇文章算是一个复盘。在接下来的文章中将重点分析 AMFI 注册的 MAC Policy Module 及其工作机制，这里面将涉及到更加复杂的逻辑。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.amazon.com/Mac-OS-iOS-Internals-Apples/dp/1118057651" target="_blank" rel="noopener">Jonathan Levin: Mac OS X and iOS Internals: To the Apple’s Core</a></li>
<li><a href="https://opensource.apple.com/source/xnu/xnu-6153.11.26/" target="_blank" rel="noopener">Apple: Darwin-XNU-6153.11.26</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高级页面仔 (Soulghost)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.asm.im/2020/07/05/iOS-Jailbreak-Principles-0x03-amfi-kext-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/">http://blog.asm.im/2020/07/05/iOS-Jailbreak-Principles-0x03-amfi-kext-%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/06/14/iOS-Jailbreak-Principles-0x02-codesign-and-amfid-bypass/"><span>iOS Jailbreak Principles 0x02 - codesign and amfid bypass</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 高级页面仔 (Soulghost)</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><i class="fa fa-user"> 0xfffffff007004000</i><span class="footer-separator">|</span><i class="fa fa-eye"> 0x2004000</i></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>