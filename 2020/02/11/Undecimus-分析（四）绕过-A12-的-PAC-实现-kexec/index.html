<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Undecimus 分析（四）绕过 A12 的 PAC 实现 kexec"><meta name="keywords" content="JailBreak,Undecimus,KEXEC,PAC"><meta name="author" content="高级页面仔 (Soulghost)"><meta name="copyright" content="高级页面仔 (Soulghost)"><title>Undecimus 分析（四）绕过 A12 的 PAC 实现 kexec | iOS Security Cabin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PAC-的一些特点"><span class="toc-number">2.</span> <span class="toc-text">PAC 的一些特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#返回地址保护"><span class="toc-number">2.1.</span> <span class="toc-text">返回地址保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针保护"><span class="toc-number">2.2.</span> <span class="toc-text">指针保护</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PAC-对-JOP-的影响"><span class="toc-number">3.</span> <span class="toc-text">PAC 对 JOP 的影响</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#绕过-PAC-的理论分析"><span class="toc-number">4.</span> <span class="toc-text">绕过 PAC 的理论分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#限制条件"><span class="toc-number">4.1.</span> <span class="toc-text">限制条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有利条件"><span class="toc-number">4.2.</span> <span class="toc-text">有利条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PACIZA-Signing-Gadget"><span class="toc-number">4.3.</span> <span class="toc-text">PACIZA Signing Gadget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#寻找-Gadget"><span class="toc-number">4.3.1.</span> <span class="toc-text">寻找 Gadget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#触发-Gadget"><span class="toc-number">4.3.2.</span> <span class="toc-text">触发 Gadget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#清理环境"><span class="toc-number">4.4.</span> <span class="toc-text">清理环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PACIA-amp-PACDA-Signing-Gadget"><span class="toc-number">4.5.</span> <span class="toc-text">PACIA &amp; PACDA Signing Gadget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完美的-kexec"><span class="toc-number">4.6.</span> <span class="toc-text">完美的 kexec</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#修改-getTargetAndTrapForIndex-为默认实现"><span class="toc-number">4.6.1.</span> <span class="toc-text">修改 getTargetAndTrapForIndex 为默认实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#绕过-PAC-的代码导读"><span class="toc-number">5.</span> <span class="toc-text">绕过 PAC 的代码导读</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/6300263?s=460&amp;u=c55866a279854c9150528b358802a75be5e6a507&amp;v=4"></div><div class="author-info__name text-center">高级页面仔 (Soulghost)</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/Soulghost" target="_blank" rel="noopener">Follow Me on GitHub</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iOS Security Cabin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Undecimus 分析（四）绕过 A12 的 PAC 实现 kexec</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-11</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://juejin.im/post/5e1ac76d51882520c02c82c0" target="_blank" rel="noopener">上一篇文章</a> 中我们介绍了非 arm64e 下通过 IOTrap 实现 kexec 的过程。阻碍 arm64e 实现这一过程的主要因素是 PAC (Pointer Authentication Code) 缓解措施，在这一篇文章中我们将介绍 Undecimus 中绕过 PAC 机制的过程。</p>
<p>整个绕过过程十分复杂，本文的主要参考资料为 <a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html" target="_blank" rel="noopener">Examining Pointer Authentication on the iPhone XS</a> 和 Undecimus 中与 arm64e 相关的 PAC Bypass 代码。</p>
<h1 id="PAC-的一些特点"><a href="#PAC-的一些特点" class="headerlink" title="PAC 的一些特点"></a>PAC 的一些特点</h1><p>什么是 PAC 这里不再赘述，简言之就是一种对返回地址、全局指针等的一种签名与验签保护机制，详细定义和机制读者可以自行查阅资料，这里仅给出一个简单的例子来帮助理解 PAC 实现。</p>
<p>下面这段代码中包含了一个全局数值变量、一个基于函数指针 fptr 的动态函数调用，猜一下哪些值会被 PAC 保护呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pac.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_somedata = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tram_one</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"call tramp one %d\n"</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step_ptr</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(ptr) = (<span class="keyword">void</span> *)&amp;tram_one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    g_somedata += argc;</span><br><span class="line">    <span class="keyword">void</span> *fptr = <span class="literal">NULL</span>;</span><br><span class="line">    step_ptr(fptr);</span><br><span class="line">    (<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> (*)(<span class="keyword">int</span>)&gt;(fptr))(g_somedata);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们用 clang 将 cpp 编译链接并生成 arm64e 下的汇编代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -arch arm64e -isysroot `xcrun --sdk iphoneos --show-sdk-path` -fno-asynchronous-unwind-tables pac.cpp -o pace.s</span><br></pre></td></tr></table></figure>

<p>生成的完整汇编结果为：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">.section</span>	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.<span class="keyword">build_version </span>ios, <span class="number">13</span>, <span class="number">0</span>	sdk_version <span class="number">13</span>, <span class="number">0</span></span><br><span class="line">	.globl	__Z8tram_onei           <span class="comment">; -- Begin function _Z8tram_onei</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">__Z8tram_onei</span>:                          <span class="comment">; @_Z8tram_onei</span></span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="comment">; %bb.0:</span></span><br><span class="line">	pacibsp</span><br><span class="line">	<span class="keyword">sub	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#32</span>             <span class="comment">; =32</span></span><br><span class="line">	stp	x29, x30, [<span class="built_in">sp</span>, <span class="number">#16</span>]     <span class="comment">; 16-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">add	</span>x29, <span class="built_in">sp</span>, <span class="number">#16</span>            <span class="comment">; =16</span></span><br><span class="line">	.cfi_def_cfa w29, <span class="number">16</span></span><br><span class="line">	.cfi_offset w30, -<span class="number">8</span></span><br><span class="line">	.cfi_offset w29, -<span class="number">16</span></span><br><span class="line">	stur	w0, [x29, #-<span class="number">4</span>]</span><br><span class="line">	ldur	w0, [x29, #-<span class="number">4</span>]</span><br><span class="line">                                        <span class="comment">; implicit-def: $x1</span></span><br><span class="line">	<span class="keyword">mov	</span>x1, x0</span><br><span class="line">	<span class="keyword">mov	</span>x8, <span class="built_in">sp</span></span><br><span class="line">	<span class="keyword">str	</span>x1, [x8]</span><br><span class="line">	<span class="keyword">adrp	</span>x0, l_.<span class="keyword">str@PAGE</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">add	</span>x0, x0, l_.<span class="keyword">str@PAGEOFF</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">bl	</span>_printf</span><br><span class="line">	<span class="keyword">mov	</span>w9, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">str	</span>w0, [<span class="built_in">sp</span>, <span class="number">#8</span>]            <span class="comment">; 4-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">mov	</span>x0, x9</span><br><span class="line">	ldp	x29, x30, [<span class="built_in">sp</span>, <span class="number">#16</span>]     <span class="comment">; 16-byte Folded Reload</span></span><br><span class="line">	<span class="keyword">add	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#32</span>             <span class="comment">; =32</span></span><br><span class="line">	retab</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        <span class="comment">; -- End function</span></span><br><span class="line">	.globl	__Z8step_ptrPv          <span class="comment">; -- Begin function _Z8step_ptrPv</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">__Z8step_ptrPv</span>:                         <span class="comment">; @_Z8step_ptrPv</span></span><br><span class="line"><span class="comment">; %bb.0:</span></span><br><span class="line">	<span class="keyword">sub	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             <span class="comment">; =16</span></span><br><span class="line">	<span class="keyword">adrp	</span>x8, l__Z8tram_onei$auth_ptr$ia<span class="number">$0</span><span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">ldr	</span>x8, [x8, l__Z8tram_onei$auth_ptr$ia<span class="number">$0</span><span class="comment">@PAGEOFF]</span></span><br><span class="line">	<span class="keyword">str	</span>x0, [<span class="built_in">sp</span>, <span class="number">#8</span>]</span><br><span class="line">	<span class="keyword">ldr	</span>x0, [<span class="built_in">sp</span>, <span class="number">#8</span>]</span><br><span class="line">	<span class="keyword">str	</span>x8, [x0]</span><br><span class="line">	<span class="keyword">add	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             <span class="comment">; =16</span></span><br><span class="line">	ret</span><br><span class="line">                                        <span class="comment">; -- End function</span></span><br><span class="line">	.globl	_main                   <span class="comment">; -- Begin function main</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">_main</span>:                                  <span class="comment">; @main</span></span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="comment">; %bb.0:</span></span><br><span class="line">	pacibsp</span><br><span class="line">	<span class="keyword">sub	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#64</span>             <span class="comment">; =64</span></span><br><span class="line">	stp	x29, x30, [<span class="built_in">sp</span>, <span class="number">#48</span>]     <span class="comment">; 16-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">add	</span>x29, <span class="built_in">sp</span>, <span class="number">#48</span>            <span class="comment">; =48</span></span><br><span class="line">	.cfi_def_cfa w29, <span class="number">16</span></span><br><span class="line">	.cfi_offset w30, -<span class="number">8</span></span><br><span class="line">	.cfi_offset w29, -<span class="number">16</span></span><br><span class="line">	<span class="keyword">adrp	</span>x8, _g_somedata<span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">add	</span>x8, x8, _g_somedata<span class="comment">@PAGEOFF</span></span><br><span class="line">	stur	wzr, [x29, #-<span class="number">4</span>]</span><br><span class="line">	stur	w0, [x29, #-<span class="number">8</span>]</span><br><span class="line">	stur	x1, [x29, #-<span class="number">16</span>]</span><br><span class="line">	ldur	w0, [x29, #-<span class="number">8</span>]</span><br><span class="line">	<span class="keyword">ldr	</span>w9, [x8]</span><br><span class="line">	<span class="keyword">add	</span>w9, w9, w0</span><br><span class="line">	<span class="keyword">str	</span>w9, [x8]</span><br><span class="line">	<span class="keyword">mov	</span>x8, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">str	</span>x8, [<span class="built_in">sp</span>, <span class="number">#24</span>]</span><br><span class="line">	<span class="keyword">ldr	</span>x0, [<span class="built_in">sp</span>, <span class="number">#24</span>]</span><br><span class="line">	<span class="keyword">bl	</span>__Z8step_ptrPv</span><br><span class="line">	<span class="keyword">adrp	</span>x8, _g_somedata<span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">add	</span>x8, x8, _g_somedata<span class="comment">@PAGEOFF</span></span><br><span class="line">	<span class="keyword">ldr	</span>x0, [<span class="built_in">sp</span>, <span class="number">#24</span>]</span><br><span class="line">	<span class="keyword">ldr	</span>w9, [x8]</span><br><span class="line">	<span class="keyword">str	</span>x0, [<span class="built_in">sp</span>, <span class="number">#16</span>]           <span class="comment">; 8-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">mov	</span>x0, x9</span><br><span class="line">	<span class="keyword">ldr	</span>x8, [<span class="built_in">sp</span>, <span class="number">#16</span>]           <span class="comment">; 8-byte Folded Reload</span></span><br><span class="line">	<span class="keyword">blraaz	</span>x8</span><br><span class="line">	<span class="keyword">mov	</span>w9, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">str	</span>w0, [<span class="built_in">sp</span>, <span class="number">#12</span>]           <span class="comment">; 4-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">mov	</span>x0, x9</span><br><span class="line">	ldp	x29, x30, [<span class="built_in">sp</span>, <span class="number">#48</span>]     <span class="comment">; 16-byte Folded Reload</span></span><br><span class="line">	<span class="keyword">add	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#64</span>             <span class="comment">; =64</span></span><br><span class="line">	retab</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        <span class="comment">; -- End function</span></span><br><span class="line">	<span class="meta">.section</span>	__<span class="meta">DATA</span>,__<span class="meta">data</span></span><br><span class="line">	.globl	_g_somedata             <span class="comment">; @g_somedata</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">_g_somedata</span>:</span><br><span class="line">	<span class="meta">.long</span>	<span class="number">102</span>                     <span class="comment">; 0x66</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">.section</span>	__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">l_.str</span>:                                 <span class="comment">; @.str</span></span><br><span class="line">	<span class="meta">.asciz</span>	<span class="string">"call tramp one %d\n"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">.section</span>	__<span class="meta">DATA</span>,__auth_ptr</span><br><span class="line">	.p2align	<span class="number">3</span></span><br><span class="line"><span class="symbol">l__Z8tram_onei$auth_ptr$ia$0</span>:</span><br><span class="line">	.quad	__Z8tram_onei<span class="comment">@AUTH(ia,0)</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure>

<h2 id="返回地址保护"><a href="#返回地址保护" class="headerlink" title="返回地址保护"></a>返回地址保护</h2><p>这里有几个值得注意的地方，第一个是每个嵌套了调用的函数的开头和结尾处都被插入了 PAC 指令：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__Z8tram_onei</span>:</span><br><span class="line">    pacibsp</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">    retab</span><br></pre></td></tr></table></figure>
<p>这里 PAC 用 Instruction Key B 保护了函数的返回地址，有效防止了 JOP 攻击。</p>
<p>再看一下全局变量的声明和访问：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">.section</span>	__<span class="meta">DATA</span>,__<span class="meta">data</span></span><br><span class="line">	.globl	_g_somedata             <span class="comment">; @g_somedata</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">_g_somedata</span>:</span><br><span class="line">	<span class="meta">.long</span>	<span class="number">102</span>                     <span class="comment">; 0x66</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">adrp	</span>x8, _g_somedata<span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">add	</span>x8, x8, _g_somedata<span class="comment">@PAGEOFF</span></span><br><span class="line">	<span class="keyword">ldr	</span>w9, [x8]</span><br></pre></td></tr></table></figure>
<p>可见常规的数值变量并没有在 PAC 的保护之下。</p>
<h2 id="指针保护"><a href="#指针保护" class="headerlink" title="指针保护"></a>指针保护</h2><p>下面我们来看一下函数指针的赋值与调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tram_one</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"call tramp one %d\n"</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step_ptr</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(ptr) = (<span class="keyword">void</span> *)&amp;tram_one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">void</span> *fptr = <span class="literal">NULL</span>;</span><br><span class="line">    step_ptr(fptr);</span><br><span class="line">    (<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> (*)(<span class="keyword">int</span>)&gt;(fptr))(g_somedata);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先可以看到 tram_one 函数地址这一全局符号受到了 PAC 保护：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">.section</span>	__<span class="meta">DATA</span>,__auth_ptr</span><br><span class="line">	.p2align	<span class="number">3</span></span><br><span class="line"><span class="symbol">l__Z8tram_onei$auth_ptr$ia$0</span>:</span><br><span class="line">	.quad	__Z8tram_onei<span class="comment">@AUTH(ia,0)</span></span><br></pre></td></tr></table></figure>

<p><code>step_ptr</code> 函数中对应的访问代码：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__Z8step_ptrPv</span>:</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">	<span class="keyword">adrp	</span>x8, l__Z8tram_onei$auth_ptr$ia<span class="number">$0</span><span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">ldr	</span>x8, [x8, l__Z8tram_onei$auth_ptr$ia<span class="number">$0</span><span class="comment">@PAGEOFF]</span></span><br><span class="line">	<span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<p>在执行 <code>(reinterpret_cast&lt;int (*)(int)&gt;(fptr))(g_somedata);</code> 调用时，采用了带 PAC 验证的指令：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">_main</span>: </span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">    <span class="comment">; x8 = l__Z8tram_onei$auth_ptr$ia$0</span></span><br><span class="line">    <span class="keyword">blraaz	</span>x8</span><br></pre></td></tr></table></figure>

<h1 id="PAC-对-JOP-的影响"><a href="#PAC-对-JOP-的影响" class="headerlink" title="PAC 对 JOP 的影响"></a>PAC 对 JOP 的影响</h1><p>在上一篇文章中我们实现 kexec 的关键在于劫持一个虚函数，这里所修改的地址有：</p>
<ol>
<li>修改虚函数表的 getTargetAndTrapForIndex 指针指向 Gadget；</li>
<li>构造 IOTrap，其 func 指向要执行的内核函数。</li>
</ol>
<p>不幸的是，这两个地址都受到了 PAC 机制的保护[1]，所以我们之前的 kexec 方法在 arm64e 上就失效了。以下的代码摘自于参考资料[1]：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loc_FFFFFFF00808FF00</span></span><br><span class="line">    <span class="keyword">STR </span>       XZR, [<span class="built_in">SP</span>,<span class="number">#0x30</span>+var_28]  <span class="comment">;; target = NULL</span></span><br><span class="line">    <span class="keyword">LDR </span>       X8, [X19]               <span class="comment">;; x19 = userClient, x8 = -&gt;vtable</span></span><br><span class="line">    <span class="comment">; 1. vtable is under protection</span></span><br><span class="line">    AUTDZA     X8                      <span class="comment">;; validate vtable's PAC</span></span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">    <span class="keyword">MOV </span>       X0, X19                 <span class="comment">;; x0 = userClient</span></span><br><span class="line">    <span class="comment">; 2. vtable-&gt;getTargetAndTrapForIndex is under protection</span></span><br><span class="line">    <span class="keyword">BLRAA </span>     X8, X9                  <span class="comment">;; PAC call -&gt;getTargetAndTrapForIndex</span></span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">    <span class="keyword">MOV </span>       X9, <span class="number">#0</span>                  <span class="comment">;; Use context 0 for non-virtual func</span></span><br><span class="line">    <span class="keyword">B </span>         loc_FFFFFFF00808FF70</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_FFFFFFF00808FF70</span></span><br><span class="line">   <span class="comment">; ... not set x9</span></span><br><span class="line">   <span class="comment">; 3. trap-&gt;func is under protection</span></span><br><span class="line">   <span class="keyword">BLRAA </span>     X8, X9                  <span class="comment">;; PAC call func(target, p1, ..., p6)</span></span><br><span class="line">   <span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<p>由上面的代码可知，在 arm64e 架构的 iOS 12.1.2 内核代码中，虚函数表、虚函数指针和 IOTrap 的函数指针都得到了 PAC 保护。</p>
<p><strong>需要特别注意的是，这里的 trap-&gt;func 调用所使用的 context 寄存器 X9 被写入了 0，即 BLRAA 相当于验签了一个 PACIZA 签名的地址，这是实现第一个受限 kexec 的重要突破口。</strong></p>
<h1 id="绕过-PAC-的理论分析"><a href="#绕过-PAC-的理论分析" class="headerlink" title="绕过 PAC 的理论分析"></a>绕过 PAC 的理论分析</h1><h2 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h2><p>在 参考资料[1] 的 write-up 中很大篇幅讲述了从软件白盒、硬件黑盒的角度对 PAC 进行的分析与绕过尝试，并得到了如下结论：</p>
<ol>
<li>储存 PAC Key 的寄存器只能在 EL1 模式下访问，而用户态处于 EL0，无法直接访问这些系统寄存器；</li>
<li>即使我们能从内核的内存中读取到 PAC Key，如果不能逆向出完整的加解密过程，依然无法伪造签名；</li>
<li>Apple 在 EL0 和 EL1 中使用了不同的 PAC Key，这就打破了 Croess-EL PAC Forgeries；</li>
<li>Apple 在实现 PACIA, PACIB, PACDA 和 PACDB 这些指令时采用了不同的算法，即使全部使用相同的 Key 也会得到不同的结果，这就打破了 Cross-Key Symmetry；</li>
<li>虽然在软件层面看 PAC Key 是 hardcode 的，但事实证明每次启动 PAC Key 都会变化。</li>
</ol>
<p>这 5 条限制每一条都刺痛着尝试绕过 PAC 的人们的心，可见苹果在这一方面做了非常多变态的保护企图将 JOP 彻底解决。此外苹果还在公开的 XNU 代码中删除了与 PAC 相关的细节，并通过控制流混淆等手段阻止黑客在 kernelcache 中轻易找到可用的 Signing Gadgets。</p>
<h2 id="有利条件"><a href="#有利条件" class="headerlink" title="有利条件"></a>有利条件</h2><p>不得不佩服这些内核大佬的功力，即使在如此重重保护下 Brandon Azad 依然找到了 PAC 在实现上的一些软件漏洞：</p>
<ol>
<li>PAC 在进行验签时，如果发现验签失败，它会将 2 位 error code 插入到指针的 62~61 区域，这里是 pointer’s extension bits；</li>
<li>PAC 在执行签名时，如果发现指针的 extension bits 异常，它仍然会插入正确的签名，只是会通过翻转 PAC 的最高位 (第 62 位) 来使指针失效。</li>
</ol>
<p>有趣的事情来了，如果我们把一个常规的地址交给 PAC 验签 (<code>AUT*</code>)，那么它会给指针的 extension bits 插入一个 error code 使其异常。此后如果再将这个值进行签名 (<code>PAC*</code>)，由于 error code 的存在会签名失败，但是正确的 PAC 依然会被计算并插入，只是指针的第 62 位被翻转了。因此我们只要找到一个先对指针的值进行 <code>AUT*</code>，随后再进行 <code>PAC*</code> 最后将值写入固定内存的代码片段即可作为 Signing Gadget。</p>
<h2 id="PACIZA-Signing-Gadget"><a href="#PACIZA-Signing-Gadget" class="headerlink" title="PACIZA Signing Gadget"></a>PACIZA Signing Gadget</h2><p>基于上面的理论，Brandon Azad 在 arm64e 的 kernelcache 中发现了一个满足上述有利条件的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sysctl_unregister_oid</span><span class="params">(sysctl_oid *oidp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sysctl_oid *removed_oidp = <span class="literal">NULL</span>;</span><br><span class="line">   sysctl_oid *old_oidp = <span class="literal">NULL</span>;</span><br><span class="line">   BOOL have_old_oidp;</span><br><span class="line">   <span class="keyword">void</span> **handler_field;</span><br><span class="line">   <span class="keyword">void</span> *handler;</span><br><span class="line">   <span class="keyword">uint64_t</span> context;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> ( !(oidp-&gt;oid_kind &amp; <span class="number">0x400000</span>) )         <span class="comment">// Don't enter this if</span></span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( oidp-&gt;oid_version != <span class="number">1</span> )               <span class="comment">// Don't enter this if</span></span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   sysctl_oid *first_sibling = oidp-&gt;oid_parent-&gt;first;</span><br><span class="line">   <span class="keyword">if</span> ( first_sibling == oidp )                <span class="comment">// Enter this if</span></span><br><span class="line">   &#123;</span><br><span class="line">       removed_oidp = <span class="literal">NULL</span>;</span><br><span class="line">       old_oidp = oidp;</span><br><span class="line">       oidp-&gt;oid_parent-&gt;first = old_oidp-&gt;oid_link;</span><br><span class="line">       have_old_oidp = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   handler_field = &amp;old_oidp-&gt;oid_handler;</span><br><span class="line">   handler = old_oidp-&gt;oid_handler;</span><br><span class="line">   <span class="keyword">if</span> ( removed_oidp || !handler )             <span class="comment">// Take the else</span></span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       removed_oidp = <span class="literal">NULL</span>;</span><br><span class="line">       context = (<span class="number">0x14EF</span> &lt;&lt; <span class="number">48</span>) | ((<span class="keyword">uint64_t</span>)handler_field &amp; <span class="number">0xFFFFFFFFFFFF</span>);</span><br><span class="line">       *handler_field = ptrauth_sign_unauthenticated(</span><br><span class="line">               ptrauth_auth_function(handler, ptrauth_key_asia, &amp;context),</span><br><span class="line">               ptrauth_key_asia,</span><br><span class="line">               <span class="number">0</span>);</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在代码的最底部有一个 unauth 与 auth 的嵌套调用，先对 handler 执行 auth 即 <code>AUT*</code>，随后立即执行 unauth，即 <code>PAC*</code>，正好满足了 Signing Gadget 条件。另外一个重要条件是签名结果必须写入稳定的内存，使得我们能够轻易、稳定地读取到。这里写入的 <code>handler_field</code> 指向 <code>old_oidp-&gt;oid_handler</code>，继续分析可知它来自于函数入参的 <code>oidp</code>。</p>
<h3 id="寻找-Gadget"><a href="#寻找-Gadget" class="headerlink" title="寻找 Gadget"></a>寻找 Gadget</h3><p>下一步的关键就是如何触发 <code>sysctl_unregister_oid</code> 并控制 <code>oidp</code> 的值。幸运的是 <code>sysctl_oid</code> 是被 <code>global sysctl tree</code> 所持有的，用于向内核中注册参数。虽然没有任何直接指向 <code>sysctl_unregister_oid</code> 的指针，但许多 kext 在启动时会通过 sysctl 注册参数，在结束时会通过 <code>sysctl_unregister_oid</code> 实现反注册，这是一个重要的线索。</p>
<p>最终 Brandon Azad 在 <code>com.apple.nke.lttp</code> 这一 kext 中找到了一对函数 <code>l2tp_domain_module_stop</code> 和 <code>l2tp_domain_module_start</code>，调用前者时会传递一个全局变量 <code>sysctl__net_ppp_l2tp</code> 来实现反注册，调用后者可以重新启动模块，并且这对函数包含可被定位的引用，该引用是通过 Instruction Key A 无 Context 签名的。</p>
<p>还记得文章开头提到的非虚函数地址在进行 <code>IOTrap-&gt;func</code> 调用时也是通过 Instruction Key A 和无 Context 进行验签的。因此我们只需要通过 XREF 技术定位到函数地址和全局变量地址，即可通过修改 <code>sysctl__net_ppp_l2tp</code> 来篡改 <code>old_oidp-&gt;oid_handler</code>，接下来只要找到调用 <code>l2tp_domain_module_stop</code> 的方法就可以实现对任意地址的 PACIZA 签名了。</p>
<h3 id="触发-Gadget"><a href="#触发-Gadget" class="headerlink" title="触发 Gadget"></a>触发 Gadget</h3><p>似乎找到 <code>l2tp_domain_module_stop</code> 和找到一个 kexec 一样困难，但事实上它比一个完整的 kexec 简单的多，这是因为 <code>l2tp_domain_module_stop</code> 是无参的。我们依然可以尝试利用 IOTrap，但这一次我们无法劫持虚函数，因此需要找到一个已存在的包含 IOTrap 调用的对象。</p>
<p>所幸 Brandon Azad 在 kernelcache 中找到了一个 IOAudio2DeviceUserClient 类，它默认实现了 getTargetAndTrapForIndex 并提供了一个 IOTrap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOExternalTrap *<span class="title">IOAudio2DeviceUserClient::getTargetAndTrapForIndex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       IOAudio2DeviceUserClient *<span class="keyword">this</span>, IOService **target, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   *target = (IOService *)<span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;IOAudio2DeviceUserClient.traps[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IOAudio2DeviceUserClient::initializeExternalTrapTable() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;IOAudio2DeviceUserClient.trap_count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;IOAudio2DeviceUserClient.traps = IOMalloc(<span class="keyword">sizeof</span>(IOExternalTrap));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>getTargetAndTrapForIndex</code> 将 target 指定为自己，这使得 <code>trap-&gt;func</code> 调用的隐含参数无法修改，即通过这种方式无法传递 arg0，也就只能通过篡改 <code>trap-&gt;func</code> 实现无参函数或是代码块的调用。</p>
<p>基于上述讨论，整个 PACIZA Signing Gadget 的构造和调用过程如下：</p>
<ol>
<li>通过 IOKit 的 userland 接口启动一个 IOAudio2DeviceService，获取到 IOAudio2DeviceUserClient 的 <code>mach_port</code> 句柄；</li>
<li>通过句柄找到其 <code>ipc_port</code>，其 <code>ip_kobject</code> 指针指向的是真正的 IOAudio2DeviceUserClient 对象。先记录下对象地址，随后在对象上找到 traps 地址，由于 IOAudio2DeviceUserClient 只声明了一个 trap，traps 的首地址即我们要修改的 IOTrap 的地址；</li>
<li>通过 String XREF 技术定位 <code>l2tp_domain_module_start</code>, <code>l2tp_domain_module_stop</code> 和 <code>sysctl__net_ppp_l2tp</code> 的地址，先缓存原始的 <code>sysctl_oid</code>，随后构造 <code>sysctl_oid</code> 满足 <code>sysctl_unregister_oid</code> 特定的执行路径，最后将 <code>sysctl_oid-&gt;oid_handler</code> 赋值为需要签名的地址；</li>
<li>修改第 2 步找到的 trap，将其 func 指向 <code>l2tp_domain_module_stop</code>，并通过 IOConnectTrap6 触发 IOAudio2DeviceUserClient 对象的 <code>IOTrap-&gt;func</code> 调用，这里便实现了对 <code>l2tp_domain_module_stop</code> 的调用，随后会执行到 <code>sysctl_unregister_oid</code>，并将签名失败的结果写入 <code>sysctl__net_ppp_l2tp-&gt;oid_handler</code>，此时我们可以读取结果，并翻转第 62 位得到正确的签名；</li>
<li>最后一步是通过 <code>l2tp_domain_module_start</code> 重启服务，但这里需要传递新的 <code>sysctl_oid</code> 作为入参，通过上面的 Primitives 是无法完成的。</li>
</ol>
<h2 id="清理环境"><a href="#清理环境" class="headerlink" title="清理环境"></a>清理环境</h2><p>由于 IOAudio2DeviceUserClient 的 IOTrap 调用仅能实现无参的 kexec，我们无法在完成 PACIZA 签名后重启 IOAudio2DeviceUserClient 服务，这会使得 Signing Gadget 失去幂等性，或是留下其他隐患，因此必须找到一个能有参调用 kexec 的办法来重启服务。</p>
<p>问题的关键是 <code>IOTrap-&gt;func</code> 调用时 arg0 指向了 this，因此单次调用时肯定无法修改 arg0 了，我们这里可以尝试多次跳转。所幸在 kernelcache 中有这样的一段代码：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV </span>        X0, X4</span><br><span class="line"><span class="keyword">BR </span>         X5</span><br></pre></td></tr></table></figure>
<p>由于我们通过 IOConnectTrap6 能控制 x1 ~ x6，所以通过 x4 既能间接控制 x0，x5 即是下一跳的地址，我们先让 <code>IOTrap-&gt;func</code> 指向这一片段的 PACIZA’d 地址，然后通过 x4 控制 arg0，x1 ~ x3 控制 arg1 ~ arg3，x5 控制 JOP 的目标地址，即可实现一个 4 个参数的 kexec。</p>
<p>因此我们只需要用上面的无参调用去签名一下上述代码块的地址，然后将其作为 <code>IOTrap-&gt;func</code> 的地址，再通过 IOConnectTrap6 的入参控制 x1 ~ x5 即可实现对 <code>l2tp_domain_module_start</code> 的带参调用，这里传递的是之前备份的 <code>sysctl_oid</code>，从而完美的恢复现场。</p>
<p>到这里，一个完美的 PACIZA Signing Gadget 就达成了，同时我们还得到了一个非常有用的代码片段的 PACIZA 签名：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV </span>        X0, X4</span><br><span class="line"><span class="keyword">BR </span>         X5</span><br></pre></td></tr></table></figure>
<p>我们将其称为 G1，也是这是后续工作的一个重要 Gadget。</p>
<h2 id="PACIA-amp-PACDA-Signing-Gadget"><a href="#PACIA-amp-PACDA-Signing-Gadget" class="headerlink" title="PACIA &amp; PACDA Signing Gadget"></a>PACIA &amp; PACDA Signing Gadget</h2><p>遗憾的是许多调用点（例如虚函数）都采用了带有 Context 的调用方式，例如上文中提到的片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context = (<span class="number">0x14EF</span> &lt;&lt; <span class="number">48</span>) | ((<span class="keyword">uint64_t</span>)handler_field &amp; <span class="number">0xFFFFFFFFFFFF</span>);</span><br><span class="line">*handler_field = ptrauth_sign_unauthenticated(</span><br><span class="line">       ptrauth_auth_function(handler, ptrauth_key_asia, &amp;context),</span><br><span class="line">       ptrauth_key_asia,</span><br><span class="line">       <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这就要求我们找到包含 PACIA 和 PACDA 的代码块，且他们要将签名结果写入稳定的内存。所幸这样的 Gadget 也是存在的：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; sub_FFFFFFF007B66C48</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">PACIA</span>       X9, X10</span><br><span class="line"><span class="keyword">STR </span>        X9, [X2,<span class="number">#0x100</span>]</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">PACDA</span>       X9, X10</span><br><span class="line"><span class="keyword">STR </span>        X9, [X2,<span class="number">#0xF8</span>]</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">PACIBSP</span></span><br><span class="line"><span class="symbol">STP</span>         X20, X19, [<span class="built_in">SP</span>,<span class="symbol">#var_20</span>]!</span><br><span class="line"><span class="symbol">...</span>         <span class="comment">;; Function body (mostly harmless)</span></span><br><span class="line"><span class="symbol">LDP</span>         X20, X19, [<span class="built_in">SP</span>+<span class="number">0x20</span>+var_20],<span class="number">#0x20</span></span><br><span class="line"><span class="symbol">AUTIBSP</span></span><br><span class="line"><span class="keyword">MOV </span>        W0, <span class="number">#0</span></span><br><span class="line"><span class="symbol">RET</span></span><br></pre></td></tr></table></figure>

<p>这一段代码同时包含了 PACIA 和 PACDA，且后续都通过 STR 写入了内存。唯一不足的是在执行完语句后距离 RET 还有很远的距离，且当前入口点位于函数的中间位置。所幸函数真正的开场白位于这些指令之后：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PACIBSP</span></span><br><span class="line"><span class="symbol">STP</span>         X20, X19, [<span class="built_in">SP</span>,<span class="symbol">#var_20</span>]!</span><br><span class="line"><span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<p>所以似乎我们从中部进入函数不会有太多的不良影响，在这里我们只需要控制 x9 作为指针，x10 作为 context，x2 控制写入的内存区域，即可实现一个 PACIA &amp; PACDA 的签名伪造。</p>
<p>但是基于 IOAudio2DeviceUserClient 的 IOConnectTrap6 我们只能控制 x1 ~ x6，无法直接控制 x9 和 x10，这里就需要我们寻找更多的 Gadget 来实现组合调用来控制 x9 和 x10。</p>
<p>随后 Brandon Azad 在 kernelcache 中又搜索到了几个可利用的 Gadget，截止到目前我们总共有 3 个可用的 Gadget：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; G1</span></span><br><span class="line"><span class="keyword">MOV </span>        X0, X4</span><br><span class="line"><span class="keyword">BR </span>         X5</span><br><span class="line"></span><br><span class="line"><span class="comment">; G2</span></span><br><span class="line"><span class="keyword">MOV </span>        X9, X0</span><br><span class="line"><span class="keyword">BR </span>         X1</span><br><span class="line"></span><br><span class="line"><span class="comment">; G3</span></span><br><span class="line"><span class="keyword">MOV </span>        X10, X3</span><br><span class="line"><span class="keyword">BR </span>         X6</span><br></pre></td></tr></table></figure>

<p>G1 使我们能通过 x4 控制 x0，再通过 G2 可将 x0 写入 x9，最后通过 G3 将 x3 写入 x10，G1 -&gt; G2 通过 X5 指向 G2 实现，G2 - &gt; G3 通过 X1 指向 G3 实现，最后通过 x6 即可跳转到包含 PACIA &amp; PACDA 的 Gadget，此时 x2, x9, x10 均已间接填入合适的参数，因此可以完成一个 PACIA &amp; PACDA Forgery。</p>
<p>上述调用环环相扣，且不能有任何寄存器上的重叠，否则将无法有效地准备参数，我们难以想象找到这么一组 Gadget 耗费了多么大的精力，在这里向大佬致敬。基于上述讨论，我们以 G1 为 <code>IOTrap-&gt;func</code> 的入口点，如下准备 IOConnectTrap6 的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trap-&gt;func = paciza(G1);</span><br><span class="line">arg1 = x1 = G3;</span><br><span class="line">arg2 = x2 = buffer_to_save_pacxad_pointer;</span><br><span class="line">arg3 = x3 = context;</span><br><span class="line">arg4 = x4 = pointer;</span><br><span class="line">arg5 = x5 = G2;</span><br><span class="line">arg6 = x6 = sub_FFFFFFF007B66C48_PACXA_ENTRY</span><br></pre></td></tr></table></figure>

<p>这会形成一个链式调用，控制流如下：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV </span>        X0, X4 </span><br><span class="line"><span class="keyword">BR </span>         X5  </span><br><span class="line"><span class="keyword">MOV </span>        X9, X0</span><br><span class="line"><span class="keyword">BR </span>         X1</span><br><span class="line"><span class="keyword">MOV </span>        X10, X3</span><br><span class="line"><span class="keyword">BR </span>         X6</span><br><span class="line"><span class="symbol">PACIA</span>       X9, X10</span><br><span class="line"><span class="keyword">STR </span>        X9, [X2,<span class="number">#0x100</span>]</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">PACDA</span>       X9, X10</span><br><span class="line"><span class="keyword">STR </span>        X9, [X2,<span class="number">#0xF8</span>]</span><br><span class="line"><span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<p>到这里我们就通过一系列的 Gadget 和 IOConnectTrap6 实现了 PACIA &amp; PACDA 的 Forgery。</p>
<h2 id="完美的-kexec"><a href="#完美的-kexec" class="headerlink" title="完美的 kexec"></a>完美的 kexec</h2><p>到这里我们已经可以伪造 Key A 的任意签名，但依然没有实现完美的 kexec，此时我们还只能实现 4 个参数的 kexec，其根本原因是我们依赖于 IOAudio2DeviceUserClient 对 getTargetAndTrapForIndex 的默认实现，遗憾的是这一实现中将 target 设置为了 this 从而导致我们无法直接控制 arg0，转向 Gadget 后则会遇到 4 个参数的限制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOExternalTrap *<span class="title">IOAudio2DeviceUserClient::getTargetAndTrapForIndex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       IOAudio2DeviceUserClient *<span class="keyword">this</span>, IOService **target, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   *target = (IOService *)<span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;IOAudio2DeviceUserClient.traps[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能实现完美的 kexec，最好的办法依然是劫持虚函数，虽然 PAC 对虚函数表和虚函数指针做了签名，但它是通过 Key A 完成的，到这里我们已经能够伪造这些签名，从而再次实现虚函数的劫持。</p>
<h3 id="修改-getTargetAndTrapForIndex-为默认实现"><a href="#修改-getTargetAndTrapForIndex-为默认实现" class="headerlink" title="修改 getTargetAndTrapForIndex 为默认实现"></a>修改 getTargetAndTrapForIndex 为默认实现</h3><p>IOAudio2DeviceUserClient 覆盖实现的 getTargetAndTrapForIndex 给我们带来了麻烦，这里我们可以将其修改为父类的默认实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IOExternalTrap * IOUserClient::</span><br><span class="line">getTargetAndTrapForIndex(IOService ** targetP, UInt32 index)</span><br><span class="line">&#123;</span><br><span class="line">      IOExternalTrap *trap = getExternalTrapForIndex(index);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (trap) &#123;</span><br><span class="line">              *targetP = trap-&gt;object;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> trap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 IOAudio2DeviceUserClient 的 traps 不是通过 getExternalTrapForIndex 取得的，这里我们还需要继续修改 getExternalTrapForIndex 方法，使其能够返回一个构造的 IOTrap，这里遇到的一个问题是父类默认实现为返回空值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOExternalTrap * IOUserClient::</span><br><span class="line">getExternalTrapForIndex(UInt32 index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就需要我们在 IOUserClient 上找到一个合适的函数和成员变量，使得该函数返回成员变量或成员变量的某个引用，这样我们就能间接地通过控制成员变量来返回特定的 IOTrap。幸运的是 IOUserClient 间接继承了超类 IORegistryEntry，它包含了一个 reserved 成员和一个返回该成员的成员函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IORegistryEntry</span> :</span> <span class="keyword">public</span> OSObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">/*! @var reserved</span></span><br><span class="line"><span class="comment">    Reserved for future use.  (Internal use only)  */</span></span><br><span class="line">    ExpansionData * reserved;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint64_t</span> <span class="title">IORegistryEntry::getRegistryEntryID</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reserved)</span><br><span class="line">    	<span class="keyword">return</span> (reserved-&gt;fRegistryEntryID);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可见我们只要将虚函数表中的 <code>getExternalTrapForIndex</code> 指向 <code>IORegistryEntry::getRegistryEntryID</code>，再修改 UserClient 实例的 reversed 使其 <code>reserved-&gt;fRegistryEntryID</code> 指向我们构造的 IOTrap 即可。</p>
<p>通过上述改造，我们再次获得了一个完美的支持 7 个入参的 kexec，<strong>理论分析起来容易，要实施这一过程是十分复杂的，因为每一个虚函数所使用的 sign context 是不同的，这就要求 dump 出所有的 sign context 再进行处理</strong>。</p>
<h1 id="绕过-PAC-的代码导读"><a href="#绕过-PAC-的代码导读" class="headerlink" title="绕过 PAC 的代码导读"></a>绕过 PAC 的代码导读</h1><p>经过理论分析相信读者已经对整个绕过的过程有了整体认识，由于整个过程太过复杂，单单进行理论分析难免会让人云里雾里，将上述理论分析结合阅读 Undecimus 中的代码可以很好的加深理解。</p>
<p>这部分代码位于上一篇文章提到的 <code>init_kexec</code> 和 <code>kexec</code> 两个函数中，针对 arm64e 架构采用了完全不同的手段。<strong>鉴于本文的理论分析部分已涉及到大量的代码，这里不再完整的进行分析，只说几个理论分析中未完全提及的内容</strong>。完整的代码请读者结合上述理论分析自行阅读，相信你会有很大的收获。</p>
<p>经过上面的分析相信读者能够轻易地理解 <code>kernel_call_init</code> 中的 <code>stage1_kernel_call_init</code> 和 <code>stage2_kernel_call_init</code>，这两个阶段主要是完成 UserClient 的启动和 G1 的签名工作，需要注意的是在 <code>stage2_kernel_call_init-&gt;stage1_init_kernel_pacxa_forging</code> 的结尾处创建了一个 buffer，用来存储新的虚函数表以及 PACIA &amp; PACDA 的签名结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stage1_init_kernel_pacxa_forging() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    kernel_pacxa_buffer = stage1_get_kernel_buffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外 A12 在 iOS 12.1.2 的 PAC 机制也允许在 userland 通过 XPAC 指令直接将一个加签的指针还原，这给我们拷贝虚函数表带来了极大的便利，这段代码位于 <code>stage3_kernel_call_init</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span></span><br><span class="line">kernel_xpacd(<span class="keyword">uint64_t</span> pointer) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">	<span class="keyword">return</span> xpacd(pointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> pointer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> *</span><br><span class="line">stage2_copyout_user_client_vtable() &#123;</span><br><span class="line">	<span class="comment">// Get the address of the vtable.</span></span><br><span class="line">	original_vtable = kernel_read64(user_client);</span><br><span class="line">	<span class="keyword">uint64_t</span> original_vtable_xpac = kernel_xpacd(original_vtable);</span><br><span class="line">	<span class="comment">// Read the contents of the vtable to local buffer.</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *vtable_contents = <span class="built_in">malloc</span>(max_vtable_size);</span><br><span class="line">	assert(vtable_contents != <span class="literal">NULL</span>);</span><br><span class="line">	kernel_read(original_vtable_xpac, vtable_contents, max_vtable_size);</span><br><span class="line">	<span class="keyword">return</span> vtable_contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 patch 虚函数表时，每个函数都有其特定的 context，因此这里使用了 dump 出来的对应于每个虚函数的 PAC Code，这段代码位于 <code>stage2_patch_user_client_vtable</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">stage2_patch_user_client_vtable(<span class="keyword">uint64_t</span> *vtable) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">	assert(count &lt; VTABLE_PAC_CODES(IOAudio2DeviceUserClient).count);</span><br><span class="line">	vmethod = kernel_xpaci(vmethod);</span><br><span class="line">	<span class="keyword">uint64_t</span> vmethod_address = kernel_buffer + count * <span class="keyword">sizeof</span>(*vtable);</span><br><span class="line">	vtable[count] = kernel_forge_pacia_with_type(vmethod, vmethod_address,</span><br><span class="line">			VTABLE_PAC_CODES(IOAudio2DeviceUserClient).codes[count]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __arm64e__</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里针对每个虚函数都采用了不同的 PAC Code，dump 出的 PAC Code 通过静态变量存储，并借助宏 <code>VTABLE_PAC_CODES</code> 进行访问，这里的每个 context 长度只有 16 位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pac__iphone11_8__16C50() &#123;</span><br><span class="line">    INIT_VTABLE_PAC_CODES(IOAudio2DeviceUserClient,</span><br><span class="line">    	<span class="number">0x3771</span>, <span class="number">0x56b7</span>, <span class="number">0xbaa2</span>, <span class="number">0x3607</span>, <span class="number">0x2e4a</span>, <span class="number">0x3a87</span>, <span class="number">0x89a9</span>, <span class="number">0xfffc</span>,</span><br><span class="line">    	<span class="number">0xfc74</span>, <span class="number">0x5635</span>, <span class="number">0xbe60</span>, <span class="number">0x32e5</span>, <span class="number">0x4a6a</span>, <span class="number">0xedc5</span>, <span class="number">0x5c68</span>, <span class="number">0x6a10</span>,</span><br><span class="line">    	<span class="number">0x7a2a</span>, <span class="number">0xaf75</span>, <span class="number">0x137e</span>, <span class="number">0x0655</span>, <span class="number">0x43aa</span>, <span class="number">0x12e9</span>, <span class="number">0x4578</span>, <span class="number">0x4275</span>,</span><br><span class="line">    	<span class="number">0xff53</span>, <span class="number">0x1814</span>, <span class="number">0x122e</span>, <span class="number">0x13f6</span>, <span class="number">0x1d35</span>, <span class="number">0xacb1</span>, <span class="number">0x7eb0</span>, <span class="number">0x1262</span>,</span><br><span class="line">    	<span class="number">0x82eb</span>, <span class="number">0x164e</span>, <span class="number">0x37a5</span>, <span class="number">0xb659</span>, <span class="number">0x6c51</span>, <span class="number">0xa20f</span>, <span class="number">0xb3b6</span>, <span class="number">0x6bcb</span>,</span><br><span class="line">    	<span class="number">0x5a20</span>, <span class="number">0x5062</span>, <span class="number">0x00d7</span>, <span class="number">0x7c85</span>, <span class="number">0x8a26</span>, <span class="number">0x3539</span>, <span class="number">0x688b</span>, <span class="number">0x1e60</span>,</span><br><span class="line">    	<span class="number">0x1955</span>, <span class="number">0x0689</span>, <span class="number">0xc256</span>, <span class="number">0xa383</span>, <span class="number">0xf021</span>, <span class="number">0x1f0a</span>, <span class="number">0xb4bb</span>, <span class="number">0x8ffc</span>,</span><br><span class="line">    	<span class="number">0xb5b9</span>, <span class="number">0x8764</span>, <span class="number">0x5d96</span>, <span class="number">0x80d9</span>, <span class="number">0x0c9c</span>, <span class="number">0x5d0a</span>, <span class="number">0xcbcc</span>, <span class="number">0x617d</span></span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他部分基本在理论分析中都已提到，这里不再赘述。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了 PAC 缓解措施的特点以及 iOS 12.1.2 在 A12 上的绕过方法，整个过程可以说是让人叹为观止。通过研究整个 bypass 过程不仅让我们对 PAC 机制有了更深刻的认识，也学到了许多 JOP 的骚操作。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html" target="_blank" rel="noopener">Brandon Azad, Project Zero. Examining Pointer Authentication on the iPhone XS</a> </li>
<li><a href="https://github.com/pwn20wndstuff/Undecimus/blob/9d7a1076a2b088b25677f4a53822a3c396b1b837/Undecimus/source/jailbreak.m" target="_blank" rel="noopener">pwn20wndstuff. Undecimus</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">高级页面仔 (Soulghost)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.asm.im/2020/02/11/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%95%E8%BF%87-A12-%E7%9A%84-PAC-%E5%AE%9E%E7%8E%B0-kexec/">http://blog.asm.im/2020/02/11/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%95%E8%BF%87-A12-%E7%9A%84-PAC-%E5%AE%9E%E7%8E%B0-kexec/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JailBreak/">JailBreak</a><a class="post-meta__tags" href="/tags/Undecimus/">Undecimus</a><a class="post-meta__tags" href="/tags/KEXEC/">KEXEC</a><a class="post-meta__tags" href="/tags/PAC/">PAC</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/06/iOS-Jailbreak-Principles-0x01-rootfs-remount-r-w-%E5%8E%9F%E7%90%86/"><i class="fa fa-chevron-left">  </i><span>iOS Jailbreak Principles 0x01 - rootfs remount r/w 原理</span></a></div><div class="next-post pull-right"><a href="/2020/01/12/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E8%BF%87-IOTrap-%E5%AE%9E%E7%8E%B0%E5%86%85%E6%A0%B8%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"><span>Undecimus 分析（三）通过 IOTrap 实现内核任意代码执行</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 高级页面仔 (Soulghost)</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="footer_custom_text"><i class="fa fa-user"> 0xfffffff007004000</i><span class="footer-separator">|</span><i class="fa fa-eye"> 0x2004000</i></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>